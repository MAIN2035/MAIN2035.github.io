# 垃圾收集器与内存分配

### 判断对象是否存活

* 引用计数算法：每个对象都有一个引用计数器，每当被一个地方引用时计数器值便加一，每当失去一个引用计数器值便减一（不采用）

* 可达性分析算法：通过**GCRoots**根对象作为起点，根据引用关系向下搜索，构成一条**引用链**如果某个对象到**GCRoots**间没有任何引用链，那么这个对象就是可回收的。

  <img src="/home/garfield/桌面/screenshot_2020_07_30T20_21_36+0800.jpg" style="zoom:50%;" />

### 回收对象、方法区

#### 回收对象：

* 可达性分析算法中可回收的对象并**不会被立即回收**，而是对其进行第二次筛选；
* 如此对象有覆盖finalize（）方法且此方法且未被虚拟机调用，则执行finalize（）方法，并将其放入F—Queue队列中（**低优先级的Finalizer线程**将执行finalize（）方法），在此期间如**对象与引用链建立联系则不会被回收**（如赋值、引用等）

#### 回收方法区：

* 方法区的垃圾回收分为两部分，**废弃的常量**与**不再使用的类型**：

1. 废弃的常量：一个常量**不被引用**，则这个常量将被从常量池中清除（接口、方法、字段符号与之类似）
2. 不再使用的类型：需要满足以下3个条件方**可被回收**（而不是立即回收）
   * 该类不存在**任何实例**（实例均被回收）
   * 加载该类的**加载器**已被回收
   * 该类对应的**class对象没有被引用**，且**无法通过反射**访问该类的方法

### 四种引用：

1. 强引用：指程序中普遍存在的引用赋值；被强引用关联的对象**只要强引用关系存在**，被引用的对象就不会被回收
2. 软引用：指有用而非必须的对象；被软引用关联的对象在**系统发生内存溢出之前**会将其回收
3. 弱引用：指非必须的对象（比软引用弱）；被弱引用关联的对象**在下一次垃圾回收前无论内存是否足够**，均将其回收
4. 虚引用：无法通过此引用来取得对象实例，使用此引用**只是为了在对象被回收时收到一个系统通知**

### 追踪式垃圾回收算法

####　分代收集

* 分代假说

1. 弱分代假说（新生代）：大多数对象都是朝生夕灭
2. 强分代假说（老年代）：对象熬过的收集次数越多就越难被回收
3. 跨代引用假说：跨代引用相对于同代引用仅占少数

* 垃圾分类：根据强、弱分代假说，将**Java堆**分为两个内存区域分别**存储新生代与老年代**，每次回收后存活的新生代对象将逐步晋升到老年代中。
* 老年代引用新生代：相互引用的两个对象应**同生同灭**，所以该**新生代会逐步晋升**到老年代中从而**消除跨代引用**
* 根据跨带引用假说，在新生代上建立全局数据结构“记忆集”，这个集合中标记存在**跨代引用**的老年代，收集扫描时仅扫描此集合中标识的老年代

#### 标记清除算法

* 标记需要**回收**的对象，清除所有**标记**的对象
* 标记需要**保**存的对象，清除所有**未标记**的对象

* 缺点：**标记清除算法**需要大量的标记、清除动作，且清除后会产生大量不连续的内存空间（可能导致无法为大的对象分配内存）

<img src="/home/garfield/桌面/screenshot_2020_07_31T12_32_20+0800.jpg" style="zoom:50%;" />

#### 标记整理算法

* 标记过程与**标记清除算法**相同，但并不直接对可回收对象进行回收，而是让所有存活对象向内存空间一端移动，然后直接清除另外一端
* 缺点：移动对象操作时需全程暂停用户应用程序
* 和稀泥式解决方案：令虚拟机使用**标记清除算法**直到内存碎片化程度影响到对象内存分配，再使用**标记整理算法**

<img src="/home/garfield/桌面/screenshot_2020_07_31T12_359+0800.jpg" style="zoom:50%;" />

#### 标记复制算法

* 将内存分为两块，每次只使用一块，当这块内存满时将其中存活的对象复制到另一块内存中，并自我清除。

* 缺点：**标记复制算法**需要大量的内存空间，且内存中回收对象的数量直接影响着此算法的效率。

* 此算法常用于**新生代**回收

  <img src="/home/garfield/桌面/screenshot_2020_07_31T12_35_49+0800.jpg" style="zoom:50%;" />

##### Appel式回收（标记复制算法的改进）

* 将新生代分为一块较大的Eden空间与两块较小的Survivor空间。
* 分配内存时使用Eden与一块Survivor，回收时将使用的Eden与Survivor上存活的对象复制到另一块Survivor上，并自我清除。
* 当另一块Survivor空间装不下**已使用**的Eden与Survivor中的存活对象时，就会发生**分配担保**（装不下的存活对象直接晋升至老年代）

