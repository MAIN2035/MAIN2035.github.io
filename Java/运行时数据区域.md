# 运行时数据区域

<img src="https://i.loli.net/2020/07/30/eLwO5syKpnhjivJ.png" style="zoom:25%;" />



* 程序计数器：每个线程都有一个程序计数器，它指示当前线程所执行字节码的行号

* Java虚拟机栈：每个方法执行时均会创建一个栈帧，其存储**局部变量表**（基本类型与对象引用）、操作数栈、动态连接、方法出口等信息

* 本地方法栈：与Java虚拟机栈类似，其**为本地方法服务**

* Java堆（GC堆）：在虚拟机运行时创建用以存放对象实例，且为所有线程共享。

* 方法区：存储已被虚拟机加载的类型信息、常量、静态变量、编译后的代码缓存等数据，且为所有线程共享。

  1. 运行时常量池：属于方法区，在加载类后class文件中的常量池表（字面量、符号引用）将存入运行时常量池

  

* 直接内存（不属于运行时数据区域）：基于通道与缓冲区的I/O方式，其使用Native函数库直接分配堆外内存，并通过存储在Java堆中的*DirectByteBuffer*对象作为这块内存的引用进行操作

## 对象的创建与访问

### 类的加载：

* 创建对象时，虚拟机首先检测这个类是否已被**加载、解析、初始化**，如没有则首先执行**类的加载过程**。

### 为对象分配内存：

* 垃圾收集器的**空间整理能力**决定**堆是否规整**

#### 分配堆内存的两种方式：

##### 指针碰撞：

* **Java堆内存是规整的**，有一个指针其两边分别是已使用、未使用的堆内存，分配内存时把指针向未使用的一边挪动一段与对象大小相同的距离

![](https://i.loli.net/2020/07/30/tV7RKAgXQWTykm5.png)

##### 空闲列表：

* **Java堆内存不是规整的**，使用与未使用的堆内存纵横交错，需要使用一个列表记录未使用的堆内存，分配内存时从列表中找到一块足够大的堆内存分配给对象

![](https://i.loli.net/2020/07/30/KoeInBvdQrjkEYS.png)

#### 对象内存分配的细节

* 为对象分配堆内存空间时为防止**同一时间创建多个对象的内存分配冲突**（对象A、B分配同一块内存），可采用以下两种操作：

1. 上锁：为分配的内存空间进行同步处理
2. 闭包（本地线程分配缓冲）：为每个线程预先分配一块内存

* 分配完堆内存后，虚拟机将堆内存初始化值为0（对象头除外）
* 对象内存分为3个部分：对象头、实例数据、对其填充

### 访问对象

* 句柄访问：Java栈中reference存储对象的句柄地址，句柄中包含对象的实例、类型数据的地址信息

  <img src="/home/garfield/桌面/screenshot_2020_07_30T15_08_55+0800.jpg" style="zoom: 50%;" />

* 直接指针访问：Java栈中reference直接存储对象地址

<img src="/home/garfield/桌面/screenshot_2020_07_31T16_03_41+0800.jpg" style="zoom:50%;" />

