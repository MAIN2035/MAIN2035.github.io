
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || IO流</title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>IO流 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                Java
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java基础" style=color:#016a99>
                    Java基础
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h2 id="流的分类："><a href="#流的分类：" class="headerlink" title="流的分类："></a>流的分类：</h2><p>操作数据单位：字节流、字符流<br>数据的流向：输入流、输出流<br>流的角色：节点流、处理流</p>
<h2 id="流的体系结构"><a href="#流的体系结构" class="headerlink" title="流的体系结构"></a>流的体系结构</h2><h3 id="整体结构体系"><a href="#整体结构体系" class="headerlink" title="整体结构体系"></a>整体结构体系</h3><img src="http://img.lbkzw.cn/img/20200830171143.png" alt="2020-08-30" style="zoom: 67%;" />


<h3 id="主要流"><a href="#主要流" class="headerlink" title="主要流"></a>主要流</h3><table>
<thead>
<tr>
<th><strong>抽象基类</strong></th>
<th><strong>节点流（或文件流）</strong></th>
<th><strong>缓冲流（处理流的一种）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream</td>
<td>FileInputStream   (read(byte[] buffer))</td>
<td>BufferedInputStream (read(byte[] buffer))</td>
</tr>
<tr>
<td>OutputStream</td>
<td>FileOutputStream  (write(byte[] buffer,0,len)</td>
<td>BufferedOutputStream (write(byte[] buffer,0,len) / flush()</td>
</tr>
<tr>
<td>Reader</td>
<td>FileReader (read(char[] cbuf))</td>
<td>BufferedReader (read(char[] cbuf) / readLine())</td>
</tr>
<tr>
<td>Writer</td>
<td>FileWriter (write(char[] cbuf,0,len)</td>
<td>BufferedWriter (write(char[] cbuf,0,len) / flush()</td>
</tr>
</tbody></table>
<h1 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h1><blockquote>
<p>直接作用于文件</p>
</blockquote>
<h2 id="字符流：FileReader与FileWriter"><a href="#字符流：FileReader与FileWriter" class="headerlink" title="字符流：FileReader与FileWriter"></a>字符流：FileReader与FileWriter</h2><pre><code class="java">  @Test
    public void testFileReaderFileWriter() &amp;#123;
        FileReader fr = null;//为完美关闭流提供条件。
        //由下方代码得出：代码执行到finally时，若未创建流且变量fr为非null值，则将引起异常（为创建流而关闭流）
        FileWriter fw = null;
        try &amp;#123;
            //1.创建File类的对象，指明读入和写出的文件
            File srcFile = new File(&quot;hello.txt&quot;);
            File destFile = new File(&quot;hello2.txt&quot;);

            //不能使用字符流来处理图片等字节数据
//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);
//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);


            //2.创建输入流和输出流的对象
            fr = new FileReader(srcFile);
            fw = new FileWriter(destFile);


            //3.数据的读入和写出操作
            char[] cbuf = new char[5];
            int len;//记录每次读入到cbuf数组中的字符的个数
            while((len = fr.read(cbuf)) != -1)&amp;#123;//从流fr中将 cbuf.length 个字节的数据读入一个 char 数组中
//直到因到达流末尾而返回 -1时停止循环。
                fw.write(cbuf,0,len);

            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //4.关闭流资源
            //方式一：
//            try &amp;#123;
//                if(fw != null)
//                    fw.close();
//            &amp;#125; catch (IOException e) &amp;#123;
//                e.printStackTrace();
//            &amp;#125;finally&amp;#123;
//                try &amp;#123;
//                    if(fr != null)
//                        fr.close();
//                &amp;#125; catch (IOException e) &amp;#123;
//                    e.printStackTrace();
//                &amp;#125;
//            &amp;#125;
            //方式二：
            try &amp;#123;
                if(fw != null)//确定创建了流
                    fw.close();
            &amp;#125; catch (IOException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;

            try &amp;#123;
                if(fr != null)
                    fr.close();
            &amp;#125; catch (IOException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;

        &amp;#125;

    &amp;#125;</code></pre>
<h2 id="字节流：FileInputStream与FileOutputStream"><a href="#字节流：FileInputStream与FileOutputStream" class="headerlink" title="字节流：FileInputStream与FileOutputStream"></a>字节流：FileInputStream与FileOutputStream</h2><p>对于文本文件(.txt,.java,.c,.cpp…)，使用字符流处理;</p>
<p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理。</p>
<pre><code class="java">@Test                                                                    
public void testFileInputStream() &amp;#123;                                      
    FileInputStream fis = null;                                          
    try &amp;#123;                                                                
        //1. 造文件                                                         
        File file = new File(&quot;hello.txt&quot;);                               

        //2.造流                                                           
        fis = new FileInputStream(file);                                 
         /*1、2这样写也可以fis = new FileInputStream(&quot;hello.txt&quot;);会自动包裹*/                                                               
        //3.读数据                                                          
        byte[] buffer = new byte[5];  //这是个byte数组哦
        //由于中文在utf-8编码中占用3个字节（最高占用到6个字节），而每次读入5个字节可能发生乱码
        int len;//记录每次读取的字节的个数                                           
        while((len = fis.read(buffer)) != -1)&amp;#123;                           

            String str = new String(buffer,0,len); //通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。                      
            System.out.print(str);                                       

        &amp;#125;                                                                
    &amp;#125; catch (IOException e) &amp;#123;                                            
        e.printStackTrace();                                             
    &amp;#125; finally &amp;#123;                                                          
        if(fis != null)&amp;#123;                                                 
            //4.关闭资源                                                     
            try &amp;#123;                                                        
                fis.close();                                             
            &amp;#125; catch (IOException e) &amp;#123;                                    
                e.printStackTrace();                                     
            &amp;#125;                                                            

        &amp;#125;                                                                
    &amp;#125;                                                                    

&amp;#125;                                                                        </code></pre>
<h1 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h1><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>作用于流，在流外再包裹一层流。</p>
<p>BufferedInputStream会一次性从文件中读取8192个(8Kb),存在缓冲区中,直到缓冲区装满了,才重新从文件中读取下一个8192个字节数组;</p>
<p>不会直接写到文件,先写到缓冲区中直到缓冲区写满,BufferedOutputStream才会把缓冲区中的数据一次性写到文件里;</p>
<p><code>flush()</code>刷新缓冲区，可以强制将缓冲区的内容全部写入输出流;close()方法关闭带缓冲流的流时，会自动刷新缓冲区后再关闭流。</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><pre><code class="java"> @Test
    public void testBufferedReaderBufferedWriter()&amp;#123;
        BufferedReader br = null;
        BufferedWriter bw = null;
        try &amp;#123;
            //创建文件和相应的流
            br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;)));
            bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;)));

            //读写操作
            //方式一：使用char[]数组
//            char[] cbuf = new char[1024];
//            int len;
//            while((len = br.read(cbuf)) != -1)&amp;#123;
//                bw.write(cbuf,0,len);
//    //            bw.flush();
//            &amp;#125;

            //方式二：使用String
            String data;
            while((data = br.readLine()) != null)&amp;#123;
                //方法一：
//                bw.write(data + &quot;\n&quot;);//data中不包含换行符
                //方法二：
                bw.write(data);//data中不包含换行符
                bw.newLine();//提供换行的操作

            &amp;#125;


        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //关闭资源
            if(bw != null)&amp;#123;

                try &amp;#123;
                    bw.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
            if(br != null)&amp;#123;
                try &amp;#123;
                    br.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;

    &amp;#125;</code></pre>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h3><pre><code class="java">@Test
    public void BufferedStreamTest()&amp;#123;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try &amp;#123;
            //1.造文件
            File srcFile = new File(&quot;爱情与友情.jpg&quot;);
            File destFile = new File(&quot;爱情与友情3.jpg&quot;);
            //2.造流
            //2.1 造节点流
            FileInputStream fis = new FileInputStream((srcFile));
            FileOutputStream fos = new FileOutputStream(destFile);
            //2.2 造缓冲流
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);

            //3.复制的细节：读取、写入
            byte[] buffer = new byte[10];
            int len;
            while((len = bis.read(buffer)) != -1)&amp;#123;
                bos.write(buffer,0,len);

//                bos.flush();//刷新缓冲区，可以强制将缓冲区的内容全部写入输出流

            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //4.资源关闭
            //要求：先关闭外层的流，再关闭内层的流
            if(bos != null)&amp;#123;
                try &amp;#123;
                    bos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if(bis != null)&amp;#123;
                try &amp;#123;
                    bis.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
//        fos.close();
//        fis.close();
        &amp;#125;
    &amp;#125;</code></pre>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>提供字节流与字符流之间的转换</p>
<pre><code class="java">package com.atguigu.java;

import org.junit.Test;

import java.io.*;

/**
 * 处理流之二：转换流的使用
 * 1.转换流：属于字符流
 *   InputStreamReader：将一个字节的输入流转换为字符的输入流
 *   OutputStreamWriter：将一个字符的输出流转换为字节的输出流
 *
 * 2. 解码：字节、字节数组  ---&gt;字符数组、字符串
 *    编码：字符数组、字符串 ---&gt; 字节、字节数组
 *
 *
 * 3.字符集
 *ASCII：美国标准信息交换码。
    用一个字节的7位可以表示。
 ISO8859-1：拉丁码表。欧洲码表
    用一个字节的8位表示。
 GB2312：中国的中文编码表。最多两个字节编码所有字符
 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。
 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。

 *
 *
 * @author shkstart
 * @create 2019 下午 4:25
 */
public class InputStreamReaderTest &amp;#123;

    /*
    此时处理异常的话，仍然应该使用try-catch-finally
    InputStreamReader的使用，实现字节的输入流到字符的输入流的转换
     */
    /*
    此时处理异常的话，仍然应该使用try-catch-finally

    综合使用InputStreamReader和OutputStreamWriter
     */

    @Test
    public void test1()  &amp;#123;
    FileInputStream fis = null;
    //在js中我们知道，catch也具有局部作用域，因此照本方法处理异常需要将引用流的变量在全局作用域声明
        // （方法中的变量不会默认初始化为null，需要手动处理）
    InputStreamReader isr =null;

        try &amp;#123;
            fis = new FileInputStream(&quot;dbcp.txt&quot;);
//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集
            //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集
            isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//使用系统默认的字符集

            char[] cbuf = new char[20];
            int len;
            while((len = isr.read(cbuf)) != -1)&amp;#123;
                String str = new String(cbuf,0,len);
                System.out.print(str);
            &amp;#125;

        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if (isr!=null)&amp;#123;
                try &amp;#123;
                    isr.close();
                &amp;#125;catch (IOException e)&amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;

        &amp;#125;

    &amp;#125;
    @Test
    public void test2()&amp;#123;
        InputStreamReader isr = null;
        OutputStreamWriter osw = null;
        try &amp;#123;
            FileInputStream fis = new FileInputStream(new File(&quot;dbcp.txt&quot;));
            FileOutputStream fos = new FileOutputStream(new File(&quot;dbcp_gbk.txt&quot;));

            isr = new InputStreamReader(fis,&quot;utf-8&quot;);
            osw = new OutputStreamWriter(fos,&quot;gbk&quot;);

            //2.读写过程
            char[] cbuf = new char[20];
            int len;
            while((len = isr.read(cbuf)) != -1)&amp;#123;
                osw.write(cbuf,0,len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;

            //3.关闭资源
            if (isr!=null)&amp;#123;
                try &amp;#123;
                    isr.close();
                &amp;#125;catch (IOException e)&amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if (isr!=null)&amp;#123;
                try &amp;#123;
                    osw.close();
                &amp;#125;catch (IOException e)&amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><blockquote>
<p>将对象序列化为二进制流便于在网络中传输</p>
</blockquote>
<p>序列化:用ObjectOutputStream类保存基本类型数据或对象的机制<br>反序列化:用ObjectInputStream类读取基本类型数据或对象的机制</p>
<p>可序列化的类必须实现以下接口任意一个：</p>
<ul>
<li><p>Serializable</p>
<p>实现Serializable接口的类都有一个表示序列化版本标识符的静态变量:<code>private static final long serialVersionUID;</code><br>serialVersionUID用来进行版本控制;如果类没有显示定义这个静态常量,它的值是Java运行时环境根据类的内部细节自<br>动生成的;若类的实例变量做了修改,serialVersionUID 可能发生变化。</p>
</li>
<li><p>Externalizable</p>
</li>
</ul>
<pre><code class="java">import java.io.Serializable;

/**
 * Person需要满足如下的要求，方可序列化
 * 1.需要实现接口：Serializable
 * 2.当前类提供一个全局常量：serialVersionUID
 * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性
 *   也必须是可序列化的。（默认情况下，基本数据类型可序列化）
 *
 *
 * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
 *
 *
 * @author shkstart
 * @create 2019 上午 10:38
 */
/*一个将用以序列化的类*/
public class Person implements Serializable&amp;#123;//实现接口：Serializable

    public static final long serialVersionUID = 475463534532L;//全局常量：serialVersionUID

    private String name;
    private int age;
    private int id;
    private Account acct;

    public Person(String name, int age, int id) &amp;#123;
        this.name = name;
        this.age = age;
        this.id = id;
    &amp;#125;

    public Person(String name, int age, int id, Account acct) &amp;#123;
        this.name = name;
        this.age = age;
        this.id = id;
        this.acct = acct;
    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;Person&amp;#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, id=&quot; + id +
                &quot;, acct=&quot; + acct +
                &#39;&amp;#125;&#39;;
    &amp;#125;

    public int getId() &amp;#123;
        return id;
    &amp;#125;

    public void setId(int id) &amp;#123;
        this.id = id;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;

    public Person(String name, int age) &amp;#123;

        this.name = name;
        this.age = age;
    &amp;#125;

    public Person() &amp;#123;

    &amp;#125;
&amp;#125;

class Account implements Serializable&amp;#123;
    public static final long serialVersionUID = 4754534532L;
    private double balance;

    @Override
    public String toString() &amp;#123;
        return &quot;Account&amp;#123;&quot; +
                &quot;balance=&quot; + balance +
                &#39;&amp;#125;&#39;;
    &amp;#125;

    public double getBalance() &amp;#123;
        return balance;
    &amp;#125;

    public void setBalance(double balance) &amp;#123;
        this.balance = balance;
    &amp;#125;

    public Account(double balance) &amp;#123;

        this.balance = balance;
    &amp;#125;
&amp;#125;
/*序列化操作开始*/
@Test
    public void testObjectOutputStream()&amp;#123;
        ObjectOutputStream oos = null;

        try &amp;#123;
            //1.
            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));
            //2.
            oos.writeObject(new String(&quot;我爱北京天安门&quot;));
            oos.flush();//刷新操作

            oos.writeObject(new Person(&quot;王铭&quot;,23));
            oos.flush();

            oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000)));
            oos.flush();

        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if(oos != null)&amp;#123;
                //3.
                try &amp;#123;
                    oos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;

    &amp;#125;

    /*
    反序列化：将磁盘文件中的对象还原为内存中的一个java对象
    使用ObjectInputStream来实现
     */
    @Test
    public void testObjectInputStream()&amp;#123;
        ObjectInputStream ois = null;
        try &amp;#123;
            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();//注意之前创建的是Person的对象
            Person p1 = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p);
            System.out.println(p1);

        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (ClassNotFoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if(ois != null)&amp;#123;
                try &amp;#123;
                    ois.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;
    &amp;#125;</code></pre>
<h1 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h1><blockquote>
<p>可读可写、可盐可甜</p>
</blockquote>
<p><code>public RandomAccessFile(File file, String mode)</code><br><code>public RandomAccessFile(String name, String mode)</code><br>创建 RandomAccessFile 类实例需要指定一个 mode 参数,该参数指定 RandomAccessFile 的访问模式:</p>
<ol>
<li>r: 以只读方式打开</li>
<li>rw:打开以便读取和写入</li>
<li>rwd:打开以便读取和写入;同步文件内容的更新</li>
<li>rws:打开以便读取和写入;同步文件内容和元数据的更新</li>
</ol>
<p>如果模式为只读r。则不会创建文件,而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 </p>
<p>如果模式为rw读写，如果文件不存在则会去创建文件。</p>
<pre><code class="java">   @Test
    public void test1() &amp;#123;

        RandomAccessFile raf1 = null;
        RandomAccessFile raf2 = null;
        try &amp;#123;
            //1.
            raf1 = new RandomAccessFile(&quot;爱情与友情.jpg&quot;,&quot;r&quot;);
            raf2 = new RandomAccessFile(new File(&quot;爱情与友情12.jpg&quot;),&quot;rw&quot;);
            //2.
            byte[] buffer = new byte[1024];
            int len;
            while((len = raf1.read(buffer)) != -1)&amp;#123;
                raf2.write(buffer,0,len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //3.
            if(raf1 != null)&amp;#123;
                try &amp;#123;
                    raf1.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if(raf2 != null)&amp;#123;
                try &amp;#123;
                    raf2.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;
    &amp;#125;
/*插入数据*/
    @Test
    public void test2() throws IOException &amp;#123;

        RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);

        raf1.seek(3);//将指针调到角标为3的位置
        raf1.write(&quot;xyz&quot;.getBytes());//使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组
        raf1.close();

    &amp;#125;</code></pre>
<h1 id="字节流实现图片加密解密"><a href="#字节流实现图片加密解密" class="headerlink" title="字节流实现图片加密解密"></a>字节流实现图片加密解密</h1><pre><code class="java">package com.atguigu.exer;

import org.junit.Test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author shkstart
 * @create 2019 下午 4:08
 */
public class PicTest &amp;#123;

    //图片的加密
    @Test
    public void test1() &amp;#123;

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try &amp;#123;
            fis = new FileInputStream(&quot;爱情与友情.jpg&quot;);
            fos = new FileOutputStream(&quot;爱情与友情secret.jpg&quot;);

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) &amp;#123;
                //字节数组进行修改
                //错误的
                //            for(byte b : buffer)&amp;#123;
                //                b = (byte) (b ^ 5);
                //            &amp;#125;
                //正确的
                for (int i = 0; i &lt; len; i++) &amp;#123;
                    buffer[i] = (byte) (buffer[i] ^ 5);
                &amp;#125;


                fos.write(buffer, 0, len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if (fos != null) &amp;#123;
                try &amp;#123;
                    fos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if (fis != null) &amp;#123;
                try &amp;#123;
                    fis.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;


    &amp;#125;


    //图片的解密
    @Test
    public void test2() &amp;#123;

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try &amp;#123;
            fis = new FileInputStream(&quot;爱情与友情secret.jpg&quot;);
            fos = new FileOutputStream(&quot;爱情与友情4.jpg&quot;);

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) &amp;#123;
                //字节数组进行修改
                //错误的
                //            for(byte b : buffer)&amp;#123;
                //                b = (byte) (b ^ 5);
                //            &amp;#125;
                //正确的
                for (int i = 0; i &lt; len; i++) &amp;#123;
                    buffer[i] = (byte) (buffer[i] ^ 5);
                &amp;#125;

                fos.write(buffer, 0, len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if (fos != null) &amp;#123;
                try &amp;#123;
                    fos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if (fis != null) &amp;#123;
                try &amp;#123;
                    fis.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;


    &amp;#125;
&amp;#125;</code></pre>

    </div>

    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>