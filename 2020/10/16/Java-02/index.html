
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || 集合</title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>集合 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                Java
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java基础" style=color:#006674>
                    Java基础
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <blockquote>
<p>在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。</p>
<p>基本的集合： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> </p>
</blockquote>
<ul>
<li>集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li>
<li><strong>Set</strong> （元组）不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
<li><strong>Map</strong> （字典）是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><pre><code class="java">import java.util.*;

class Apple &amp;#123;
  private static long counter;
  private final long id = counter++;
  public long id() &amp;#123; return id; &amp;#125;
&amp;#125;

class Orange &amp;#123;&amp;#125;

public class ApplesAndOrangesWithoutGenerics &amp;#123;
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void main(String[] args) &amp;#123;
    ArrayList apples = new ArrayList();
    for(int i = 0; i &lt; 3; i++)
      apples.add(new Apple());
    /*ArrayList 保存的是 Object ，所以不仅可以通过 ArrayList 的 add() 方法将 Apple 对象放入这个集合，而且可以放入 Orange 对象。*/
    apples.add(new Orange());
    for(Object apple : apples) &amp;#123;
      ((Apple) apple).id();
        /*当使用 ArrayList 的 get() 方法来取出你认为是 Apple 的对象时，得到的只是 Object 引用，必须将其转型为 Apple。然后需要将整个表达式用括号括起来，以便在调用 Apple 的 id() 方法之前，强制执行转型。*/
    &amp;#125;
  &amp;#125;
&amp;#125;
/**通过泛型,限定&lt;Apple&gt;类型防止其它类型对象添加到容器中*/
import java.util.*;

class GrannySmith extends Apple &amp;#123;&amp;#125;
public class ApplesAndOrangesWithGenerics &amp;#123;
  public static void main(String[] args) &amp;#123;
    ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; 3; i++)
      apples.add(new GrannySmith());//向上转型也可以添加到容器哦
      apples.add(new Apple());
    // Compile-time error:
    // apples.add(new Orange());
    for(Apple apple : apples) &amp;#123;
      System.out.println(apple.id());
        //使用泛型，容器知道它被限定为什么类型，因此当调用 get() 时，它会替你执行转型，因此从泛型容器中获取元素不需要强制类型转换。</code></pre>
<h2 id="添加元数组"><a href="#添加元数组" class="headerlink" title="添加元数组"></a>添加元数组</h2><ul>
<li><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。</li>
<li><code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中</li>
</ul>
<pre><code class="java">package com.test.day3;

import java.util.*;

public class AddingGroups &amp;#123;
    public static void main(String[] args) &amp;#123;
        Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));
        Integer[] moreInts = &amp;#123;6,7,8,9,10&amp;#125;;
        collection.addAll(Arrays.asList(moreInts));//Collection.addAll() 方法只能接受另一个 Collection 作为参数
        /*Collection 可以接受另一个 Collection进行初始化，所以使用 Arrays.asList() 可为这个构造器产生输入。
        Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，再调用 Collections.addAll()添加元素 */
        Collections.addAll(collection,11,12,13,14,15);
        Collections.addAll(collection,moreInts);
         /*使用 Arrays.asList() 的输出作为一个 List ，无法调整大小*/
        List&lt;Integer&gt; list = Arrays.&lt;Integer&gt;asList(16,17,18,19,20);
        //告诉编译器 Arrays.asList() 生成的结果 List 类型的实际目标类型是什么。这称为显式类型参数说明

        list.set(1,99);

    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接</li>
<li><strong>Collection</strong> 类型在每个槽中只能保存一个元素。 <strong>Set</strong> 中元素不重复； <strong>Queue</strong> ，只在一端插入对象，并从另一端移除对象； <strong>Map</strong> 在每个槽中存放了两个元素，即<em>键</em>和与之关联的<em>值</em>。</li>
</ul>
<pre><code class="java">import java.util.*;

public class PrintingCollections &amp;#123;
  static Collection
  fill(Collection&lt;String&gt; collection) &amp;#123;
    collection.add(&quot;rat&quot;);
    collection.add(&quot;cat&quot;);
    collection.add(&quot;dog&quot;);
    collection.add(&quot;dog&quot;);
    return collection;
  &amp;#125;
  static Map fill(Map&lt;String, String&gt; map) &amp;#123;
    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);
    map.put(&quot;cat&quot;, &quot;Rags&quot;);
    map.put(&quot;dog&quot;, &quot;Bosco&quot;);
    map.put(&quot;dog&quot;, &quot;Spot&quot;);
    return map;
  &amp;#125;
  public static void main(String[] args) &amp;#123;
    System.out.println(fill(new ArrayList&lt;&gt;()));
      //ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。
    System.out.println(fill(new LinkedList&lt;&gt;()));
      //LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。

    System.out.println(fill(new HashSet&lt;&gt;()));
    System.out.println(fill(new TreeSet&lt;&gt;()));
      //如果存储顺序很重要，则可以使用 TreeSet ，它将按比较结果的升序保存对象
    System.out.println(fill(new LinkedHashSet&lt;&gt;()));
      //LinkedHashSet ，它按照被添加的先后顺序保存对象。

    System.out.println(fill(new HashMap&lt;&gt;()));
      // 键和值保存在 HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非常快速的算法来控制顺序。
    System.out.println(fill(new TreeMap&lt;&gt;()));
      // TreeMap 通过比较结果的升序来保存键
    System.out.println(fill(new LinkedHashMap&lt;&gt;()));
      //LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。
  &amp;#125;
&amp;#125;
/* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[rat, cat, dog]
[cat, dog, rat]
[rat, cat, dog]
&amp;#123;rat=Fuzzy, cat=Rags, dog=Spot&amp;#125;
&amp;#123;cat=Rags, dog=Spot, rat=Fuzzy&amp;#125;
&amp;#123;rat=Fuzzy, cat=Rags, dog=Spot&amp;#125;
*/</code></pre>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>统一集合的移动、删除</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p> <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，设计的很糟糕：如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类。</p>
<p><strong>Java 6 添加了 **ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法:</p>
<pre><code class="java">package com.test.day5;

import java.util.ArrayDeque;
import java.util.Deque;

public class Stack&lt;T&gt; &amp;#123;

    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();
    public void push(T v)&amp;#123;storage.push(v);&amp;#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。
    public T peek() &amp;#123;return storage.peek();&amp;#125;
    public T pop() &amp;#123;return storage.pop();&amp;#125;
    public boolean isEmpty() &amp;#123;return storage.isEmpty();&amp;#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法
    @Override
    public String toString()&amp;#123;
        return storage.toString();
    &amp;#125;

&amp;#125;
</code></pre>
<p>onjava8中利用泛型实现的栈：</p>
<pre><code class="java">package com.test.day5;

import java.util.ArrayDeque;
import java.util.Deque;

public class Stack&lt;T&gt; &amp;#123;

    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();
    public void push(T v)&amp;#123;storage.push(v);&amp;#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。
    public T peek() &amp;#123;return storage.peek();&amp;#125;
    public T pop() &amp;#123;return storage.pop();&amp;#125;
    public boolean isEmpty() &amp;#123;return storage.isEmpty();&amp;#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法
    @Override
    public String toString()&amp;#123;
        return storage.toString();
    &amp;#125;

&amp;#125;
//测试：
public class StackTest2 &amp;#123;
    public static void main(String[] args) &amp;#123;
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();//创建此对象的同时，Stack类也将创建ArrayDeque对象
        for (String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))
            stack.push(s);
        while (!stack.isEmpty())
            System.out.println(stack.pop() + &quot; &quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><ul>
<li><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。  </p>
</li>
<li><p><strong>Set</strong> 最常见的用途是测试归属性。</p>
</li>
</ul>
<p>  **迭代器与集合 **</p>
<pre><code class="java">public class InterfaceVsIterator &amp;#123;
  public static void display(Iterator&lt;Pet&gt; it) &amp;#123;
    while(it.hasNext()) &amp;#123;
      Pet p = it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);//返回越过的值
    &amp;#125;
    System.out.println();
  &amp;#125;
  public static void display(Collection&lt;Pet&gt; pets) &amp;#123;
    for(Pet p : pets)
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    System.out.println();
  &amp;#125;
    /*两个版本的 display() 方法都可以使用 Map 或 Collection 的子类型来工作。 而且Collection 接口和 Iterator 都将 display() 方法与低层集合的特定实现解耦。
     Collection 要更方便一点，因为它是 Iterable 类型，因此在 display(Collection) 的实现中可以使用 for-in 构造，这使得代码更加清晰*/
  public static void main(String[] args) &amp;#123;
    List&lt;Pet&gt; petList = Pets.list(8);
    Set&lt;Pet&gt; petSet = new HashSet&lt;&gt;(petList);
    Map&lt;String, Pet&gt; petMap = new LinkedHashMap&lt;&gt;();
    String[] names = (&quot;Ralph, Eric, Robin, Lacey, &quot; +
      &quot;Britney, Sam, Spot, Fluffy&quot;).split(&quot;, &quot;);
    for(int i = 0; i &lt; names.length; i++)
      petMap.put(names[i], petList.get(i));
    display(petList);
    display(petSet);
    display(petList.iterator());
    display(petSet.iterator());
    System.out.println(petMap);
    System.out.println(petMap.keySet());
    display(petMap.values());
    display(petMap.values().iterator());
  &amp;#125;
&amp;#125;</code></pre>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><code>offer()</code>在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。</li>
<li><code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 </li>
<li><code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</li>
<li>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象</li>
</ul>
<pre><code class="java">package com.test.day4;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

public class QueueDemo &amp;#123;
    public static void printQ(Queue queue)&amp;#123;
        /*删除队列中所有元素*/
        while (queue.peek()!=null)//peek()查询队列第一个元素
            System.out.println(queue.remove()+&quot;&quot;);
        System.out.println();
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        Random rand = new Random(47);//用来生成随机数
        for (int i = 0; i &lt; 10; i++)
            queue.offer(rand.nextInt(i+10));//向队列添加元素
        printQ(queue);
        Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();
        for (char c: &quot;Brontosaurus&quot;.toCharArray())//将字符串分为单个字符加入队列中
            qc.offer(c);
        printQ(qc);

    &amp;#125;</code></pre>
<h3 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h3><ul>
<li>可以通过提供Comparator 来修改队列元素顺序。 </li>
<li><strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素</li>
<li><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</li>
</ul>
<pre><code class="java">import java.util.*;
/*int string 均有默认的大小顺序*/
public class PriorityQueueDemo &amp;#123;
  public static void main(String[] args) &amp;#123;
    PriorityQueue&lt;Integer&gt; priorityQueue =
      new PriorityQueue&lt;&gt;();
    Random rand = new Random();
    for(int i = 0; i &lt; 10; i++)
      priorityQueue.offer(rand.nextInt(i + 10));//将指定的元素插入此优先级队列。
    QueueDemo.printQ(priorityQueue);//删除并打印队列所有元素

    List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20,
      18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);
    priorityQueue = new PriorityQueue&lt;&gt;(ints);
    QueueDemo.printQ(priorityQueue);
    priorityQueue = new PriorityQueue&lt;&gt;(
        ints.size(), Collections.reverseOrder());//反序排列
    priorityQueue.addAll(ints);
    QueueDemo.printQ(priorityQueue);

    String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;
    List&lt;String&gt; strings =
      Arrays.asList(fact.split(&quot;&quot;));//将这个字符串分解为字母（依据空格）填入列表中
    PriorityQueue&lt;String&gt; stringPQ =
      new PriorityQueue&lt;&gt;(strings);
    QueueDemo.printQ(stringPQ);
    stringPQ = new PriorityQueue&lt;&gt;(
      strings.size(), Collections.reverseOrder());//按原stringPQ大小，创建一个新的队列，反并序排列
    stringPQ.addAll(strings);//将strings中的所有元素添加进队列
    QueueDemo.printQ(stringPQ);

    Set&lt;Character&gt; charSet = new HashSet&lt;&gt;();
    for(char c : fact.toCharArray())//toCharArray分割字符。
      charSet.add(c); 
    PriorityQueue&lt;Character&gt; characterPQ =
      new PriorityQueue&lt;&gt;(charSet);//创建队列对象并将集合的元素“安排”到队列中
    QueueDemo.printQ(characterPQ);
  &amp;#125;
&amp;#125;
/* Output:
0 1 1 1 1 1 3 5 8 14
1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25
25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1
      A A B C C C D D E E E F H H I I L N N O O O O S S
S T T U U U W
W U U U T T S S S O O O O N N L I I H H F E E E D D C C
C B A A
  A B C D E F H I L N O S T U W
*/</code></pre>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code class="java">package com.test.day5;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class Statistics &amp;#123;
    public static void main(String[] args) &amp;#123;
        Random rand = new Random(47);
        Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();//创建键值均为int类型的字典对象
        for (int i = 0; i &lt; 1000; i++)&amp;#123;
            int r = rand.nextInt(20);
            Integer freq = m.get(r);//查询有无值r，无则返回null
            m.put(r, freq == null ? 1: freq + 1 );//如字典中有这个值，则为其加一
        &amp;#125;
        System.out.println(m);
    &amp;#125;
&amp;#125;

</code></pre>

    </div>

    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>