
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || 接口</title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>接口 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                Java
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java基础" style=color:#016a99>
                    Java基础
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <blockquote>
<p> 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p>
</blockquote>
<p>接口中可添加静态方法与默认方法；</p>
<p>一个类实现一个接口的同时必须实现该接口的所有方法（可以不用实现默认方法即关键词为为 default的方法）；</p>
<p><strong>extends</strong> 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p>
<h1 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h1><p><img src="http://img.lbkzw.cn/img/20200821084956.jpeg"></p>
<blockquote>
<p>把方法抽象封装到接口或抽象类中，在别的类中对其进行实现即，变得是内容，而其框架则始终如一。</p>
<p>就像我与大厨炒西红柿：大家都是加油、加鸡蛋、加西红柿。只是做出来时味道不同罢了。</p>
</blockquote>
<h1 id="接口与抽象类（选择）"><a href="#接口与抽象类（选择）" class="headerlink" title="接口与抽象类（选择）"></a>接口与抽象类（选择）</h1><table>
<thead>
<tr>
<th>特性</th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>组合</td>
<td>新类可以组合多个接口</td>
<td>只能继承单一抽象类</td>
</tr>
<tr>
<td>状态</td>
<td>不能包含属性（除了静态属性，不支持对象状态）</td>
<td>可以包含属性，非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td>默认方法 和 抽象方法</td>
<td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td>
<td>必须在子类中实现抽象方法</td>
</tr>
<tr>
<td>构造器</td>
<td>没有构造器</td>
<td>可以有构造器</td>
</tr>
<tr>
<td>可见性</td>
<td>隐式 <strong>public</strong></td>
<td>可以是 <strong>protected</strong> 或友元</td>
</tr>
</tbody></table>
<h1 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h1><ul>
<li>创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。</li>
</ul>
<pre><code class="java">import java.util.*;

class Processor &amp;#123;
    /*父类*/
    public String name() &amp;#123;
        return getClass().getSimpleName();
    &amp;#125;

    public Object process(Object input) &amp;#123;
        return input;
    &amp;#125;
&amp;#125;

/*子类开始，将所有传入类设置为同一个类的子类*/
class Upcase extends Processor &amp;#123;
    // 返回协变类型
    @Override 
    public String process(Object input) &amp;#123;
        return ((String) input).toUpperCase();
    &amp;#125;
&amp;#125;

class Downcase extends Processor &amp;#123;
    @Override
    public String process(Object input) &amp;#123;
        return ((String) input).toLowerCase();
    &amp;#125;
&amp;#125;

class Splitter extends Processor &amp;#123;
    @Override
    public String process(Object input) &amp;#123;
        // split() divides a String into pieces:
        return Arrays.toString(((String) input).split(&quot; &quot;));
    &amp;#125;
&amp;#125;

/*策略开始*/
public class Applicator &amp;#123;
    public static void apply(Processor p, Object s) &amp;#123;
        //(Processor p。已知：所有传入类设置为同一个类的子类，故其父类的变量可以作为引用
        System.out.println(&quot;Using Processor &quot; + p.name());//获取其类名
        System.out.println(p.process(s));//根据其类名调用其覆盖的相应的process方法
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        String s = &quot;We are such stuff as dreams are made on&quot;;
        //进入策略，以下3类均为Processor子类，故可用Processor p分别引用以下3个不同类型的对象
        apply(new Upcase(), s);
        apply(new Downcase(), s);
        apply(new Splitter(), s);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="常量字段"><a href="#常量字段" class="headerlink" title="常量字段"></a>常量字段</h1><blockquote>
<p>接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong></p>
</blockquote>
<pre><code class="java">public interface Months &amp;#123;
    int 
    JANUARY = 1, FEBRUARY = 2, MARCH = 3,
    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,
    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
    NOVEMBER = 11, DECEMBER = 12;
&amp;#125;</code></pre>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><blockquote>
<p>所有类都必须是公共可用的，唯独内部类不同。——一枝独秀</p>
</blockquote>
<ul>
<li>内部类的变量必须是最终变量。传入参数默认为fianl</li>
<li>创建内部类对象：在拥有外部类对象之前不可创建内部类对象，且必须使用外部类的对象来创建其内部类对象。</li>
<li>典型手法：外部类中的一个方法返回指向内部类的引用。</li>
<li>可以让内部类实现一个接口，再借接口变量对创建的内部类对象进行引用。</li>
<li>当内部类在方法内部时除该方法外，所有类与方法不得访问。</li>
<li>类只能继承一个父类，实现多个内部类继承类，则等同于实现类的多继承。</li>
</ul>
<h2 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h2><blockquote>
<p>利用内部类实现迭代器功能，对其外类元素（方法、字段）进行访问。</p>
</blockquote>
<pre><code class="java">package com.test.day2;

public class Sequence &amp;#123;
    private Object[] items;
    private int next = 0;
    public Sequence(int size)&amp;#123;
        items = new Object[size];
    &amp;#125;
    public void add(Object x)&amp;#123;
        if(next &lt; items.length)
            items[next++] = x;
    &amp;#125;
    private class SequenceSelector implements Selector&amp;#123;
        private  int i = 0;
        @Override
        public boolean end() &amp;#123;return  i == items.length;&amp;#125;
        @Override
        public Object current() &amp;#123;return  items[i];&amp;#125;
        @Override
        public void  next() &amp;#123;if (i &lt; items.length) i++;&amp;#125;//定义一个迭代器，if语句相当于hasNext
    &amp;#125;
    public Selector selector()&amp;#123;
        /*返回指向内部类的引用。*/
        return new SequenceSelector();
        //当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。
        // 然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        Sequence sequence = new Sequence(10);
        for (int i = 0; i &lt; 10; i++)
            sequence.add(Integer.toString(i));//Integer.toString()表示先讲int转换bai成Integer型，然后再将Integer转换成String型。
        Selector selector = sequence.selector();//返回、创建、引用内部类对象操作开始（此处使用接口变量，对内部类对象进行引用）
        //Selector selector = sequence.new SequenceSelector();//外部类方法返回内部类引用、创建内部类对象
        //var selector = sequence.new SequenceSelector();//简写引用、创建内部类对象
       // Sequence.SequenceSelector selector = sequence.new SequenceSelector();//使用外部类.内部类引用、创建内部类对象
        while (!selector.end())&amp;#123;
            System.out.println(selector.current() + &quot; &quot;);
            selector.next();
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<p>这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p>
<h2 id="this、new"><a href="#this、new" class="headerlink" title="this、new"></a>this、new</h2><pre><code class="java">public class DotThis &amp;#123;
    void f() &amp;#123; System.out.println(&quot;DotThis.f()&quot;); &amp;#125;

    public class Inner &amp;#123;
        public DotThis outer() &amp;#123;
            return DotThis.this;//创建对外部类对象的引用
        &amp;#125;
    &amp;#125;

    public Inner inner() &amp;#123; return new Inner(); &amp;#125;

    public static void main(String[] args) &amp;#123;
        DotThis dt = new DotThis();//在拥有外部类对象之前不可创建内部类对象。
        DotThis.Inner dti = dt.inner();//必须使用外部类的对象来创建其内部类对象
        dti.outer().f();
    &amp;#125;
&amp;#125;


public class DotNew &amp;#123;
    public class Inner &amp;#123;&amp;#125;
    public static void main(String[] args) &amp;#123;
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象
       // var dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul>
<li>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <strong>final</strong> 的</li>
</ul>
<blockquote>
<p>匿名内部类的初始化（借助抽象类）</p>
</blockquote>
<pre><code class="java">package com.test.day2;

abstract class Base &amp;#123;//抽象类的构造器
    Base(int i) &amp;#123;
        System.out.println(&quot;Base constructor, i = &quot; + i);
    &amp;#125;
    public abstract void f();
&amp;#125;
public class AnonymousConstructor &amp;#123;
    public static Base getBase(int i) &amp;#123;
        return new Base(i) &amp;#123;//利用抽象类构造器进行字段初始化。
            &amp;#123; System.out.println(
                    &quot;Inside instance initializer&quot;); &amp;#125;
            @Override
            public void f() &amp;#123;
                System.out.println(&quot;In anonymous f()&quot;);
            &amp;#125;
        &amp;#125;;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        Base base = getBase(47);
        base.f();
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h2><blockquote>
<p>普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p>
</blockquote>
<ul>
<li><p>要创建嵌套类的对象，并不需要先创建其外部类的对象，即直接创建并引用即可。</p>
</li>
<li><p>不能从嵌套类的对象中访问非静态的外围类对象。</p>
</li>
</ul>
<pre><code class="java">public class Parcel11 &amp;#123;
    private static class ParcelContents implements Contents &amp;#123;
        private int i = 11;
        @Override
        public int value() &amp;#123; return i; &amp;#125;
    &amp;#125;
    protected static final class ParcelDestination
            implements Destination &amp;#123;
        private String label;
        private ParcelDestination(String whereTo) &amp;#123;
            label = whereTo;
        &amp;#125;
        @Override
        public String readLabel() &amp;#123; return label; &amp;#125;
        // Nested classes can contain other static elements:
        public static void f() &amp;#123;&amp;#125;
        static int x = 10;
        static class AnotherLevel &amp;#123;
            public static void f() &amp;#123;&amp;#125;
            static int x = 10;
        &amp;#125;
    &amp;#125;
    public static Destination destination(String s) &amp;#123;
        return new ParcelDestination(s);
    &amp;#125;
    public static Contents contents() &amp;#123;
        return new ParcelContents();
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        Contents c = contents();
        //并没有创建外部类的对象，再用外部类对象创建内部类。
        //var i = new Parcel11()
        //var c = i.contents()
        Destination d = destination(&quot;Tasmania&quot;);
    &amp;#125;
&amp;#125;</code></pre>
<pre><code class="java">/**一个接口内部的类（接口内方法、字段默认为final static）*/
public interface ClassInInterface &amp;#123;
    void howdy();
    class Test implements ClassInInterface &amp;#123;
        @Override
        public void howdy() &amp;#123;
            System.out.println(&quot;Howdy!&quot;);
        &amp;#125;
        public static void main(String[] args) &amp;#123;
            new Test().howdy();
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><blockquote>
<p>内部类无法被覆盖，但可通过继承覆盖其方法</p>
</blockquote>
<pre><code class="java">class WithInner &amp;#123;
    class Inner &amp;#123;
        public Yolk() &amp;#123;
            System.out.println(&quot;Egg.Yolk()&quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
public class InheritInner extends WithInner.Inner &amp;#123;//继承须以（外部类.内部）类形式。
    InheritInner(WithInner wi) &amp;#123;
        wi.super();
        @Override
        public Yolk() &amp;#123;
            System.out.println(&quot;BigEgg2.Yolk()&quot;);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code class="java">package cn.day.a5;

// files/PathInfo.java
import java.nio.file.*;
import java.net.URI;
import java.io.File;
import java.io.IOException;

public class PathInfo &amp;#123;
    static void show(String id, Object p) &amp;#123;
        System.out.println(id + &quot;: &quot; + p);
    &amp;#125;

    static void info(Path p) &amp;#123;
        show(&quot;toString&quot;, p);
        show(&quot;Exists&quot;, Files.exists(p));//测试文件是否存在
        show(&quot;RegularFile&quot;, Files.isRegularFile(p));
        show(&quot;Directory&quot;, Files.isDirectory(p));//测试文件是否是一个目录。
        show(&quot;Absolute&quot;, p.isAbsolute());//判断此路径是否为绝对路径
        show(&quot;FileName&quot;, p.getFileName());//返回文件名
        show(&quot;Parent&quot;, p.getParent());//返回此文件的父路径，无返回null
        show(&quot;Root&quot;, p.getRoot());//返回此文件的根路径，无返回null
        System.out.println(&quot;******************&quot;);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        System.out.println(System.getProperty(&quot;os.name&quot;));
        info(Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;));//转化路径（此方法将来可能被弃用）
        Path p = Paths.get(&quot;PathInfo.java&quot;);
        info(p);
        Path ap = p.toAbsolutePath();//获取这个文件的绝对路径
        info(ap);
        info(ap.getParent());
        try &amp;#123;/*传入p引用 文件的父路径，调用info进行处理*/
            info(p.toRealPath());
        &amp;#125; catch(IOException e) &amp;#123;
            System.out.println(e);
        &amp;#125;
        URI u = p.toUri();//返回一个URI来表示该路径
        System.out.println(&quot;URI: &quot; + u);
        Path puri = Paths.get(u);//给定的URI转换为Path对象。
        System.out.println(Files.exists(puri));
        File f = ap.toFile();
    &amp;#125;
&amp;#125;
</code></pre>

    </div>

    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>