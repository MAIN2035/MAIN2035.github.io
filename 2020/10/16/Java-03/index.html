
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || 函数式编程</title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>函数式编程 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                Java
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java基础" style=color:#607d8b>
                    Java基础
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <blockquote>
<p>任何 Lambda 表达式的基本语法是：</p>
<ol>
<li>参数。</li>
<li>接着 <code>-&gt;</code>，可视为“产出”。</li>
<li><code>-&gt;</code> 之后的内容都是方法体。</li>
</ol>
</blockquote>
<p>当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例;</p>
<p> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见;</p>
<p>如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表;</p>
<p>对于多个参数，将参数列表放在括号 <code>()</code> 中;</p>
<p>表达式的结果自动成为<strong>Lambda 表达式</strong>的返回值，在此处使用 <strong>return</strong> 关键字是非法的。</p>
<p><strong>递归</strong>方法必须是实例变量或静态变量，否则会出现编译时错误</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用组成：类名或对象名 <code>::</code> 方法名</p>
<pre><code class="java">package com.test.day6;

// functional/MethodReferences.java

import java.util.*;

interface Callable &amp;#123; // [1]
    void call(String s);
&amp;#125;

class Describe &amp;#123;
    void show(String msg) &amp;#123; // [2]
        System.out.println(msg);
    &amp;#125;
&amp;#125;

public class MethodReferences &amp;#123;
    static void hello(String name) &amp;#123; // [3]
        System.out.println(&quot;Hello, &quot; + name);
    &amp;#125;
    static class Description &amp;#123;
        String about;
        Description(String desc) &amp;#123; about = desc; &amp;#125;
        void help(String msg) &amp;#123; // [4]
            System.out.println(about + &quot; &quot; + msg);
        &amp;#125;
    &amp;#125;
    static class Helper &amp;#123;
        static void assist(String msg) &amp;#123; // [5]
            System.out.println(msg);
        &amp;#125;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        Describe d = new Describe();
        Callable c = d::show;
        //将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。
        c.call(&quot;call()&quot;); //现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show(),因为其签名均是String。

        c = MethodReferences::hello; //这是一个静态方法引用。
        c.call(&quot;Bob&quot;);

        c = new Description(&quot;valuable&quot;)::help; // 对已实例化对象的方法的引用，称为绑定方法引用。
        c.call(&quot;information&quot;);

        c = Helper::assist; // 内部类方法引用
        c.call(&quot;Help!&quot;);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p><strong>Runnable</strong> 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 <code>run()</code> 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong>：</p>
<pre><code class="java">// 方法引用与 Runnable 接口的结合使用

class Go &amp;#123;
  static void go() &amp;#123;
    System.out.println(&quot;Go::go()&quot;);
  &amp;#125;
&amp;#125;

public class RunnableMethodReference &amp;#123;
  public static void main(String[] args) &amp;#123;

    new Thread(new Runnable() &amp;#123;//内部类方法
      public void run() &amp;#123;
        System.out.println(&quot;Anonymous&quot;);
      &amp;#125;
    &amp;#125;).start();

    new Thread(
      () -&gt; System.out.println(&quot;lambda&quot;)//lambda表达式
    ).start();

    new Thread(Go::go).start();//方法引用
  &amp;#125;
&amp;#125;</code></pre>
<h2 id="未绑定的方法引用"><a href="#未绑定的方法引用" class="headerlink" title="未绑定的方法引用"></a>未绑定的方法引用</h2><blockquote>
<p>在目标类没有对象的时候对其采用方法引用，即为未绑定方法引用（静态类除外）</p>
<p>可使用目标类类型的方法参数解决未绑定方法引用问题</p>
</blockquote>
<pre><code class="java">package com.test.day6;

// functional/UnboundMethodReference.java

// 没有方法引用的对象

class X &amp;#123;
    String f() &amp;#123; return &quot;X::f()&quot;; &amp;#125;
&amp;#125;

interface MakeString &amp;#123;
    String make();
&amp;#125;

interface TransformX &amp;#123;
    String transform(X x);
&amp;#125;

public class UnboundMethodReference &amp;#123;
    public static void main(String[] args) &amp;#123;
        // MakeString ms = X::f; // 不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。
        TransformX sp = X::f;//TransformX下的String transform(X x)方法接受一个X类的参数，所以可与完成对象绑定并成功调用方法。
        X x = new X();
        System.out.println(sp.transform(x)); // [2]
        System.out.println(x.f()); // 同等效果
    &amp;#125;
&amp;#125;




package com.test.day6;

// functional/MultiUnbound.java

// 未绑定的方法与多参数的结合运用

class This &amp;#123;
    void two(int i, double d) &amp;#123;&amp;#125;
    void three(int i, double d, String s) &amp;#123;&amp;#125;
    void four(int i, double d, String s, char c) &amp;#123;&amp;#125;
&amp;#125;
/*接口方法中加入对象类型参数 达到绑定对象目的*/
interface TwoArgs &amp;#123;
    void call2(This athis, int i, double d);//参数This athis达到绑定对象目的
&amp;#125;

interface ThreeArgs &amp;#123;
    void call3(This athis, int i, double d, String s);
&amp;#125;

interface FourArgs &amp;#123;
    void call4(
            This athis, int i, double d, String s, char c);
&amp;#125;

public class MultiUnbound &amp;#123;
    public static void main(String[] args) &amp;#123;
        TwoArgs twoargs = This::two;
        ThreeArgs threeargs = This::three;
        FourArgs fourargs = This::four;
        This athis = new This();
        twoargs.call2(athis, 11, 3.14);//相当于woargs.call2(this.athis, 11, 3.14),成功绑定对象并传入参数调用方法
        threeargs.call3(athis, 11, 3.14, &quot;Three&quot;);
        fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, &#39;Z&#39;);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><pre><code class="java">package com.test.day6;

// functional/CtorReference.java

class Dog &amp;#123;
    String name;
    int age = -1; // For &quot;unknown&quot;
    Dog() &amp;#123; name = &quot;stray&quot;; &amp;#125;
    Dog(String nm) &amp;#123; name = nm; &amp;#125;
    Dog(String nm, int yrs) &amp;#123; name = nm; age = yrs; &amp;#125;
&amp;#125;

interface MakeNoArgs &amp;#123;
    Dog make();
&amp;#125;

interface Make1Arg &amp;#123;
    Dog make(String nm);
&amp;#125;

interface Make2Args &amp;#123;
    Dog make(String nm, int age);
&amp;#125;

public class CtorReference &amp;#123;
    public static void main(String[] args) &amp;#123;
        /*[1][2][3]分别引用不同签名的构造器*/
        MakeNoArgs mna = Dog::new; // [1]根据MakeNoArgs接口中方法的签名引用相符的构造器
        Make1Arg m1a = Dog::new;   // [2]根据Make1Arg接口中方法的签名引用相符的构造器
        Make2Args m2a = Dog::new;  // [3]根据MakeNoArgsMake2Args接口中方法的签名引用相符的构造器

        Dog dn = mna.make();//相当于调用引用Dog类的构造器
        Dog d1 = m1a.make(&quot;Comet&quot;);
        Dog d2 = m2a.make(&quot;Ralph&quot;, 4);
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><blockquote>
<p>只包含一个抽象方法的接口（接口中方法默认为抽象的）</p>
<p>如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会自动包装方法引用或 Lambda 表达式到实现目标接口的类的实例中。</p>
</blockquote>
<pre><code class="java">// functional/FunctionalAnnotation.java

@FunctionalInterface
//@FunctionalInterface 的作用：接口中如果有多个方法则会产生编译期错误
interface Functional &amp;#123;
  String goodbye(String arg);
&amp;#125;

interface FunctionalNoAnn &amp;#123;
  String goodbye(String arg);
&amp;#125;


public class FunctionalAnnotation &amp;#123;
  public String goodbye(String arg) &amp;#123;
    return &quot;Goodbye, &quot; + arg;
  &amp;#125;
  public static void main(String[] args) &amp;#123;
    FunctionalAnnotation fa =
      new FunctionalAnnotation();
    Functional f = fa::goodbye;
    FunctionalNoAnn fna = fa::goodbye;
    // Functional fac = fa; // Incompatible
    Functional fl = a -&gt; &quot;Goodbye, &quot; + a;
    FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a;
  &amp;#125;
&amp;#125;</code></pre>
<p><code>java.util.function</code> 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。</p>
<p> 以下是基本命名准则：</p>
<ol>
<li>如果只处理对象而非基本类型，名称则为 <code>Function</code>，<code>Consumer</code>，<code>Predicate</code> 等。参数类型通过泛型添加。</li>
<li>如果接收的参数是基本类型，则由名称的第一部分表示，如 <code>LongConsumer</code>，<code>DoubleFunction</code>，<code>IntPredicate</code> 等，但基本 <code>Supplier</code> 类型例外。</li>
<li>如果返回值为基本类型，则用 <code>To</code> 表示，如 <code>ToLongFunction &lt;T&gt;</code> 和 <code>IntToLongFunction</code>。</li>
<li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 <code>UnaryOperator</code>，两个参数使用 <code>BinaryOperator</code>。</li>
<li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li>
<li>如果接收的两个参数类型不同，则名称中有一个 <code>Bi</code>。</li>
</ol>
<p>下表描述了 <code>java.util.function</code> 中的目标类型（包括例外情况）：</p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>函数式方法名</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>无参数；   无返回值</td>
<td><strong>Runnable</strong>   (java.lang)     <code>run()</code></td>
<td><strong>Runnable</strong></td>
</tr>
<tr>
<td>无参数；   返回类型任意</td>
<td><strong>Supplier</strong>   <code>get()</code>   <code>getAs类型()</code></td>
<td><strong>Supplier<code>&lt;T&gt;</code>    BooleanSupplier    IntSupplier    LongSupplier    DoubleSupplier</strong></td>
</tr>
<tr>
<td>无参数；   返回类型任意</td>
<td><strong>Callable</strong>   (java.util.concurrent)    <code>call()</code></td>
<td><strong>Callable<code>&lt;V&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数；   无返回值</td>
<td><strong>Consumer</strong>   <code>accept()</code></td>
<td><strong><code>Consumer&lt;T&gt;</code>   IntConsumer   LongConsumer   DoubleConsumer</strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong></td>
<td><strong>BiConsumer</strong>   <code>accept()</code></td>
<td><strong><code>BiConsumer&lt;T,U&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong>；   1 引用；   1 基本类型</td>
<td><strong>Obj类型Consumer</strong>   <code>accept()</code></td>
<td><strong><code>ObjIntConsumer&lt;T&gt;</code>   <code>ObjLongConsumer&lt;T&gt;</code>   <code>ObjDoubleConsumer&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数；   返回类型不同</td>
<td><strong>Function</strong>   <code>apply()</code>   <strong>To类型</strong> 和 <strong>类型To类型</strong>   <code>applyAs类型()</code></td>
<td><strong>Function<code>&lt;T,R&gt;</code>   IntFunction<code>&lt;R&gt;</code>   <code>LongFunction&lt;R&gt;</code>   DoubleFunction<code>&lt;R&gt;</code>   ToIntFunction<code>&lt;T&gt;</code>   <code>ToLongFunction&lt;T&gt;</code>   <code>ToDoubleFunction&lt;T&gt;</code>   IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>1 参数；   返回类型相同</td>
<td><strong>UnaryOperator</strong>   <code>apply()</code></td>
<td><strong><code>UnaryOperator&lt;T&gt;</code>   IntUnaryOperator   LongUnaryOperator   DoubleUnaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同；   返回类型相同</td>
<td><strong>BinaryOperator</strong>   <code>apply()</code></td>
<td><strong><code>BinaryOperator&lt;T&gt;</code>   IntBinaryOperator   LongBinaryOperator   DoubleBinaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同;   返回整型</td>
<td>Comparator   (java.util)   <code>compare()</code></td>
<td><strong><code>Comparator&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数；   返回布尔型</td>
<td><strong>Predicate</strong>   <code>test()</code></td>
<td><strong><code>Predicate&lt;T&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   IntPredicate   LongPredicate   DoublePredicate</strong></td>
</tr>
<tr>
<td>参数基本类型；   返回基本类型</td>
<td><strong>类型To类型Function</strong>   <code>applyAs类型()</code></td>
<td><strong>IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>2 参数类型不同</td>
<td><strong>Bi操作</strong>   (不同方法名)</td>
<td><strong><code>BiFunction&lt;T,U,R&gt;</code>   <code>BiConsumer&lt;T,U&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   <code>ToIntBiFunction&lt;T,U&gt;</code>   <code>ToLongBiFunction&lt;T,U&gt;</code>   <code>ToDoubleBiFunction&lt;T&gt;</code></strong></td>
</tr>
</tbody></table>
<p>此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。</p>

    </div>

    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>