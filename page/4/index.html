
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2020/10/16/jvm-01/">
        <h2>
            运行时数据区域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><img src="https://i.loli.net/2020/07/30/eLwO5syKpnhjivJ.png" style="zoom:25%;" />



<ul>
<li><p>程序计数器：每个线程都有一个程序计数器，它指示当前线程所执行字节码的行号</p>
</li>
<li><p>Java虚拟机栈：每个方法执行时均会创建一个栈帧，其存储<strong>局部变量表</strong>（基本类型与对象引用）、操作数栈、动态连接、方法出口等信息</p>
</li>
<li><p>本地方法栈：与Java虚拟机栈类似，其<strong>为本地方法服务</strong></p>
</li>
<li><p>Java堆（GC堆）：在虚拟机运行时创建用以存放对象实例，且为所有线程共享。</p>
</li>
<li><p>方法区：存储已被虚拟机加载的类型信息、常量、静态变量、编译后的代码缓存等数据，且为所有线程共享。</p>
<ol>
<li>运行时常量池：属于方法区，在加载类后class文件中的常量池表（字面量、符号引用）将存入运行时常量池</li>
</ol>
</li>
</ul>
<ul>
<li>直接内存（不属于运行时数据区域）：基于通道与缓冲区的I/O方式，其使用Native函数库直接分配堆外内存，并通过存储在Java堆中的<em>DirectByteBuffer</em>对象作为这块内存的引用进行操作</li>
</ul>
<h1 id="为对象分配内存："><a href="#为对象分配内存：" class="headerlink" title="为对象分配内存："></a>为对象分配内存：</h1><ul>
<li><p>创建对象时，虚拟机首先检测这个类是否已被<strong>加载、解析、初始化</strong>，如没有则首先执行<strong>类的加载过程</strong>。</p>
</li>
<li><p>垃圾收集器的<strong>空间整理能力</strong>决定<strong>堆是否规整</strong></p>
</li>
</ul>
<h2 id="分配堆内存的两种方式："><a href="#分配堆内存的两种方式：" class="headerlink" title="分配堆内存的两种方式："></a>分配堆内存的两种方式：</h2><h3 id="指针碰撞："><a href="#指针碰撞：" class="headerlink" title="指针碰撞："></a>指针碰撞：</h3><ul>
<li><strong>Java堆内存是规整的</strong>，有一个指针其两边分别是已使用、未使用的堆内存，分配内存时把指针向未使用的一边挪动一段与对象大小相同的距离</li>
</ul>
<p><img src="https://i.loli.net/2020/07/30/tV7RKAgXQWTykm5.png"></p>
<h3 id="空闲列表："><a href="#空闲列表：" class="headerlink" title="空闲列表："></a>空闲列表：</h3><ul>
<li><strong>Java堆内存不是规整的</strong>，使用与未使用的堆内存纵横交错，需要使用一个列表记录未使用的堆内存，分配内存时从列表中找到一块足够大的堆内存分配给对象</li>
</ul>
<p><img src="https://i.loli.net/2020/07/30/KoeInBvdQrjkEYS.png"></p>
<h2 id="对象内存分配的细节"><a href="#对象内存分配的细节" class="headerlink" title="对象内存分配的细节"></a>对象内存分配的细节</h2><ul>
<li>为对象分配堆内存空间时为防止<strong>同一时间创建多个对象的内存分配冲突</strong>（对象A、B分配同一块内存），可采用以下两种操作：</li>
</ul>
<ol>
<li>上锁：为分配的内存空间进行同步处理</li>
<li>闭包（本地线程分配缓冲）：为每个线程预先分配一块内存</li>
</ol>
<ul>
<li>分配完堆内存后，虚拟机将堆内存初始化值为0（对象头除外）</li>
<li>对象内存分为3个部分：对象头、实例数据、对其填充</li>
</ul>
<h1 id="对象、方法区"><a href="#对象、方法区" class="headerlink" title="对象、方法区"></a>对象、方法区</h1><h2 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h2><ul>
<li>句柄访问：Java栈中reference存储对象的句柄地址，句柄中包含对象的实例、类型数据的地址信息</li>
<li><img src="https://i.loli.net/2020/08/19/XxgJA5zpeWqZFt6.jpg" alt="screenshot_2020_07_30T15_08_55+0800" style="zoom:50%;" /></li>
<li>直接指针访问：Java栈中reference直接存储对象地址<img src="https://i.loli.net/2020/08/19/YsgivyGItW4ALkH.jpg" alt="screenshot_2020_07_31T16_03_41+0800" style="zoom:50%;" /></li>
</ul>
<h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><ul>
<li><p>引用计数算法：每个对象都有一个引用计数器，每当被一个地方引用时计数器值便加一，每当失去一个引用计数器值便减一（不采用）</p>
</li>
<li><p>可达性分析算法：通过<strong>GCRoots</strong>根对象作为起点，根据引用关系向下搜索，构成一条<strong>引用链</strong>如果某个对象到<strong>GCRoots</strong>间没有任何引用链，那么这个对象就是可回收的。</p>
<img src="https://i.loli.net/2020/08/19/Jre7x8wUvLEchsP.jpg" alt="screenshot_2020_07_30T20_21_36+0800" style="zoom:50%;" />

</li>
</ul>
<h2 id="回收对象："><a href="#回收对象：" class="headerlink" title="回收对象："></a>回收对象：</h2><ul>
<li>可达性分析算法中可回收的对象并<strong>不会被立即回收</strong>，而是对其进行第二次筛选；</li>
<li>如此对象有覆盖finalize（）方法且此方法且未被虚拟机调用，则执行finalize（）方法，并将其放入F—Queue队列中（<strong>低优先级的Finalizer线程</strong>将执行finalize（）方法），在此期间如<strong>对象与引用链建立联系则不会被回收</strong>（如赋值、引用等）</li>
</ul>
<h2 id="回收方法区："><a href="#回收方法区：" class="headerlink" title="回收方法区："></a>回收方法区：</h2><ul>
<li>方法区的垃圾回收分为两部分，<strong>废弃的常量</strong>与<strong>不再使用的类型</strong>：</li>
</ul>
<ol>
<li>废弃的常量：一个常量<strong>不被引用</strong>，则这个常量将被从常量池中清除（接口、方法、字段符号与之类似）</li>
<li>不再使用的类型：需要满足以下3个条件方<strong>可被回收</strong>（而不是立即回收）<ul>
<li>该类不存在<strong>任何实例</strong>（实例均被回收）</li>
<li>加载该类的<strong>加载器</strong>已被回收</li>
<li>该类对应的<strong>class对象没有被引用</strong>，且<strong>无法通过反射</strong>访问该类的方法</li>
</ul>
</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Jvm虚拟机" style=color:#6484be>
                Jvm虚拟机
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/jvm-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/js-05/">
        <h2>
            JS数组
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>Js数组是无类型的，其元素可以为任意类型，也可以是任意对象或数组；</p>
<p>Js数组是动态的，无需声明其大小，数组长度会根据需要增长与缩减；</p>
<p>省略的数组直接量将被赋予undefined值；</p>
<p>数组是对象的特殊形式，所以其可以从原型中继承元素，可以定义元素的getter与setter方法；数组的索引是对象属性名的特殊类型。</p>
<pre><code class="js">var b = [1,,3]//索引1处值即为undefined
var c = [,];//空数组，因为数组直接量结尾处的“,”可选加与不加，数组中只有1个“,”时默认为是结尾处的“,”
var d = [];//空数组
var d = new Array(10);//利用Array()构造函数创建一个预分配大小的数组。
</code></pre>
<pre><code class="js">/*负值与非整数的数组索引，将被转换为字符串，字符串作为属性名使用*/
var a = [3.1415926] = pi;
var b = [-180] = deg;</code></pre>
<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><pre><code class="js">a = new Array(5);//a为空数组，但其长度为5
b = [];
b[1000] = 122;//添加一个元素，数组长度为1001
/*length属性小于当前长度时，超出length值-1的元素将被删除。*/
b.length = 999;//此时数组为空。
/*让数组变为只读*/
c = [1,2,3];
Object.defineProperty(a,&quot;length&quot;,&amp;#123;writable:false&amp;#125;)//将length属性设置为不可写</code></pre>
<h1 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h1><p>栈、队列、双端队列的实现。</p>
<h2 id="push-unshift"><a href="#push-unshift" class="headerlink" title="push(),unshift()"></a>push(),unshift()</h2><blockquote>
<p>**push()**在尾部添加元素;</p>
<p>**unshift()**在头部添加元素.</p>
</blockquote>
<pre><code class="js">a = [];
a.push(&quot;pu&quot;);//与直接量添加a[a.length]=&quot;pu&quot;;效果相同
a.unshift(&quot;d&quot;,&quot;j&quot;);//unshif插入元素是一次性插入的，所以不会影响顺序
/*delete可删除数组元素（数组是特殊对象），但不改变其长度*/
delete a[0];</code></pre>
<h2 id="pop-shift"><a href="#pop-shift" class="headerlink" title="pop(),shift()"></a>pop(),shift()</h2><ul>
<li><p>栈的实现（配合push()）：pop() 减少数组1长度（即删除末尾元素），并返回被删除的元素值</p>
</li>
<li><p>队列的实现（配合unshift()）：shift()从头部删除一个元素，并将被删除元素以后的元素索引减一（队列，所有人向前走一步）</p>
</li>
</ul>
<p><strong><em>双端队列：push(),unshift() pop(),shift()实现。</em></strong></p>
<h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><ul>
<li>一般，调用的函数作为forEach第一个参数，调用函数一般提供3个参数：数组元素、元素索引、数组本身</li>
<li>forEach只能利用”异常“机制终止遍历</li>
</ul>
<pre><code class="js">var data = [1,2,3,4,5,];
var sum = 0;
data.forEach(function(value)&amp;#123;sum+=value;&amp;#125;);//求和
data.forEach(function(v,i,a)&amp;#123;a[i]=v+1;&amp;#125;);//每个元素+1
/*终止遍历*/
function foreach(a,f,t)&amp;#123;
    try&amp;#123;a.forEach(f,t);&amp;#125;
    catch(e)&amp;#123;if(e===foreach.break)return;else throw e;&amp;#125;
&amp;#125;
foreach.break = new Error(&quot;Stoplteration&quot;);</code></pre>
<h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul>
<li>将数组组成字符串返回</li>
</ul>
<pre><code class="js">/*join */
var a = [1,2,3,4]
a.join();//默认以“,”分隔
a.join(&#39;_&#39;);//自定义元素分隔(_)
/*split */
var b = &quot;hello World&quot;
var c =b.split(正则表达式或字符串);//将字符串分割为若干块并创建一个数组</code></pre>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><ul>
<li>逆序数组元素（直接在原数组中排序），并返回排序后的数组</li>
</ul>
<pre><code class="js">var a = [1,2,3,4]
a.reverse()</code></pre>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><ul>
<li>默认以字母顺序进行排序，且返回排序后的数组</li>
<li>undefined 元素会被排列到尾部</li>
<li>自定义排序：sort接受一个比较函数，该函数有两个比较参数，返回小于0的值则第一个参数在前，反之第二个参数在前。</li>
</ul>
<pre><code class="js">/*排列数值*/
var a = [12,574,88,78];
a.sort();
a.sort(function(a,b)&amp;#123;return a-b;&amp;#125;)
/*排列字符串且不区分大小写*/
a = [&#39;ant&#39;,&#39;Bug&#39;,&#39;cos&#39;]
a.sort(function(s,t)&amp;#123;var a = s.toLowerCase();var b = t.toLowerCase();
if(a&lt;b)return -1;//写小于0的任意值
if(a&gt;b)return 1;//写大于0的任意值
return 0;//相等返回0
&amp;#125;);</code></pre>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><ul>
<li>创建并返回新的数组</li>
<li>如果其参数中包含某个数组则添加其元素，创建并返回新的数组</li>
</ul>
<pre><code class="js">var a = new Array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);
var b = new Array(&#39;1f&#39;,&#39;2f&#39;,&#39;3f&#39;);
a.concat(4,5,6,b);//a = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 4, 5, 6, &quot;1f&quot;, &quot;2f&quot;, &quot;3f&quot;];</code></pre>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><ul>
<li>返回数组参数指定位置的片段或子数组</li>
</ul>
<pre><code class="js">var a = new Array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);
a.slice(0,2)//返回[&quot;1&quot;, &quot;2&quot;]，返回第一个参数位置（包含第一个位置）到第2个参数位置前的子数组。</code></pre>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><ul>
<li>插入或删除数组元素，并返回一个包含已删除元素的数组。</li>
<li>第一个参数指定了插入或删除的位置，第二个参数指定了删除元素的数量（若是添加则此参数填0）</li>
</ul>
<pre><code class="js"> var a =[1,32,95,98,6,,78];
 a.splice(2, 0,&#39;f1&#39;);//删除0个在索引2前插入&#39;f1&#39;
 a.splice(4,1,[1,5,,6],&#39;j&#39;);//在索引4出删除1个元素并插入一个数组[1,5,,6]与一个元素&#39;j&#39;</code></pre>
<h2 id="toString与toLocaleString"><a href="#toString与toLocaleString" class="headerlink" title="toString与toLocaleString"></a>toString与toLocaleString</h2><ul>
<li>toString将每个元素转换为字符串，并输出用逗号分隔的字符串列表。</li>
<li>toLocaleString使用“本地化“版本的toString，将元素转换为字符串并分隔（自定义）</li>
</ul>
<h1 id="Es-5数组方法"><a href="#Es-5数组方法" class="headerlink" title="Es 5数组方法"></a>Es 5数组方法</h1><p>大多数方法第一个参数接收一个函数，并对数组中每个元素调用一次该函数；</p>
<p>对于稀疏数组中不存在的元素（undefined），不调用传递函数；</p>
<p>调用函数一般提供3个参数：数组元素、元素索引、数组本身。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>将数组的所有元素传递给指定函数，并返回一个包含该函数返回值的数组</li>
</ul>
<pre><code class="js">var a = [1,5];
var b = a.map( function(x)&amp;#123; return x*x;&amp;#125;);//返回的是新数组哦</code></pre>
<h2 id="fileter"><a href="#fileter" class="headerlink" title="fileter"></a>fileter</h2><ul>
<li>返回数组元素的子集</li>
<li>只返回稠密数组（自动跳过稀疏数组中为空的元素）</li>
</ul>
<pre><code class="js">/*返回子集 */
var a= [1,5,98,8];
var b = a.filter(function(x)&amp;#123;return x&gt;5;&amp;#125;);//过滤
var c = a.filter(function(x,y)&amp;#123;return y%2==0;&amp;#125;);

/*压缩空缺*/
var a = a.filter(function(x)&amp;#123;return x!==undefined &amp;&amp; x!=null;&amp;#125;);</code></pre>
<h2 id="every与some"><a href="#every与some" class="headerlink" title="every与some"></a>every与some</h2><ul>
<li><p>对数组元素按照指定的函数进行判定，返回布尔值</p>
</li>
<li><h4 id="every针对所有元素，some仅当一些元素"><a href="#every针对所有元素，some仅当一些元素" class="headerlink" title="every针对所有元素，some仅当一些元素"></a>every针对所有元素，some仅当一些元素</h4></li>
<li><p>一旦every与some确定结果，遍历便停止了</p>
<pre><code class="js">var a =[1,5,8,,9];
a.every(function(x)&amp;#123;return x &lt; 5 ;&amp;#125;);//数组中全部元素大于5？否，返回false
a.some(function(x)&amp;#123;return x &lt;5;&amp;#125;);//数组中有元素大于5？yes，返回false</code></pre>
</li>
</ul>
<h2 id="reduce与reduceRight"><a href="#reduce与reduceRight" class="headerlink" title="reduce与reduceRight"></a>reduce与reduceRight</h2><ul>
<li>reduce 使用指定函数使数组元素相互结合，其有两个参数第一个是“到目前为止操作的结果”，第二个是初始值。（可不写初始值，默认数组第一个元素为初始值）</li>
</ul>
<pre><code class="js">var a = [1,2,5]
var sum = a.reduce(function(x,y)&amp;#123;return x+y&amp;#125;，2)//sum =8
var sum = a.reduce(function(x,y)&amp;#123;return x+y&amp;#125;)//sum =10</code></pre>
<ul>
<li>reduceRight和reduce操作相同，但其从右到左处理数组</li>
</ul>
<h2 id="indexOf-与-lastIndexOf"><a href="#indexOf-与-lastIndexOf" class="headerlink" title="indexOf 与 lastIndexOf"></a>indexOf 与 lastIndexOf</h2><ul>
<li>依照给定的值在数组中搜索元素，返回找到的第一个元素，不存在则返回-1</li>
<li>indexOf从头开始搜索 lastIndexOf从尾开始搜索</li>
<li>第一个参数是要搜索的值，第二个参数（可省略）指定从哪个索引开始搜索</li>
</ul>
<pre><code class="js">function findall(a,x)&amp;#123;//传入数组与将要查找的值
    var results = [],len = a.length,pos = 0;//
    while(pos&lt;len)&amp;#123;pos = indexOf(x,pos);//从索引o开始搜索
    if(pos===-1)break;results.push(pos);pos +=1;//找不到结束；否则在数组results中存储索引，继续搜索
&amp;#125;
return results;
&amp;#125;</code></pre>
<h1 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h1><ul>
<li>类数组对象没有继承自Array.prototype,但其仍可使用Function.call方法调用数组方法</li>
</ul>
<pre><code class="js">var a = &amp;#123;&quot;0&quot;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3&amp;#125;
Array.prototype.join.call(a,&quot;+&quot;)//调用join方法
Array.prototype.slice.call(a,0)//调用slice方法
Array.prototype.map.call(a,function(x)&amp;#123;return x.toLowerCase();&amp;#125;)//调用map方法</code></pre>
<h1 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h1><ul>
<li><strong>charAt</strong> 方法可用来访问单个字符(即可对字符串采取索引访问操作)</li>
<li>数组的通用操作也适用于字符串</li>
</ul>
<pre><code class="js">var a = &quot;hello!&quot;
a.charAt(2)//返回&#39;l&#39;
Array.prototype.filter.call(a,function(x)&amp;#123;return x.match(/[^aeiou]/);&amp;#125;)//只匹配非元音字符</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#016a99>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/js-05/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/js-04/">
        <h2>
            JS对象
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><ul>
<li>字符串、布尔值、数字等可通过包装器，构造一个临时对象</li>
<li>必要时，js会进行包装器与字符串、数字、布尔值的相互转换</li>
</ul>
<pre><code class="js">var a = &quot;hello&quot;;
var word = a.substring(a.indexOf(&quot;&quot;)+1,a.length);//结果word=ello
//substring() 方法用于提取字符串中介于两个指定下标之间的字符。
//indexOf() 方法返回某个指定的字符串值在字符串中首次出现的位置。</code></pre>
<h1 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h1><pre><code class="js">/*像py里的字典*/
var book =&amp;#123;
    &quot;main title&quot;:&quot;The Definitive Guide&quot;,
    &quot;author&quot;:&quot;David Flanagan&quot;
&amp;#125;;
//对象直接量的原型为constructor.prototype</code></pre>
<h1 id="new创建对象"><a href="#new创建对象" class="headerlink" title="new创建对象"></a>new创建对象</h1><pre><code class="js">var mydate = new Date();//new+构造函数创建对象 </code></pre>
<h1 id="删除、查询、添加、继承"><a href="#删除、查询、添加、继承" class="headerlink" title="删除、查询、添加、继承"></a>删除、查询、添加、继承</h1><pre><code class="js">/*添加、查询对象属性 */
 var customer=&amp;#123;a1:&quot;1&quot;,a2:&quot;2&quot;,a3:&quot;3&quot;&amp;#125;
 var addr=&quot;&quot;;
 for(i=0;i&lt;4,i++)&amp;#123;//拼接customer属性
     addr+=customer[&quot;a&quot;+i]+&#39;\n&#39;
 &amp;#125;
 customer.a4 =&#39;4&#39;;//为customer创建一个名为a4的属性，值为4
 customer[a5]=&quot;5&quot;//为customer创建一个名为a5的属性，值为5
 var mynumber =customer.a4;//查询customer的a4属性，并将其赋值于此变量
/*继承对象、删除对象属性*/
 var o = &amp;#123;&amp;#125;
 o.x = 1;
 var p = inherit(o);//继承对象，包含其toString方法与属性
 p.y = 2;
 delete p.x;//delete无法删除对象继承的属性，可直接在其父上操作 delete o.x;
 var q = inherit(p);
 q.z = 3;
 var s = q.toString();
/*delete:用来删除对象属性（包含数组元素），也可删除未使用var声明的变量包含（this.的全局变量）*/</code></pre>
<h1 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h1><ul>
<li><p>读取、写入、可枚举、可配置</p>
</li>
<li><p>只有getter方法，就是只读属性</p>
</li>
<li><p>只有setter方法 ，就是只写属性  </p>
</li>
</ul>
<pre><code class="js">/*直接定义存储器属性*/
var random = &amp;#123;
    get octet()&amp;#123;
        return Math.floor(Math.random() *256);
    &amp;#125;,
    get uint16()&amp;#123;
        return Math.floor(Math.random() *65536);
    &amp;#125;,
    get int16()&amp;#123;
        return Math.floor(Math.random() *65536)-32768;
    &amp;#125;
&amp;#125;;</code></pre>
<pre><code class="js">/*老式api*/
__lookupGetter__(),__lookupSetter__()//返回属性的getter与setter方法；
__defineSetter__(),__defineGetter__()//定义属性的getter与setter方法；//有两个参数，第一个为属性名字，第二个是getter与seeter方法</code></pre>
<h2 id="设置属性特性"><a href="#设置属性特性" class="headerlink" title="设置属性特性"></a>设置属性特性</h2><p><strong>属性特性</strong>  包括：值、可写性、可枚举性、可配置性，分别对应：value,writable,enumerable,configurable</p>
<pre><code class="js">/**
 * 设置属性特性
 */
/*单个 */
var o =&amp;#123;&amp;#125;;
Object.defineProperty(o,&quot;x&quot;,&amp;#123;value:1,writable:true,enumerable:false,configurable:true&amp;#125;);
//Object.defineProperty方法修改自己已有属性或创建自有属性，不可修改继承属性
Object.keys(o);//将o.x属性变为只读
o.x =2 ;//操作失败
Object.defineProperty(o,&quot;x&quot;,&amp;#123;value:2&amp;#125;);

/*多个 */
var p = Object.defineProperties(&amp;#123;&amp;#125;,&amp;#123;x:&amp;#123;value:1,writable:true,enumerable:true,configurable:true&amp;#125;,
    y:&amp;#123;value:1,writable:true,enumerable:true,configurable:true&amp;#125;,
    r:&amp;#123;get:function()&amp;#123;return Math.sqrt(this.x*this.x+this.y*this.y)&amp;#125;,
enumerable:true,configurable:true&amp;#125;
&amp;#125;);



/*复制属性特性 */
Object.defineProperty(Object.prototype,&quot;extend&quot;,
/*定义Object.prototype.extend*/
&amp;#123;writable:true,enumerable:false,configurable:true,value:function(o)&amp;#123;
    var names = Object.getOwnPropertyNames(o);//得到所有自由属性包括不可枚举属性
    for (var i = 0; i&lt; names.length; i++)&amp;#123;
        if(names[i]in this)continue;//如果属性已存在，则跳过
        var desc = Object.getOwnPropertyDescriptor(o,names[i]);//为this创建一个属性
        Object.defineProperty(this,names[i],desc);
    &amp;#125;
&amp;#125;&amp;#125;);</code></pre>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><ul>
<li>获取对象的属性描述</li>
</ul>
<pre><code class="js">对于继承属性与不存在属性均返回undefined</code></pre>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><ul>
<li>修改已创建对象的属性特性，不能修改继承属性</li>
</ul>
<pre><code class="js">/*用法：Object.defineProperty(操作对象，属性名，&amp;#123;属性描述符对象：value,writable,enumerable,configurable&amp;#125;)*/
var o =&amp;#123;&amp;#125;;
Object.defineProperty(o,&quot;x&quot;,&amp;#123;value:1,writable:true,enumerable:false,configurable:true&amp;#125;);//为对象O创建一个不可枚举的属性x
//修改或创建完成后返回新的对象</code></pre>
<h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><ul>
<li>同时修改多个对象属性特性，不能修改继承属性</li>
</ul>
<pre><code class="js">var p = Object.defineProperties(&amp;#123;&amp;#125;,&amp;#123;x:&amp;#123;value:1,writable:true,enumerable:true,configurable:true&amp;#125;,//p是一个空对象
                                    /*为其创建x，y，r属性*/
    y:&amp;#123;value:1,writable:true,enumerable:true,configurable:true&amp;#125;,
    r:&amp;#123;get:function()&amp;#123;return Math.sqrt(this.x*this.x+this.y*this.y)&amp;#125;,
enumerable:true,configurable:true&amp;#125;
&amp;#125;);</code></pre>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul>
<li>通过对象直接量创建的对象使用Object.prototype作为它们的原型</li>
<li>new创建的对象，prototype作为其原型</li>
<li>Object.create()创建的对象，使用第一个参数作为其原型（可以是null）</li>
</ul>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><ul>
<li>创建</li>
</ul>
<pre><code class="js">var p =&amp;#123;x:1&amp;#125;;
var o =Object.create(p);//使用原型p创建对象o
p.isPrototype(o)//o继承至p?
Object.prototype.isPrototypeOf(o)//P继承至Object.prototype？</code></pre>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><ul>
<li>查询对象原型</li>
</ul>
<pre><code class="js">var a = &amp;#123;&amp;#125;;
Object.getPrototypeOf(a);</code></pre>
<h1 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h1><ul>
<li>是否可以添加、删除属性；</li>
</ul>
<pre><code class="js">/*将对象传入*/
Object.esExtensible()//判断对象是否可扩展
Object.isSealed()//检测对象是否封闭（不可扩展）
Object.prevenExtensions()//将对象自身转换为不可扩展的（此操作不可逆），其原型添加属性时此对象仍会继承这些属性
Object.seal()//与Object.prevenExtensions()类似
Object.freeze()//冻结：不可扩展且数据属性设置为只读（setter存储器属性不受影响）
Object.isFrozen();//检测是否冻结
/*创建一个封闭（不可扩展）对象，包含一个冻结原型一个不可枚举属性*/
var o = Object.seal(Object.create(Object.freeze(&amp;#123;x:1&amp;#125;),&amp;#123;y:&amp;#123;value:2,writable:true&amp;#125;&amp;#125;));</code></pre>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><pre><code class="js">/*序列化对象 */
o = &amp;#123;x:1,y:&amp;#123;z:[false,null,&quot;&quot;]&amp;#125;&amp;#125;;
s = JSON.stringify(o);//序列化对象o（转换为字符串）
p = JSON.parse(s);//还原为对象,p是深度复制</code></pre>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#607d8b>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/js-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/js-03/">
        <h2>
            JS函数
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>函数方法（方法体同声明均提升到顶部位置）</p>
<pre><code class="JavaScript">function printprops(o)&amp;#123;
            for(var p in o)&amp;#123;
                console.log(p + &quot;:&quot; + o[p] + &quot;\n&quot;);

            &amp;#125;
        &amp;#125;//返回nudefined</code></pre>
<p>函数表达式（方法体原地保留、仅提前声明）</p>
<pre><code class="javascript">        var f = function(x)&amp;#123;return x*x;&amp;#125;//适合做只用一次的函数</code></pre>
<p>函数中声明的变量仅在函数体内可见，因此可用函数来声明局部变量（也可通过let方法声明局部块）</p>
<pre><code class="javascript">        (function()&amp;#123;/*局部变量*/&amp;#125;());//结束并立即调用函数</code></pre>
<p>函数是特殊的对象，所以也可拥有属性、方法，还可使用Function构造函数对象</p>
<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><ul>
<li><p>省略的实参都是undefined，多出的参数自动省略</p>
</li>
<li><p>函数可赋值给变量、存储在数组、对象属性中（称为方法），还可作为参数传入另一函数</p>
<pre><code class="javascript">/**函数赋值于变量*/
function square(x)&amp;#123;return x*x;&amp;#125;
var s = square;
/**函数作为对象属性，此时叫方法*/
var o=&amp;#123;square:function(x)&amp;#123;return x*x;&amp;#125;&amp;#125;;
/*函数存储在数组中*/
var a = [function(x)&amp;#123;return x*x;&amp;#125;,20];
a[0](a[1]);//看似nb的直接量调用a0的括号中装上a1，哈哈</code></pre>
</li>
</ul>
<ul>
<li><p>内部函数可使用外部函数的参数和变量</p>
<pre><code class="javascript">function hypotenuse(a,b)&amp;#123;
            function square(x)&amp;#123;return x*x;&amp;#125;
            return Math.sqrt(square(a)+square(b))
    //调用square函数时，传入了外部函数的a,b参数
        &amp;#125;</code></pre>
</li>
</ul>
<h2 id="函数作为对象方法"><a href="#函数作为对象方法" class="headerlink" title="函数作为对象方法"></a>函数作为对象方法</h2><pre><code class="js">var o =&amp;#123;
            m:function()&amp;#123;//函数作为对象方法
                var self = this;//指代对象O
                console.log(this====o);
                f();
                function f()&amp;#123;//嵌套函数
                    console.log(this===o);//这里的this不是O
                    console.log(self===o);
                &amp;#125;
            &amp;#125;
        &amp;#125;;
        o.m();</code></pre>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><pre><code class="javascript">var o = new Object();//无参数构造函数
var o = new Object;//无参数构造函数</code></pre>
<h1 id="实参对象"><a href="#实参对象" class="headerlink" title="实参对象"></a>实参对象</h1><ul>
<li><p>arguments标识符指向实参对象引用</p>
<pre><code class="javascript">function f(x)&amp;#123;
            console.log(x);
            arguments[0]=null;//修改参数x
            console.log(x);
        &amp;#125;</code></pre>
<h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><ul>
<li><p>指代当前执行的函数</p>
<pre><code class="javascript">    var factorial = function(x)&amp;#123;
            if(x&lt;=1)return 1;
            return x*arguments.callee(x-1);//递归调用
        &amp;#125;</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>接收任意数量的实参</p>
<pre><code>function max(/*number...*/)&amp;#123; &amp;#125;</code></pre>
</li>
</ul>
<h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><pre><code class="javascript">uniquelnteger.counter = 0;//为函数属性设置初始值
function uniquelnteger()&amp;#123;
    return uniquelnteger.counter++;
&amp;#125;
/**作为数组储存*/
function factorial(n)&amp;#123;
            if(isFinite(n)&amp;&amp;n&gt;0&amp;&amp;n===Math.round(n))&amp;#123;
                if(!(n in factorial))//判断n在不在
                factorial[n]=n*factorial(n-1);//计算并存储a
                return factorial[n];
            &amp;#125;else return NaN;
        &amp;#125;factorial[1]=1</code></pre>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><pre><code class="javascript">var scope = &quot;global scope&quot;;
        function checkscope()&amp;#123;
            var scope = &quot;local scope&quot;;
            function f()&amp;#123;return scope;&amp;#125;
            return f();
        &amp;#125;
        checkscope();//返回局部变量值local scope

/**************类似java对象之间的闭包性*******************/
function counter()&amp;#123;
            var n = 0;
            return&amp;#123;
                count:function()&amp;#123;return n++;&amp;#125;,
                reset:function()&amp;#123;n = 0;&amp;#125;
            &amp;#125;;
        &amp;#125;
        var c = counter(),d = counter();//即分别创建两个作用域链
        c.count(),d.count();//初始值都是0，调用后+1
        c.reset();//重置c为0，对其中一个作用域lian
        c.count(),d.count();//c-0 ，d-1
/*******************实现存取器***************/
//用参数n保存变量值
function counter(n)&amp;#123;
    return&amp;#123;
        get count()&amp;#123;return n++;&amp;#125;,
        set count(m)&amp;#123;
            if(m&gt;=n)n=m;
            else throw Error(&quot;count can only be set to a larger value&quot;);
        &amp;#125;
    &amp;#125;;
&amp;#125;
var c = counter(1000);
c.count;
c.count;//访问（读）操作
c.count = 2000;//写操作

/********访问实例：********/
/*错误的闭包示范*/
        function constfuncs()&amp;#123;
            var funcs=[];
            for(var i=0;i&lt;10;i++)
            funcs[i]=function()&amp;#123;return i;&amp;#125;;//闭包内的i是同一个i，即最终i=10
            return funcs;//最终返回10
        &amp;#125;
        var funcs=constfuncs();
        funcs[5]()//10
/*正确的闭包示范*/    
        function constfuncs(v)&amp;#123;return function()&amp;#123;return v;&amp;#125;;&amp;#125;
        var funcs =[];
        for(var i = 0 ;i&lt;10; i++)funcs[i]=constfuncs(i);//在闭包外每个i都是不同的i
        funcs[5]()//5</code></pre>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call( ),apply( )"></a>call( ),apply( )</h2><pre><code class="javascript">f.call(o);//以对象o的方法形式调用函数f
f.apply(o);
f.call(o ,1,2)//以对象o的方法形式调用函数f，并传入参数
f.apply(o,[1,2]);</code></pre>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind( )"></a>bind( )</h2><ul>
<li><p>绑定，一个函数调用bind( )方法，并传入一个对象，那么bind( )方法会返回一个新的函数，调用新的函数即可把原函数当作传入对象的方法来使用</p>
<pre><code class="javascript">function f(y)&amp;#123;return this.x+y;&amp;#125;;//函数
var o =&amp;#123;x:1;&amp;#125;;//对象
var g = f.bind(o);//新函数
g(2);//调用新函数</code></pre>
</li>
</ul>
<h1 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li>每次调用**Function( )**就会创建新对象</li>
</ul>
<pre><code class="javascript">var f = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x*y&quot;);
//等同于 var f=function(x,y)&amp;#123;return x*y&amp;#125;</code></pre>
<ul>
<li>Function( )构建对象的函数体编译会在顶层函数（全局作用域）进行</li>
</ul>
<pre><code class="javascript">var scope = &quot;hello&quot;;
function a()&amp;#123;
var scope = &quot;world&quot;;
return new Function(&quot;return scope&quot;);
&amp;#125;
a()();//返回hello</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#607d8b>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/js-03/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/js-02/">
        <h2>
            变量&&语法
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>函数体内局部变量优先级高于全局变量；</p>
<p>函数内的变量声明将提升至函数体顶部，同时在原位置完成初始化var声明；</p>
<p>在for循环中使用var声明变量时，该变量的作用域为for循环所属函数。</p>
<pre><code class="js"> var a=[];  
 for(var i = 0;i&lt;10;i++)&amp;#123;  
     var q = i;  
    a[i]=function()&amp;#123;console.log(q)&amp;#125;  
 &amp;#125;  
 a[0]()  

/*其中，由于for循环并不是一个函数体，所以for循环中定义的变量q和i是作用域for循环所在的函数体，和a同级，  
i++ 和  q=i 并不是重新定义变量，只是重复赋值，最终循环结束，i = 10,q=9; */ </code></pre>
<p>let声明的变量，只在let所在的代码块有效果</p>
<pre><code class="js">1.  var a=[];  
2.  for(let i = 0;i&lt;10;i++)&amp;#123;  
3.     ley q = i;  
4.     a[i]=function()&amp;#123;console.log(q)&amp;#125;  
5.  &amp;#125;  
6.  a[6]()    
//这里会输出   6  let声明的变量仅在块级作用域有效，所以这里的i只在本轮循环有效果，每次循环的i其实都是一个新的变量</code></pre>
<h1 id="function-声明"><a href="#function-声明" class="headerlink" title="function 声明"></a>function 声明</h1><pre><code class="js">/*定义一个函数 */
//one:
function mysqrt(x)&amp;#123;//使用此声明则函数名与函数初始化块均“提前”到脚本或函数的顶部
    return Math.sqrt(x*x);

&amp;#125;
//two
var mysqrt = function(x)&amp;#123;return Math.sqrt(x*x);&amp;#125;//使用此声明则仅有变量声明“提前”到脚本或函数的顶部，初始化体仍在原来的位置</code></pre>
<h1 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h1><ul>
<li>for-in 会跳过null、undefined</li>
<li>只遍历可枚举的（包含继承的属性名）</li>
</ul>
<pre><code class="js">/*使用for-in 变量数组元素 */
var o = &amp;#123;x:1,y:2,z:3&amp;#125;
var a = [],i = 0//声明一个数组与一个变量
for(a[i++]in o); 
</code></pre>
<h1 id="continue-break"><a href="#continue-break" class="headerlink" title="continue,break"></a>continue,break</h1><p>带标签的continue,break作用相同，均是跳转到指定循环（均不得跳转至所属函数边界，即所属函数外）</p>
<pre><code class="js">mainloop: while(token!=null)&amp;#123;
    continue mainloop;
&amp;#125;
mainloop: while(token!=null)&amp;#123;
    break mainloop;//mainloop为自定义标记
&amp;#125;</code></pre>
<h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h1><p>检索对象列表，解析变量名</p>
<pre><code>
/*用于简化代码*/
with(document.forms[0])&amp;#123;
    name.value=&quot;&quot;;
    address.value=&quot;&quot;;
    email.value=&quot;&quot;;
&amp;#125;
/*简化前*/
var f = document.form[0];
f.name.value=&quot;&quot;;
f.address.value=&quot;&quot;;
f.email.value=&quot;&quot;;</code></pre>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="严格相等"><a href="#严格相等" class="headerlink" title="===严格相等"></a>===严格相等</h2><ul>
<li>比较过程中没有类型的转换，两个值类型不同则其不等</li>
<li>值为null或undefined则其不等</li>
<li>均是相同的布尔值则相等</li>
<li>其中一个值为NaN则不等**</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><ul>
<li>值为null或undefined则其相等</li>
<li>两个不同类型的值转换后相等则其相等（如：true转换为1 false转换为0 再进行比较）</li>
</ul>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><ul>
<li>左操作数是一个字符串或可以转换为字符串，有操作数是一个对象</li>
<li>如右侧对象包含左侧操作数，表达式返回true</li>
</ul>
<pre><code class="js">var a = &amp;#123;x:a&amp;#125;
&quot;x&quot; in a; //true</code></pre>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ul>
<li>如左侧对象是右侧类的实例，表达式将返回true</li>
</ul>
<pre><code class="js">var mynew = new Date();
mynew instanceof Date;//返回true</code></pre>
<h1 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a>null、undefined</h1><ul>
<li>null是一个特殊对象（非对象），多用来表示字符串、数字、对象得无值。</li>
<li>undefined（未定义） 表示属性或元素不存在</li>
<li>===可区分null与undefined，而==则不行</li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code class="js">x+&quot;&quot;//等价于String(x)
+x//等价于Number(x)
!!x//等价于Boolean(x)</code></pre>
<p><strong>对象向字符串转换</strong></p>
<p>有toString则通过此方法将其变为字符串，无toString则通过ValueOf，二者均无则报错。</p>
<p>空数组向数值转换结果为0</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul>
<li>throw 抛出异常</li>
</ul>
<pre><code class="js">try&amp;#123;/*可能出现异常的代码*/&amp;#125;
catch()&amp;#123;/*对异常的处理*/&amp;#125;
finally&amp;#123;/*不管发不发生异常都执行的语句*/&amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#607d8b>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/js-02/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/JS-01/">
        <h2>
            JS作用域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>JavaScript是编译型语言，不同的是JavaScript的代码编译发生在代码执行前的几微秒内</p>
<h1 id="LHS与RHS"><a href="#LHS与RHS" class="headerlink" title="LHS与RHS"></a>LHS与RHS</h1><p>LHS查找的目的为了赋值</p>
<p>RHS查找的目的是为了引用值</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域查找从词法作用域（即最内部作用域）开始逐层向上查找，直到匹配到或触顶为止</p>
<img src="http://img.lbkzw.cn/img/20200830120120.png" alt="screenshot_2020_08_13T21_09_28+0800" style="zoom:50%;" />

<p>全局变量会自动成为全局对象，因此可通过<code> window.a（a是要访问的变量）</code>访问被同名变量屏蔽的全局变量</p>
<h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>使用欺骗词法则JavaScript引擎无法对作用域栈进行优化</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><pre><code class="js">    /*在函数内动态创建变量b，屏蔽全局变量b*/
        function foo(str,a)&amp;#123;
            eval(str);//动态创建代码
            console.log(a,b);
        &amp;#125;
        var b = 2;
        foo(&quot;var b = 3;&quot;,1);
    /*结果：1,3*/</code></pre>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><pre><code class="js">/*重复引用对象的多个属性*/
        var obj = &amp;#123;
            a = 1,
            b = 2
        &amp;#125;;
        with(obj)&amp;#123;
            a = 3;
            b = 4;
            c = 5;//对象obj中没有c，返回undefined,并创建一个全局变量c = 5;
        &amp;#125;</code></pre>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数中的作用域属于局部作用域，函数具有很好的闭包性，隐藏该隐藏的。</p>
<p>JavaScript中多</p>
<h3 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h3><ul>
<li>两种方式</li>
</ul>
<pre><code class="js">/*ONE*/
        (function foo()&amp;#123;
            var a = 2;
            console.log(a);
        &amp;#125;)();
/*TWO*/  
        (function foo()&amp;#123;
            var a = 2;
            console.log(a);
        &amp;#125;());//括号位置不同哦</code></pre>
<ul>
<li>传入参数</li>
</ul>
<pre><code class="js">       /*传入window对象，引用全局变量*/
        var a = 2;
        (function (global)&amp;#123;//匿名IIFE
            var a = 3;
            console.log(a); 
            console.log(global.a);
        &amp;#125;)(window)
/*结果：3,2*/</code></pre>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>变量声明、函数声明均会提升到顶部。</p>
<p>let声明的块中的变量声明不会提升，而是保留在原地</p>
<p>函数先于变量提升，函数表达式不会被提升，后面的函数声明覆盖前面的函数声明</p>
<pre><code class="js">        function a()&amp;#123;
            console.log(1);
        &amp;#125;
        a = function a()&amp;#123;//不会被提升
            console.log(2);
        &amp;#125;        
        function a()&amp;#123;
            console.log(3);
        &amp;#125;
        a();
/*结果：3*/</code></pre>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>调用一个函数只返回其属性数据，而没有返回闭包对象（函数内的函数）的不是真模块</p>
<p>具有函数属性的对象不是真模块</p>
<pre><code class="js">/*一个模块*/
        function CoolModule()&amp;#123;
            var something = &quot;so&quot;;
            var another = [1,2,3];
            function doSomething()&amp;#123;
                console.log(something);
            &amp;#125;
            function doAnother()&amp;#123;
                console.log(another.join(&quot;!&quot;));
            &amp;#125;
            return &amp;#123;
                doSomething:doSomething,
                doAnother:doAnother
            &amp;#125;;
        &amp;#125;
        var foo = CoolModule();
        foo.doAnother();
        foo.doSomething();


/*一个单例模式*/
        var foo = (function CoolModule()&amp;#123;
            var something = &quot;so&quot;;
            var another = [1,2,3];
            function doSomething()&amp;#123;
                console.log(something);
            &amp;#125;
            function doAnother()&amp;#123;
                console.log(another.join(&quot;!&quot;));
            &amp;#125;
            return &amp;#123;
                doSomething:doSomething,
                doAnother:doAnother
            &amp;#125;;
        &amp;#125;)();
        foo.doAnother();
        foo.doSomething();
/*结果：
1！2！3！
so
*/</code></pre>
<h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><h4 id="未来模块机制（python）"><a href="#未来模块机制（python）" class="headerlink" title="未来模块机制（python）"></a>未来模块机制（python）</h4><pre><code>//a.js,一个单独的模块
function a()&amp;#123;
    ...
&amp;#125;
export a;//将当前模块的（变量、函数）标识符导出为公共API
</code></pre>
<pre><code>//b.js
import a from &quot;a&quot;;//从模块a，导入函数a()
function b()&amp;#123;
    ...
&amp;#125;
export b;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#006674>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/JS-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/JDBC-01/">
        <h2>
            JDBC基本使用
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>前言：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库，是官方（sun公司）定义的一套操作所有关系型数据库的接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<ul>
<li>步骤：<ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar<br> 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下<br> 2.右键–&gt;Add As Library</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行sql语句的对象 Statement</li>
<li>执行sql，接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
</ul>
<h1 id="Statement：执行sql的对象"><a href="#Statement：执行sql的对象" class="headerlink" title="Statement：执行sql的对象"></a>Statement：执行sql的对象</h1><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><blockquote>
<ol>
<li><p>boolean execute(String sql) ：可以执行任意的sql</p>
</li>
<li><p>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句,即增删改查</p>
<blockquote>
<p>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</p>
</blockquote>
</li>
</ol>
</blockquote>
<pre><code class="java">package cn.itcast.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class TestJDBC1&amp;#123;
    public static void main(String[] args) &amp;#123;
        Statement stmt = null;
        Connection conn = null;
        try &amp;#123;
            //注册驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //定义sql语句
            String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;
            //获取Connection对象
            conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;,&quot;root&quot;,&quot;root&quot;);
            //获取执行sql的对象Statement
            stmt = conn.createStatement();
            //执行sql
            int count = stmt.executeUpdate(sql);//此方法将返回执行后的影响行数数值,此方法用于执行增、删、改、查的sql语句
            // int count = stmt.execute(sql) ：可以执行任意的sql
            System.out.println(count);
            if(count &gt; 0)&amp;#123;
                System.out.println(&quot;添加成功！&quot;);
            &amp;#125;else&amp;#123;
                System.out.println(&quot;添加失败！&quot;);
            &amp;#125;
        &amp;#125; catch (ClassNotFoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (SQLException throwables) &amp;#123;
            throwables.printStackTrace();
        &amp;#125;finally &amp;#123;
            //释放资源
            if (stmt != null)&amp;#123;
                try &amp;#123;
                    stmt.close();
                &amp;#125; catch (SQLException throwables) &amp;#123;
                    throwables.printStackTrace();
                &amp;#125;
            &amp;#125;
            if (conn != null)&amp;#123;
                try &amp;#123;
                    conn.close();
                &amp;#125; catch (SQLException throwables) &amp;#123;
                    throwables.printStackTrace();
                &amp;#125;
            &amp;#125;
        &amp;#125;

    &amp;#125;
&amp;#125;</code></pre>
<h2 id="封装数据库表到对象"><a href="#封装数据库表到对象" class="headerlink" title="封装数据库表到对象"></a>封装数据库表到对象</h2><blockquote>
<p>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</p>
<p>（可用来将表数据封装为对象并装载入集合）</p>
</blockquote>
<pre><code class="java">package cn.itcast.jdbc;

import java.sql.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class TestJDBC3 &amp;#123;

    public List&lt;Emp&gt; findAll()&amp;#123;
        Statement stmt = null;
        Connection conn = null;
        ResultSet rs = null;
        List&lt;Emp&gt;list = null;
        try &amp;#123;
            //注册驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //定义sql语句
            String sql = &quot;select * from emp&quot;;
            //获取Connection对象
            conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;,&quot;root&quot;,&quot;root&quot;);
            //获取执行sql的对象Statement
            stmt = conn.createStatement();
            //执行sql
            rs = stmt.executeQuery(sql);
            Emp emp = null;
            list = new ArrayList&lt;Emp&gt;();

            while (rs.next())&amp;#123;
//        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
//                        * getXxx(参数):获取数据
//                        * Xxx：代表数据类型   如： int getInt() ,    String getString()
//                        * 参数：
//                1. int：代表列的编号,从1开始   如： getString(1)
//                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)

                //获取数据
                int id = rs.getInt(&quot;id&quot;);
                String ename = rs.getString(&quot;ename&quot;);
                int job_id = rs.getInt(&quot;job_id&quot;);
                int mgr = rs.getInt(&quot;mgr&quot;);
                Date joindate = rs.getDate(&quot;joindate&quot;);
                double salary = rs.getDouble(&quot;salary&quot;);
                double bonus = rs.getDouble(&quot;bonus&quot;);
                int dept_id = rs.getInt(&quot;dept_id&quot;);
                //创建Emp对象并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载进集合
                list.add(emp);
            &amp;#125;
        &amp;#125; catch (ClassNotFoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (SQLException throwables) &amp;#123;
            throwables.printStackTrace();
        &amp;#125;finally &amp;#123;
            //释放资源
            if (rs != null)&amp;#123;
                try &amp;#123;
                    rs.close();
                &amp;#125; catch (SQLException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
            if (stmt != null)&amp;#123;
                try &amp;#123;
                    stmt.close();
                &amp;#125; catch (SQLException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return list;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
       var a = new TestJDBC3();
        System.out.println(a.findAll());

    &amp;#125;
&amp;#125;</code></pre>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol>
<li>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li>
<li>操作：<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li>使用Connection对象来管理事务<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit() <ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback() <ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="java">        public class JDBCDemo10 &amp;#123;

        public static void main(String[] args) &amp;#123;
            Connection conn = null;
            PreparedStatement pstmt1 = null;
            PreparedStatement pstmt2 = null;

            try &amp;#123;
                //1.获取连接
                conn = JDBCUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);

                //2.定义sql
                //2.1 张三 - 500
                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;
                //2.2 李四 + 500
                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;
                //3.获取执行sql对象
                pstmt1 = conn.prepareStatement(sql1);
                pstmt2 = conn.prepareStatement(sql2);
                //4. 设置参数
                pstmt1.setDouble(1,500);
                pstmt1.setInt(2,1);

                pstmt2.setDouble(1,500);
                pstmt2.setInt(2,2);
                //5.执行sql
                pstmt1.executeUpdate();
                // 手动制造异常
                int i = 3/0;

                pstmt2.executeUpdate();
                //提交事务
                conn.commit();
            &amp;#125; catch (Exception e) &amp;#123;
                //事务回滚
                try &amp;#123;
                    if(conn != null) &amp;#123;
                        conn.rollback();
                    &amp;#125;
                &amp;#125; catch (SQLException e1) &amp;#123;
                    e1.printStackTrace();
                &amp;#125;
                e.printStackTrace();
            &amp;#125;finally &amp;#123;
                JDBCUtils.close(pstmt1,conn);
                JDBCUtils.close(pstmt2,null);
            &amp;#125;
        &amp;#125;

    &amp;#125;</code></pre>
<p>​        </p>
<h1 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h1><p>通常我们获取一个数据库连接对象，在使用后将其释放。这需要繁琐的申请与释放操作，而我们有更好的方案：即从数据库连接池处获取对象，在不使用的时候再将其归还到连接池中。</p>
<p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
<p>操作步骤：</p>
<ol>
<li>导入jar包 </li>
<li>定义配置文件：以properties形式，可叫任意名称，可放在任意目录下。</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
<h2 id="导入并使用jar包"><a href="#导入并使用jar包" class="headerlink" title="导入并使用jar包"></a>导入并使用jar包</h2><blockquote>
<ol>
<li><img src="http://img.lbkzw.cn/img/20200918202606.png" alt="image-20200918202606795" style="zoom: 50%;" />
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><img src="http://img.lbkzw.cn/img/20200918202636.png" alt="image-20200918202636057" style="zoom:50%;" />
</li>
</ol>
</blockquote>
<h2 id="Properties文件配置"><a href="#Properties文件配置" class="headerlink" title="Properties文件配置"></a>Properties文件配置</h2><pre><code class="java">driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/db4
username=root
password=root
initialSize=1//初始数据库连接数
maxActive=10//最大数据库连接数
maxWait=3000</code></pre>
<h2 id="数据库连接池的工具类"><a href="#数据库连接池的工具类" class="headerlink" title="数据库连接池的工具类"></a>数据库连接池的工具类</h2><pre><code class="java">package cn.itcast.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * Druid连接池的工具类
 */
public class JDBCUtils &amp;#123;

    //1.定义成员变量 DataSource
    private static DataSource ds ;

    static&amp;#123;
        try &amp;#123;
            //1.加载配置文件
            Properties pro = new Properties();
            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
            //2.获取DataSource
            ds = DruidDataSourceFactory.createDataSource(pro);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (Exception e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;

    /**
     * 获取连接
     */
    public static Connection getConnection() throws SQLException &amp;#123;
        return ds.getConnection();
    &amp;#125;

    /**
     * 释放资源
     */
    public static void close(Statement stmt,Connection conn)&amp;#123;
       /* if(stmt != null)&amp;#123;
            try &amp;#123;
                stmt.close();
            &amp;#125; catch (SQLException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;

        if(conn != null)&amp;#123;
            try &amp;#123;
                conn.close();//归还连接
            &amp;#125; catch (SQLException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;*/

       close(null,stmt,conn);
    &amp;#125;


    public static void close(ResultSet rs , Statement stmt, Connection conn)&amp;#123;


        if(rs != null)&amp;#123;
            try &amp;#123;
                rs.close();
            &amp;#125; catch (SQLException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;


        if(stmt != null)&amp;#123;
            try &amp;#123;
                stmt.close();
            &amp;#125; catch (SQLException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;

        if(conn != null)&amp;#123;
            try &amp;#123;
                conn.close();//归还连接
            &amp;#125; catch (SQLException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;
    &amp;#125;

    /**
     * 获取连接池方法
     */

    public static DataSource getDataSource()&amp;#123;
        return  ds;
    &amp;#125;

&amp;#125;</code></pre>
<p>使用连接池工具类</p>
<pre><code class="java">package cn.itcast.datasource.druid;

import cn.itcast.utils.JDBCUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * 使用新的工具类
 */
public class DruidDemo2 &amp;#123;

    public static void main(String[] args) &amp;#123;
        /*
         * 完成添加操作：给account表添加一条记录
         */
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &amp;#123;
            //1.获取连接
            conn = JDBCUtils.getConnection();
            //2.定义sql
            String sql = &quot;insert into account values(null,?,?)&quot;;
            //3.获取pstmt对象
            pstmt = conn.prepareStatement(sql);
            //4.给？赋值
            pstmt.setString(1,&quot;王五&quot;);
            pstmt.setDouble(2,3000);
            //5.执行sql
            int count = pstmt.executeUpdate();
            System.out.println(count);
        &amp;#125; catch (SQLException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;finally &amp;#123;
            //6. 释放资源
            JDBCUtils.close(pstmt,conn);
        &amp;#125;
    &amp;#125;

&amp;#125;</code></pre>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><blockquote>
<p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>导入jar包(注意版本要匹配，如mysql版本，数据库驱动版本等)</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ul>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ul>
</li>
<li><p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li>update():执行DML语句。增、删、改语句</li>
<li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul>
<li>注意：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li>queryForList():查询结果将结果集封装为list集合<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li>query():查询结果，将结果封装为JavaBean对象<ul>
<li>query的参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject：查询结果，将结果封装为对象<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="java">import cn.itcast.domain.Emp;
            import cn.itcast.utils.JDBCUtils;
            import org.junit.Test;
            import org.springframework.jdbc.core.BeanPropertyRowMapper;
            import org.springframework.jdbc.core.JdbcTemplate;
            import org.springframework.jdbc.core.RowMapper;

            import java.sql.Date;
            import java.sql.ResultSet;
            import java.sql.SQLException;
            import java.util.List;
            import java.util.Map;

            public class JdbcTemplateDemo2 &amp;#123;

                //Junit单元测试，可以让方法独立执行
                                //1. 获取JDBCTemplate对象
                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
                /**
                 * 1. 修改1号数据的 salary 为 10000
                 */
                @Test
                public void test1()&amp;#123;

                    //2. 定义sql
                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;
                    //3. 执行sql
                    int count = template.update(sql);
                    System.out.println(count);
                &amp;#125;

                /**
                 * 2. 添加一条记录
                 */
                @Test
                public void test2()&amp;#123;
                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;
                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);
                    System.out.println(count);

                &amp;#125;

                /**
                 * 3.删除刚才添加的记录
                 */
                @Test
                public void test3()&amp;#123;
                    String sql = &quot;delete from emp where id = ?&quot;;
                    int count = template.update(sql, 1015);
                    System.out.println(count);
                &amp;#125;

                /**
                 * 4.查询id为1001的记录，将其封装为Map集合
                 * 注意：这个方法查询的结果集长度只能是1
                 */
                @Test
                public void test4()&amp;#123;
                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;
                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);
                    System.out.println(map);
                    //&amp;#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&amp;#125;

                &amp;#125;

                /**
                 * 5. 查询所有记录，将其封装为List
                 */
                @Test
                public void test5()&amp;#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);

                    for (Map&lt;String, Object&gt; stringObjectMap : list) &amp;#123;
                        System.out.println(stringObjectMap);
                    &amp;#125;
                &amp;#125;

                /**
                 * 6. 查询所有记录，将其封装为Emp对象的List集合
                 */

                @Test
                public void test6()&amp;#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &amp;#123;

                        @Override
                        public Emp mapRow(ResultSet rs, int i) throws SQLException &amp;#123;
                            Emp emp = new Emp();
                            int id = rs.getInt(&quot;id&quot;);
                            String ename = rs.getString(&quot;ename&quot;);
                            int job_id = rs.getInt(&quot;job_id&quot;);
                            int mgr = rs.getInt(&quot;mgr&quot;);
                            Date joindate = rs.getDate(&quot;joindate&quot;);
                            double salary = rs.getDouble(&quot;salary&quot;);
                            double bonus = rs.getDouble(&quot;bonus&quot;);
                            int dept_id = rs.getInt(&quot;dept_id&quot;);

                            emp.setId(id);
                            emp.setEname(ename);
                            emp.setJob_id(job_id);
                            emp.setMgr(mgr);
                            emp.setJoindate(joindate);
                            emp.setSalary(salary);
                            emp.setBonus(bonus);
                            emp.setDept_id(dept_id);

                            return emp;
                        &amp;#125;
                    &amp;#125;);
                                        for (Emp emp : list) &amp;#123;
                        System.out.println(emp);
                    &amp;#125;
                &amp;#125;

                /**
                 * 6. 查询所有记录，将其封装为Emp对象的List集合
                 */

                @Test
                public void test6_2()&amp;#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));
                    for (Emp emp : list) &amp;#123;
                        System.out.println(emp);
                    &amp;#125;
                &amp;#125;

                /**
                 * 7. 查询总记录数
                 */

                @Test
                public void test7()&amp;#123;
                    String sql = &quot;select count(id) from emp&quot;;
                    Long total = template.queryForObject(sql, Long.class);
                    System.out.println(total);
                &amp;#125;

            &amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#016a99>
                Java
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/JDBC" style=color:#006674>
                JDBC
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/JDBC-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-Stack-01/">
        <h2>
            Stack,Queue,Tree
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/dataStructure">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                dataStructure
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <pre><code class="mermaid">graph LR

A[扫描输入] --&gt;B&amp;#123;是否为运算符&amp;#125;

    B --&gt; |是运算符| C&amp;#123;运算符栈是否为空&amp;#125;
    B --&gt;|是数值| D&amp;#123;判断是否为多位数&amp;#125;
    D --&gt;|是多位| J[扫描到运算符为止]
    J --&gt; K
    D --&gt;|是个位| K[压入数值栈]
    C --&gt;|为空| E[将运算符压入栈]
    C --&gt;|不为空| F&amp;#123;比较运算符优先级&amp;#125;
    F --&gt;|优先级高于栈顶| G[入栈]
    F --&gt;|优先级低于栈顶| H[弹出运算符栈与数值栈中元素]
    H --&gt;|进行计算| I[将计算结果与比较优先级的运算符分别入栈]
    O[中缀表达式算法]

</code></pre>
<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>方法：为每个运算符旁的数值加括号如:<code>a+b*c; </code>改为<code> (a+(b*c))</code>，再将运算符移到括号外，得到后缀表达式<code> abc*+</code></p>
<p>转为算法：</p>
<ol>
<li>新建运算符栈，从左至右扫描，</li>
<li>运算符栈空时直接入栈，不为空则比较优先级，优先级大于时直接入栈，等于或小于时先（原栈顶元素）出栈，（档期元素）再入栈</li>
<li>到达末尾（即扫描完毕时），弹出所有运算符并追加到表达式末尾</li>
</ol>
<p>后缀表达式求值：遇到符号弹出数值进行求值（数值优先处于符号右方）</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="数组实现："><a href="#数组实现：" class="headerlink" title="数组实现："></a>数组实现：</h2><pre><code class="java">package com.pdf.data;

import org.junit.Test;

public class ArrayStack &amp;#123;
    /*字段分别为：栈大小、模拟栈的数组、栈顶*/
    private int maxsize;
    private int[] stack;
    private int top = -1;
    public ArrayStack(int maxsize)&amp;#123;
        this.maxsize = maxsize;
        stack = new int[this.maxsize];
    &amp;#125;
    /*The stack is full*/
    public boolean isFull()&amp;#123;
        return top+1 == maxsize;
    &amp;#125;
    /*The stack is void*/
    public boolean isEmpty()&amp;#123;
        return top == -1;
    &amp;#125;
    /*Press-in data*/
    public void push(int value)&amp;#123;
        if (isFull())&amp;#123;
            System.out.println(&quot;Stack fill&quot;);
            return;
        &amp;#125;
        top++;
        stack[top]=value;
    &amp;#125;
    /*Pop-up data*/
    public int pop()&amp;#123;
        if (isEmpty())&amp;#123;
            throw new RuntimeException(&quot;Stack Void&quot;);
        &amp;#125;
        int value = stack[top];
        top--;
        return value;
    &amp;#125;
    /*print Stack*/
    public void list()&amp;#123;
        if (isEmpty())&amp;#123;
            System.out.println(&quot;Stack void&quot;);
            return;
        &amp;#125;
        for (int i=top;i&gt;=0;i--)&amp;#123; System.out.printf(&quot;stack[%d]=%d\n&quot;,i,stack[i]);
        &amp;#125;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        var mStack = new ArrayStack(100);
        for (int i = 1; i &lt; 101; i++) &amp;#123;
            assert i &lt; 50:i;//断言
            mStack.push(i);
        &amp;#125;
        mStack.list();

    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="链表实现："><a href="#链表实现：" class="headerlink" title="链表实现："></a>链表实现：</h2><pre><code class="java">package com.abstrast.data.stack;

import java.util.EmptyStackException;

/*链表实现栈*/
public final class LinkedStack&lt;T&gt; implements StackInterface&lt;T&gt; &amp;#123;
    private Node topNode;//指向栈顶
    public LinkedStack()&amp;#123;
        topNode = null;
    &amp;#125;
    /*节点类*/
    private class Node&amp;#123;
        private T data;
        private Node next;
        Node(T newEntry,Node topNode)&amp;#123;
            data = newEntry;
            next = topNode;

        &amp;#125;

        public Node getNextNode() &amp;#123;
            return next;
        &amp;#125;

        public T getData() &amp;#123;
            return data;
        &amp;#125;
    &amp;#125;
    @Override
    public void push(T newEntry) &amp;#123;
//        Node newNode = new Node(newEntry,topNode);
//        topNode = newNode;
        topNode = new Node(newEntry,topNode);// 压入数据时直接指向栈顶
    &amp;#125;

    @Override
    public T pop() &amp;#123;
        T top = peek();
        topNode = topNode.getNextNode();
        return top;
    &amp;#125;

    @Override
    public T peek() &amp;#123;//查看栈顶元素
       if(isEmpty())
           throw new EmptyStackException();
       else
           return topNode.getData();
    &amp;#125;

    @Override
    public boolean isEmpty() &amp;#123;
        return topNode ==null;//顶栈为null则为空
    &amp;#125;

    @Override
    public void clear() &amp;#123;//没有顶栈则栈为空
        topNode = null;

    &amp;#125;

//    public static void main(String[] args) &amp;#123;
//        var a = new LinkedStack&lt;String&gt;();
//        a.push(&quot;a&quot;);
//        a.push(&quot;b&quot;);
//        a.push(&quot;c&quot;);
//        a.push(&quot;d&quot;);
//        a.peek();
//        a.pop();
//        a.peek();
//    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h2><pre><code class="java">import java.util.Iterator;
/**
 * 这是一个动态数组栈*/

public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;&amp;#123;//实现Iterable&lt;Item&gt;接口后可以使用foreach遍历
    private Item[] a = (Item[]) new Object[1];//栈元素数量，通过强制类型转换Object数组实现泛型号=数组
    private int N = 0;//元素数量
    public boolean isEmpty()&amp;#123;
        return N == 0;
    &amp;#125;
    public int size()&amp;#123;
        return N;
    &amp;#125;
    /*实现动态数组*/
    private void resize(int max)&amp;#123;
        Item[] temp = (Item[]) new Object[max];//创建空间大小为2倍的新数组
        for (int i = 0; i &lt; N; i++)&amp;#123;//复制数组元素
            temp[i] = a[i];
        &amp;#125;
        a = temp;
    &amp;#125;
    public void push(Item item)&amp;#123;
        if (N == a.length)resize(2*a.length);//数组存储空间不足，则扩大为2倍
        a[N++] = item;//每次添加元素N+1
    &amp;#125;
    public Item pop()&amp;#123;
        Item item = a[--N];
        a[N] = null;//防止游离元素，即不在栈中，但仍存在于数组中的元素
        if (N &gt; 0&amp;&amp;N == a.length/4)resize(a.length/2);//如果该数组仅仅占用1/4,那么缩小它
        return item;
    &amp;#125;
    public Iterator&lt;Item&gt; iterator()&amp;#123;//实现了一个迭代器
        return new ReverseArrayIterator();
    &amp;#125;
    private class ReverseArrayIterator implements Iterator&lt;Item&gt;&amp;#123;
        private int i = N;
        public boolean hasNext()&amp;#123;return  i &gt; 0;&amp;#125;
        public Item next()&amp;#123;return a[--i];&amp;#125;//next即越过并返回这个元素，
        // 数组下标从0开始，而数组中只要存在元素那么数量便从1开始，故需要减1（否则下标N下的元素不存在则返回null）
        public void remove()&amp;#123;&amp;#125;
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        long startTime = System.currentTimeMillis(); // 获取开始时间
        var a = new ResizingArrayStack&lt;String&gt;();
        for (int i = 0; i &lt; 1000000; i++) &amp;#123;
            a.push(&quot;abc&quot;+i);
        &amp;#125;
        for (String s: a)
            System.out.println(s);
        long endTime = System.currentTimeMillis(); // 获取结束时间
        System.out.println(&quot;程序运行时间： &quot; + (endTime - startTime) + &quot;ms&quot;);


    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h2><pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue &lt;T&gt;implements Iterable&lt;T&gt;&amp;#123;
    /**分析：
     * 队列实现需包含：队列长度、头指针，尾指针、结点类。
     *功能:增、删、清空查看队列、队列有无、查看队列头元素
     * 迭代：队列类实现可迭代接口Iterable&lt;T&gt;，再由内部类实现迭代器。
     */
    private int length;
    private Node head,tail;

    /*节点类*/
    private class Node&lt;T&gt;&amp;#123;
        private T data;
        private Node next;

        Node(T data) &amp;#123;
            this.data = data;
        &amp;#125;

        @Override
        public String toString() &amp;#123;
            return &quot;Node(&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &#39;)&#39;;
        &amp;#125;
    &amp;#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&amp;#123;
//        return length!=0;也可以哦
        return head == null;
    &amp;#125;
    /*添加元素*/
    private void enqueue(T x)&amp;#123;
        if (isEmpty())&amp;#123;
            tail = head = new Node&lt;T&gt;(x);
            length++;
        &amp;#125;else &amp;#123;
            tail = tail.next = new Node&lt;T&gt;(x);//尾指针与与原尾结点均指向新结点
            length++;
        &amp;#125;
    &amp;#125;
    /*删除元素*/
    public T dequeue()&amp;#123;
        if (isEmpty())&amp;#123;
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &amp;#125;else&amp;#123;
            T returnValue = (T) head.data;
            head = head.next;
            length--;
            return returnValue;
        &amp;#125;
    &amp;#125;
    /*清空队列*/
    public void makeEmpty()&amp;#123;
        head=tail=null;
        length=0;
    &amp;#125;

    /*返回头元素*/
    public T getHead() throws Exception &amp;#123;
        if (isEmpty())&amp;#123;
            throw new Exception(&quot;队列无数据&quot;);
        &amp;#125;else&amp;#123;
            return (T) head.data;
        &amp;#125;
    &amp;#125;
    /*查看队列中所有元素*/
    public void showQueue()&amp;#123;
        Node head =this.head;//引用head便于进行遍历
        while (head.next!=null)&amp;#123;
            System.out.println(head.data);
            head=head.next;
        &amp;#125;
        System.out.println(head.data);

    &amp;#125;
    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &amp;#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &amp;#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&amp;#123;
        private Node current = head;
        public boolean hasNext() &amp;#123;
            return current != null;
        &amp;#125;

        public void remove() &amp;#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &amp;#125;

        public T next() &amp;#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;
            current = current.next;
            return item;
        &amp;#125;

    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;ListQueue&amp;#123;&quot; +
                &quot;length=&quot; + length +
                &quot;, head=&quot; + head +
                &quot;, tail=&quot; + tail +
                &#39;&amp;#125;&#39;;
    &amp;#125;

    /*测试*/
    public static void main(String[] args) throws Exception &amp;#123;
        var a = new ListQueue&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &amp;#123;//添加元素
            a.enqueue(i);
        &amp;#125;
        for (int i: a) &amp;#123;
            System.out.println(i);

        &amp;#125;
      //覆盖toString只为了更直观的查看队列
        System.out.println(a+&quot;&quot;);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="数组模拟队列-amp-amp-单例模式"><a href="#数组模拟队列-amp-amp-单例模式" class="headerlink" title="数组模拟队列&amp;&amp;单例模式"></a>数组模拟队列&amp;&amp;单例模式</h2><pre><code class="java">import org.junit.Test;

public class ArrayQueue &amp;#123;

    private static int maxsize;
    /*分别创建最大容量、头指针、尾指针、数组*/
    private int front = -1;
    private int rear = -1;
    private int[] arr;
    private static ArrayQueue MYARRAYQUEUE;
    private ArrayQueue(int maxsize)&amp;#123;
        this.maxsize = maxsize;
        arr = new int[maxsize];
    &amp;#125;
    /*队列是否为满*/
    public boolean isFull()&amp;#123;
        return rear == maxsize-1;//因为尾、头部指针开始均指向-1，故容量减1为满
    &amp;#125;
    /*队列是否为空*/
    public boolean isEmpty()&amp;#123;
        return rear  == front;
    &amp;#125;
    /*添加数据到队列*/
    public void addQueue(int n)&amp;#123;
       if (isFull())&amp;#123;
           System.out.println(&quot;挤挤总会有的？？？&quot;);
           return;
       &amp;#125;
       arr[++rear]=n;// 写入尾部
    &amp;#125;
    public static synchronized ArrayQueue getArrayQueue(int a)&amp;#123;
        if(null != MYARRAYQUEUE)return MYARRAYQUEUE;
        maxsize = a;
        MYARRAYQUEUE = new ArrayQueue(a);
        return MYARRAYQUEUE;
    &amp;#125;

    public void showQueue() &amp;#123;
        var a = ArrayQueue.getArrayQueue(maxsize);
        // 遍历
        if (isEmpty()) &amp;#123;
            System.out.println(&quot;队列空的，没有数据~~&quot;);
            return;
        &amp;#125;
        for (int i = 0; i &lt; arr.length; i++) &amp;#123;
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);
        &amp;#125;
    &amp;#125;
&amp;#125;
class RunArrayQueue extends Thread&amp;#123;
    @Override
    public void run() &amp;#123;
        var a = ArrayQueue.getArrayQueue(4);
        a.showQueue();
        a.addQueue(4);
        a.addQueue(5);
        a.addQueue(6);
        a.showQueue();
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        var a = new RunArrayQueue();
        var b = new RunArrayQueue();
        a.start();
        b.start();
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><pre><code class="java">public class CircleArrayQueue &amp;#123;
    private static int maxsize;
    /*分别创建最大容量、头指针、尾指针、数组*/
    private int front = 0;
    private int rear = 0;
    private int[] arr;

    private CircleArrayQueue(int maxsize) &amp;#123;
        this.maxsize = maxsize;
        arr = new int[maxsize];
    &amp;#125;

    /*队列是否为满*/
    public boolean isFull() &amp;#123;
        return (rear + 1) % maxsize == front;
        //无论指针怎么移动，rear总与最后一个元素间隔一格
    &amp;#125;

    /*队列是否为空*/
    public boolean isEmpty() &amp;#123;
        return rear == front;
    &amp;#125;

    /*添加数据到队列*/
    public void addQueue(int n) &amp;#123;
        if (isFull()) &amp;#123;
            System.out.println(&quot;挤挤总会有的？？？&quot;);
            return;
        &amp;#125;
        arr[rear] = n;
        rear = (rear + 1) % maxsize;
    &amp;#125;

    /*取出数据*/
    public int getQueue() &amp;#123;
        if (isEmpty())&amp;#123;
            throw new RuntimeException(&quot;队列为空你币没了&quot;);
        &amp;#125;
        int value = arr[front];
        front = (front + 1)%maxsize;
        return value;

    &amp;#125;
    /*打印队列*/
    public void showQueue() &amp;#123;
        // 遍历
        if (isEmpty()) &amp;#123;
            System.out.println(&quot;队列空的，没有数据~~&quot;);
            return;
        &amp;#125;
        for (int i = 0; i &lt; front + size(); i++) &amp;#123;
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i%maxsize, arr[i%maxsize]);
        &amp;#125;
    &amp;#125;
    public int size()&amp;#123;
        return (rear + maxsize -front)%maxsize;
    &amp;#125;
    //显示队列头信息
    public int headQueue()&amp;#123;
        if (isEmpty())&amp;#123;
            throw new RuntimeException(&quot;队列为空&quot;);
        &amp;#125;
        return arr[front];
    &amp;#125;

    public static void main(String[] args) &amp;#123;
       var a = new CircleArrayQueue(10);
    &amp;#125;
&amp;#125;

</code></pre>
<h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><h3 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h3><pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue2&lt;T&gt;implements Iterable&lt;T&gt;&amp;#123;
    /**双向队列不带头结点
     */
    private int length;
    private Node head,tail;

    /*节点类*/
    private class Node&lt;T&gt;&amp;#123;
        private T data;
        private Node next;
        private Node prev;

        Node(T data) &amp;#123;
            this.data = data;
        &amp;#125;

        @Override
        public String toString() &amp;#123;
            return &quot;Node&amp;#123;&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &quot;, prev=&quot; + prev +
                    &#39;&amp;#125;&#39;;
        &amp;#125;
    &amp;#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&amp;#123;
//        return length==0;也可以哦
        return head == null;
    &amp;#125;
    /*队头添加元素*/
    private void addHead(T x)&amp;#123;
        if (isEmpty())&amp;#123;
            tail = head = new Node(x);
            length++;
            &amp;#125;
        else &amp;#123;
            Node newNode = head;//指向原head指向的首结点
            head = new Node(x);//将head指向添加的新结点
            //head.prev=null;类中的成员字段会自动初始化为null，故不必设置新首结点prev=null
            head.next = newNode;//将新结点的next指向原首节点
            newNode.prev = head;//原首结点的prev指向新结点
            length++;//队列长度+1
        &amp;#125;
    &amp;#125;
    /*队尾添加元素*/
    private void addTail(T x)&amp;#123;
        if (isEmpty())&amp;#123;
            tail = head = new Node(x);
            length++;
        &amp;#125;
        else &amp;#123;
            Node newNode = tail;
            tail = new Node(x);
            //tail.next=null;类中的成员字段会自动初始化为null，故不必设置新尾结点next=null
            newNode.next = tail;//原尾结点的next指向新结点
            tail.prev=newNode;//新结点的prev指向原尾结点
            length++;
        &amp;#125;
    &amp;#125;

    /*队头删除元素*/
    public T removeHead()&amp;#123;
        if (isEmpty())&amp;#123;//队列无元素抛出异常
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &amp;#125;else&amp;#123;
            T returnValue = (T) head.data;
            head = head.next;
            length--;
            //如果删除时队列中只存在一个元素则head=null，否则令首节点的prev=null
            if (length==0)&amp;#123;
                tail=head=null;
            &amp;#125;else &amp;#123;
                head.prev=null;
            &amp;#125;
            return returnValue;
        &amp;#125;
    &amp;#125;
    /*队尾删除元素*/
    public T removeTail()&amp;#123;
        if (isEmpty())&amp;#123;
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &amp;#125;else&amp;#123;
            T returnValue = (T) tail.data;
            tail = tail.prev;
            length--;
            if (length==0)&amp;#123;
                tail=head=null;
            &amp;#125;else &amp;#123;
                tail.next=null;
            &amp;#125;
            return returnValue;//返回被删除结点的值
        &amp;#125;
    &amp;#125;
    /*清空队列*/
    public void makeEmpty()&amp;#123;
        head=tail=null;
        length=0;
    &amp;#125;

    /*返回头元素*/
    public T getHead() throws Exception &amp;#123;
        if (isEmpty())&amp;#123;
            throw new Exception(&quot;队列无数据&quot;);
        &amp;#125;else&amp;#123;
            return (T) head.data;
        &amp;#125;
    &amp;#125;
    /*查看队列中所有元素*/
    public void showQueue()&amp;#123;
        Node head =this.head;//引用head便于进行遍历
        while (head.next!=null)&amp;#123;
            System.out.println(head.data);
            head=head.next;
        &amp;#125;
        System.out.println(head.data);

    &amp;#125;
    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &amp;#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &amp;#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&amp;#123;
        private ListQueue2.Node current = head;//指向首结点
        public boolean hasNext() &amp;#123;
            return current != null;
        &amp;#125;

        public void remove() &amp;#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &amp;#125;

        public T next() &amp;#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;//存储当前结点中的值
            current = current.next;//更新指针，指向下一个结点
            return item;//返回当前结点中的值
        &amp;#125;

    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;ListQueue&amp;#123;&quot; +
                &quot;length=&quot; + length +
                &quot;, head=&quot; + head +
                &quot;, tail=&quot; + tail +
                &#39;&amp;#125;&#39;;
    &amp;#125;

    /*测试*/
    public static void main(String[] args) throws Exception &amp;#123;
        var a = new ListQueue2&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &amp;#123;//添加元素
            a.addHead(i);
            a.removeTail();
        &amp;#125;a.removeTail();
        for (int i: a) &amp;#123;
            System.out.println(i);

        &amp;#125;
      //覆盖toString只为了更直观的查看队列
        System.out.println(a+&quot;&quot;);
    &amp;#125;
&amp;#125;

</code></pre>
<p>###带头结点</p>
<pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue3&lt;T&gt;implements Iterable&lt;T&gt;&amp;#123;
    /**双向队列带头结点的
     * 引入一个头结点nil， 初始化时nil的prev和next分别指向自身。用于判断队列是否为空
     * 加入新元素以后只需要操作新增节点，nil 和 nil的下一个节点。
     */
    private int length;
    private Node headNode;


    /*节点类*/
    private class Node&lt;T&gt;&amp;#123;
        private T data;
        private Node next;
        private Node prev;
        //使用了默认结点构造器

        @Override
        public String toString() &amp;#123;
            return &quot;Node&amp;#123;&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &quot;, prev=&quot; + prev +
                    &#39;&amp;#125;&#39;;
        &amp;#125;
    &amp;#125;
    public ListQueue3()&amp;#123;
        headNode = new Node();
        headNode.next = headNode;
        headNode.prev = headNode;
    &amp;#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&amp;#123;
//        return length==0;也可以哦
        return headNode.next == headNode;
    &amp;#125;
    /*队头添加元素
    * 添加的所有元素都将位于头结点之后*/
    private void addHead(T x)&amp;#123;
            Node newNode = new Node();//创建新结点
            newNode.data=x;
            //以下操作顺序不能颠倒
            //先将新结点的前驱为头结点，后继为头结点的原后继
            newNode.prev=headNode;
            newNode.next=headNode.next;
            //再将头结点的原后继的前驱、改为新结点
            headNode.next.prev=newNode;
            headNode.next=newNode;//最后将头结点的后继为新结点

            length++;//队列长度+1

    &amp;#125;
    /*队尾添加元素
    * 添加的所有元素都将位于头结点之前*/
    private void addTail(T x)&amp;#123;
        Node newNode = new Node();//创建新结点
        newNode.data=x;
        newNode.next=headNode;//新结点的后继为头结点
        //以下操作顺序不能颠倒
        newNode.prev=headNode.prev;//现将新结点的前驱为头结点的前驱
        headNode.prev.next=newNode;//再将头结点前驱的后继为新结点
        headNode.prev=newNode;//最后将头结点前驱改为新结点
        length++;//队列长度+1

    &amp;#125;

    /*队头删除元素*/
    public T removeHead()&amp;#123;
        if (isEmpty())
            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);
        Node del = headNode.next;//指向将要删除的结点
        T retunValue = (T) del.data;
        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点
        del.next.prev = headNode;
        headNode.next = del.next;
        length--;
        return retunValue;
    &amp;#125;
    /*队尾删除元素*/
    public T removeTail()&amp;#123;
        if (isEmpty())
            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);
        Node del = headNode.prev;//指向将要删除的结点
        T retunValue = (T) del.data;
        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点
        del.prev.next=headNode;
        headNode.prev=del.prev;
        length--;
        return retunValue;
    &amp;#125;
    /*清空队列*/
    public void makeEmpty()&amp;#123;
        headNode.next=null;
        length=0;
    &amp;#125;

    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &amp;#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &amp;#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&amp;#123;
        private ListQueue3.Node current = headNode.next;//指向头结点
        public boolean hasNext() &amp;#123;
            return current != headNode;
        &amp;#125;

        public void remove() &amp;#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &amp;#125;

        public T next() &amp;#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;//存储当前结点中的值
            current = current.next;//更新指针，指向下一个结点
            return item;//返回当前结点中的值
        &amp;#125;

    &amp;#125;





    /*测试*/
    public static void main(String[] args) throws Exception &amp;#123;
        var a = new ListQueue3&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &amp;#123;
            a.addTail(i);
        &amp;#125;a.removeHead();
        for (int i: a) &amp;#123;
            System.out.println(i);

        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树结点类：</p>
<pre><code>package cn.three.cloth.Tree;
/**
 * 二叉树结点类*/
public class Node&lt;T&gt;&amp;#123;
    private int no;
    private T element;
    private Node left;
    private Node right;

    public Node(int no, T element) &amp;#123;
        this.no = no;
        this.element = element;
    &amp;#125;

    public int getNo() &amp;#123;
        return no;
    &amp;#125;

    public T getElement() &amp;#123;
        return element;
    &amp;#125;

    public Node getLeft() &amp;#123;
        return left;
    &amp;#125;

    public Node getRight() &amp;#123;
        return right;
    &amp;#125;

    public void setNo(int no) &amp;#123;
        this.no = no;
    &amp;#125;

    public void setElement(T element) &amp;#123;
        this.element = element;
    &amp;#125;

    public void setLeft(Node left) &amp;#123;
        this.left = left;
    &amp;#125;

    public void setRight(Node right) &amp;#123;
        this.right = right;
    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;Node&amp;#123;&quot; +
                &quot;no=&quot; + no +
                &quot;, element=&quot; + element +&quot;&amp;#125;&quot;;
    &amp;#125;

    /*前、中、后序遍历开始*/
    //前序遍历
    public void preOrder()&amp;#123;
        System.out.println(this);
        if (this.left != null)&amp;#123;
            this.left.preOrder();
        &amp;#125;
        if (this.right != null)&amp;#123;
            this.right.preOrder();
        &amp;#125;
    &amp;#125;
    //中序遍历
    public void infixOrder()&amp;#123;
        if (this.left != null)&amp;#123;
            this.left.infixOrder();
        &amp;#125;
        System.out.println(this);
        if (this.right != null)&amp;#123;
            this.right.infixOrder();
        &amp;#125;
    &amp;#125;
    //后序遍历
    public void postOrder()&amp;#123;
        if (this.left != null)&amp;#123;
            this.left.postOrder();
        &amp;#125;
        if (this.right != null)&amp;#123;
            this.right.postOrder();
        &amp;#125;
        System.out.println(this);
    &amp;#125;

    /*前、中、后序查找开始*/
    //前序查找、
    public Node preOrderSearch(int no)&amp;#123;
        if (this.no == no)&amp;#123;
            return this;
        &amp;#125;
        Node resNode = null;
        if (this.left != null)&amp;#123;
            resNode = this.left.preOrderSearch(no);
        &amp;#125;
        if (resNode != null)&amp;#123;
            return resNode;
        &amp;#125;
        if (this.right != null)&amp;#123;
            resNode = this.right.preOrderSearch(no);
        &amp;#125;
        return resNode;
    &amp;#125;
    //中序查找
    public Node infixOrderSearch(int no)&amp;#123;
        Node resNode = null;
        if (this.left != null)&amp;#123;
            resNode = this.left.infixOrderSearch(no);
        &amp;#125;
        if (resNode != null)&amp;#123;
            return resNode;
        &amp;#125;
        if (this.no == no)&amp;#123;
            return this;
        &amp;#125;
        if (this.right != null)&amp;#123;
            resNode = this.right.infixOrderSearch(no);
        &amp;#125;
        return resNode;
    &amp;#125;
    //后序查找
    public Node postOrderSearch(int no)&amp;#123;
        Node resNode = null;
        if (this.left != null)&amp;#123;
            resNode = this.left.postOrderSearch(no);
        &amp;#125;
        if (resNode != null)&amp;#123;
            return resNode;
        &amp;#125;
        if (this.right != null)&amp;#123;
            resNode = this.right.postOrderSearch(no);
        &amp;#125;
        if (this.no == no)&amp;#123;
            return this;
        &amp;#125;
        return resNode;
    &amp;#125;
    /*删除结点*/
    public void delNode(int no)&amp;#123;
        //判断当前结点的左、右结点是否为要删除结点
        if (this.left !=null &amp;&amp; this.left.no == no)&amp;#123;
            this.left = null;
            return;
        &amp;#125;
        if (this.right !=null &amp;&amp; this.right.no == no)&amp;#123;
            this.right = null;
            return;
        &amp;#125;
        //··左、右递归删除
        if (this.left != null)&amp;#123;
            this.left.delNode(no);
        &amp;#125;;
        if (this.right != null)&amp;#123;
            this.right.delNode(no);
        &amp;#125;;


    &amp;#125;

&amp;#125;</code></pre>
<p>二叉树：</p>
<pre><code class="java">
package cn.three.cloth.Tree;
/**
 * 二叉树*/
public class BinaryTree1 &amp;#123;
    private Node root;

    public void setRoot(Node root) &amp;#123;
        this.root = root;
    &amp;#125;
/*前、中、后序遍历*/
    public void preOrder()&amp;#123;
        if (this.root != null)&amp;#123;
            this.root.preOrder();
        &amp;#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &amp;#125;

    public void infixOrder()&amp;#123;
        if (this.root != null)&amp;#123;
            this.root.infixOrder();
        &amp;#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &amp;#125;

    public void postOrder()&amp;#123;
        if (this.root != null)&amp;#123;
            this.root.postOrder();
        &amp;#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &amp;#125;
    /*前、中、后序遍历*/
    public Node preOrderSearch(int no)&amp;#123;
        if (root != null)&amp;#123;
            return root.preOrderSearch(no);
        &amp;#125;else &amp;#123;
            return null;
        &amp;#125;
    &amp;#125;
    public Node infixOrderSearch(int no)&amp;#123;
        if (root != null)&amp;#123;
            return root.infixOrderSearch(no);
        &amp;#125;else &amp;#123;
            return null;
        &amp;#125;
    &amp;#125;
    public Node postOrderSearch(int no)&amp;#123;
        if (root != null)&amp;#123;
            return root.postOrderSearch(no);
        &amp;#125;else &amp;#123;
            return null;
        &amp;#125;
    &amp;#125;
    public void delNode(int no)&amp;#123;
        if (root != null)&amp;#123;//该树不为空树
            if (root.getNo() == no)&amp;#123;//该树根结点是否为目标结点
                root = null;
            &amp;#125;else &amp;#123;
                root.delNode(no);//递归删除（Node类中的）以此结点为根结点。沿着左结点遍历查询删除，如未找到则再沿着根结点的右结点遍历查询
            &amp;#125;
        &amp;#125;else &amp;#123;
            System.out.println(&quot;该树为空！&quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组<img src="https://i.loli.net/2020/09/13/qRFTifeoytCw1c6.png"></h1><pre><code class="java">
public class SparseArray &amp;#123;

    public static void main(String[] args) &amp;#123;
        // 创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;
        // 输出原始的二维数组
        System.out.println(&quot;原始的二维数组~~&quot;);
        for (int[] row : chessArr1) &amp;#123;
            for (int data : row) &amp;#123;
                System.out.printf(&quot;%d\t&quot;, data);
            &amp;#125;
            System.out.println();
        &amp;#125;

        // 将二维数组 转 稀疏数组的思
        // 1. 先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int i = 0; i &lt; 11; i++) &amp;#123;
            for (int j = 0; j &lt; 11; j++) &amp;#123;
                if (chessArr1[i][j] != 0) &amp;#123;
                    sum++;
                &amp;#125;
            &amp;#125;
        &amp;#125;

        // 2. 根据非0数据个数再加一（记录总行、列、有效值个数）创建对应的稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        // 遍历二维数组，将非0的值存放到 sparseArr中
        int count = 0; //count 用于记录是第几个非0数据
        for (int i = 0; i &lt; 11; i++) &amp;#123;
            for (int j = 0; j &lt; 11; j++) &amp;#123;
                if (chessArr1[i][j] != 0) &amp;#123;
                    count++;
                    sparseArr[count][0] = i;//行
                    sparseArr[count][1] = j;//列
                    sparseArr[count][2] = chessArr1[i][j];//值
                &amp;#125;
            &amp;#125;
        &amp;#125;

        // 输出稀疏数组的形式
        System.out.println();
        System.out.println(&quot;得到稀疏数组为~~~~&quot;);
        for (int i = 0; i &lt; sparseArr.length; i++) &amp;#123;
            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        &amp;#125;
        System.out.println();

        //将稀疏数组 --》 恢复成 原始的二维数组
        /*
         *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]
            2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
         */

        //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组

        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];

        //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可

        for(int i = 1; i &lt; sparseArr.length; i++) &amp;#123;
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        &amp;#125;

        // 输出恢复后的二维数组
        System.out.println();
        System.out.println(&quot;恢复后的二维数组&quot;);

        for (int[] row : chessArr2) &amp;#123;
            for (int data : row) &amp;#123;
                System.out.printf(&quot;%d\t&quot;, data);
            &amp;#125;
            System.out.println();
        &amp;#125;
    &amp;#125;

&amp;#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#6484be>
                Java
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-Stack-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/javadm-04/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试时，程序运行的成功与否并不依靠返回值、打印语句来判断;通常我们使用断言而非print来展示返回值</p>
<pre><code class="java">Assert.assertEquals(-1,value)//预测变量value的值为-1
assert i &lt; 50:i;//断言i的值小于50（如i大于等于50将发生异常并返回实际i的值）</code></pre>
<p>idea中运行结果为绿色就是运行成功，红色则失败。</p>
<p><code>@Before</code>在测试方法前自动执行，通常用来申请资源</p>
<p><code>@After</code>在测试方法后自动执行，通常用来释放资源</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote>
<pre><code class="java">import java.lang.annotation.*;
//元注解：对注解进行注解
@Target(ElementType.TYPE)//该注解可以被写在什么位置，取值如：类、方法、字段、包等
@Retention(RetentionPolicy.RUNTIME)//表明注解保留的时间段如：运行时即存入字节码并为JVM所接收、仅保留到字节码、保留到编译时（前）
@Documented//注解可以被抽取到javadoc文档中
@Inherited//该注解是否可以被继承

public @interface MyAnnotation &amp;#123;
    String value();
    int a();

&amp;#125;

@MyAnnotation(value = &quot;value&quot;,a=0)
public class MyAnnotationTest &amp;#123;
&amp;#125;</code></pre>
<p> 用于描述注解的注解</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2020/10/16/javadm-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Javadm-03/">
        <h2>
            代理模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>只要代理对象以某种方式代表具体实现的方法调用，那么基本思想就算实现了。而，拥有一个公共接口是很方便的，因此具体实现必须实现代理对象调用的所有方法。</p>
<pre><code class="java">// patterns/ProxyDemo.java
// Simple demonstration of the Proxy pattern
interface ProxyBase &amp;#123;
    void f();

    void g();

    void h();
&amp;#125;

class Proxy implements ProxyBase &amp;#123;
    private ProxyBase implementation;//这是一个私有字段

    Proxy() &amp;#123;
        implementation = new Implementation();//创建所代理类（Implementation）的对象
    &amp;#125;
    /*覆盖方法并调用所代理类（Implementation）的方法*/
    @Override
    public void f() &amp;#123; implementation.f(); &amp;#125;
    @Override
    public void g() &amp;#123; implementation.g(); &amp;#125;
    @Override
    public void h() &amp;#123; implementation.h(); &amp;#125;
&amp;#125;

class Implementation implements ProxyBase &amp;#123;
    /*与代理类实现同一个接口,必须实现（覆盖）接口中所有方法哦/
    @Override
    public void f() &amp;#123;
        System.out.println(&quot;Implementation.f()&quot;);
    &amp;#125;
    @Override
    public void g() &amp;#123;
        System.out.println(&quot;Implementation.g()&quot;);
    &amp;#125;
    @Override
    public void h() &amp;#123;
        System.out.println(&quot;Implementation.h()&quot;);
    &amp;#125;
&amp;#125;

public class ProxyDemo &amp;#123;
    public static void main(String[] args) &amp;#123;
        Proxy p = new Proxy();
        p.f();
        p.g();
        p.h();
    &amp;#125;
&amp;#125;
/*
Output:
Implementation.f()
Implementation.g()
Implementation.h()
*/
/*总结：
1.代理模式中通常代理类与被代理类实现一个公共接口利于交流。
2.在创建代理类对象的时，被代理类的对象也将同时创建（因为new被代理类写在代理类的构造器中）并为代理类的一个私有变量引用
3. so，想要调用被代理类的方法只需使用代理类 私有变量.被代理类的方法 （即在代理类中使用方法调用被代理类的方法）*/</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java设计模式" style=color:#016a99>
                Java设计模式
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Javadm-03/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/3/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/2">
                <span class="page-num">
                    2
                </span>
            </a>
            

            
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
        </span>
        

        <span class="current">
            4
        </span>

        
        <span>
            <a href="/page/5/">
                <span class="page-num">
                    5
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/5/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>