
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/20/Java-04/">
        <h2>
            流的创建与基础操作
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说;</p>
<p>利用流，我们无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道;</p>
<p>流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体;</p>
</blockquote>
<p>流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）;</p>
<p>在接口中添加被 <code>default</code>（<code>默认</code>）修饰的方法，即可将流式（<em>stream</em>）方法平滑地嵌入到现有类中。</p>
<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h4 id="ints"><a href="#ints" class="headerlink" title=".ints( )"></a>.ints( )</h4><ul>
<li>生成整数流，可设定边界</li>
<li>如设定边界为ints（5，20）则生成5（包括）-20（不包括）之间的数</li>
</ul>
<h4 id="limit"><a href="#limit" class="headerlink" title=".limit()"></a>.limit()</h4><ul>
<li>截断并获取流中元素</li>
<li>如填入7，则获取前7个元素</li>
</ul>
<pre><code class="java">// streams/Randoms.java
import java.util.*;
public class Randoms &#123;
    public static void main(String[] args) &#123;
        new Random(47)
            .ints(5, 20)//生成整数流，设定边界如5-20（不包括20）
            .distinct()//收集不重复的
            .limit(7)//截断，获取7个元素
            .sorted()//排序
            .forEach(System.out::println);
    &#125;
&#125;
</code></pre>
<h1 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h1><h2 id="Stream-of"><a href="#Stream-of" class="headerlink" title="Stream.of()"></a>Stream.of()</h2><p>将一组元素转化成为流</p>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream()"></a>stream()</h2><p>集合可通过调用此方法产生一个流</p>
<h2 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet()"></a>entrySet()</h2><ul>
<li>产生一个对象流，每个对象都包含一个 <code>key</code> 键以及与其相关联的 <code>value</code> 值。 </li>
<li>可使用getKey()和getValue() 获取对象流的键值</li>
</ul>
<pre><code class="java">// streams/CollectionToStream.java
import java.util.*;
import java.util.stream.*;
public class CollectionToStream &#123;
    public static void main(String[] args) &#123;
        List&lt;Bubble&gt; bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
        System.out.println(bubbles.stream()
            .mapToInt(b -&gt; b.i)
            .sum());

        Set&lt;String&gt; w = new HashSet&lt;&gt;(Arrays.asList(&quot;It&#39;s a wonderful day for pie!&quot;.split(&quot; &quot;)));
        w.stream()
         .map(x -&gt; x + &quot; &quot;)
         .forEach(System.out::print);
        System.out.println();

        Map&lt;String, Double&gt; m = new HashMap&lt;&gt;();
        m.put(&quot;pi&quot;, 3.14159);
        m.put(&quot;e&quot;, 2.718);
        m.put(&quot;phi&quot;, 1.618);
        m.entrySet().stream()//entrySet() 产生一个对象流，每个对象都包含一个 `key` 键以及与其相关联的 `value` 值。 。
                    .map(e -&gt; e.getKey() + &quot;: &quot; + e.getValue())//getKey()和getValue() 获取键值
            //中间操作 `map()` 会获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。
                    .forEach(System.out::println);
    &#125;
&#125;
</code></pre>
<h2 id="boxed"><a href="#boxed" class="headerlink" title="boxed()"></a>boxed()</h2><ul>
<li>把基本类型包装成为对应的装箱类型</li>
</ul>
<pre><code class="java">public class RandomGenerators &#123;
    public static &lt;T&gt; void show(Stream&lt;T&gt; stream) &#123;
        stream
        .limit(4)
        .forEach(System.out::println);
    &#125;

    public static void main(String[] args) &#123;
        Random rand = new Random(47);
        show(rand.ints().boxed());//boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 show() 能够接受流
        show(rand.longs().boxed());
    &#125;
&#125;
</code></pre>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h2><p>收集操作，它根据参数来组合所有流中的元素。</p>
<h2 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining()"></a>Collectors.joining()</h2><p>每个元素都根据 <code>joining()</code> 的参数来进行分割。</p>
<p>得到一个 <code>String</code> 类型的结果</p>
<h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate()"></a>Stream.generate()</h2><ul>
<li>把任意  <code>Supplier&lt;T&gt;</code> 用于生成 <code>T</code> 类型的流。</li>
</ul>
<pre><code class="java">// streams/RandomWords.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
import java.io.*;
import java.nio.file.*;
public class RandomWords implements Supplier&lt;String&gt; &#123;
    List&lt;String&gt; words = new ArrayList&lt;&gt;();
    Random rand = new Random(47);
    RandomWords(String fname) throws IOException &#123;
        List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname));
        // 略过第一行
        for (String line : lines.subList(1, lines.size())) &#123;
            for (String word : line.split(&quot;[ .?,]+&quot;))
                words.add(word.toLowerCase());
        &#125;
    &#125;
    public String get() &#123;
        return words.get(rand.nextInt(words.size()));
    &#125;
    @Override
    public String toString() &#123;
        return words.stream()
            .collect(Collectors.joining(&quot; &quot;));
    &#125;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(
            Stream.generate(new RandomWords(&quot;Cheese.dat&quot;))
                .limit(10)
                .collect(Collectors.joining(&quot; &quot;)));//以空格分隔流元素并收集
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.test.day15;

// streams/Generator.java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Generator implements Supplier&lt;String&gt; &#123;
    Random rand = new Random(47);
    char[] letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();

    public String get() &#123;
        return &quot;&quot; + letters[rand.nextInt(letters.length)];
    &#125;

    public static void main(String[] args) &#123;
        String word = Stream.generate(new Generator())
                ////Stream.generate() 的用法，它可以把任意 Supplier&lt;T&gt; 用于生成 T 类型的流。
                .limit(30)//获取前30个
                .collect(Collectors.joining(&quot; &quot;));//collect() 收集操作，它根据参数来组合所有流中的元素。
        //使用 Collectors.joining()，你将会得到一个 String 类型的结果，
        // 每个元素都根据 joining() 的参数来进行分割。

        System.out.println(word);
    &#125;
&#125;
</code></pre>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h2><p>将元素装入数组</p>
<h2 id="Arrays的stream"><a href="#Arrays的stream" class="headerlink" title="Arrays的stream()"></a>Arrays的stream()</h2><p>把数组转换成为流;</p>
<p>（）中可加入两个额外的参数。第一个参数告诉 <code>stream()</code> 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止。</p>
<h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate()"></a>Stream.iterate()</h2><p>以种子（第一个参数）开头，并将其传给方法（第二个参数）；</p>
<p>方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code>。</p>
<h2 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h2><ul>
<li>根据参数丢弃指定数量的流元素。</li>
</ul>
<pre><code class="java">package com.test.day15;

// streams/Fibonacci.java
import java.util.stream.*;
public class Fibonacci &#123;
    int x = 1;

    Stream&lt;Integer&gt; numbers() &#123;
        return Stream.iterate(0, i -&gt; &#123;//terate() 以种子（第一个参数）开头，并将其传给方法（第二个参数）。
            // iterate() 只能记忆结果，因此我们需要利用一个变量 x 追踪另外一个元素。
            int result = x + i;
            x = i;
            return result;//返回值赋予i
        &#125;);
    &#125;

    public static void main(String[] args) &#123;
        new Fibonacci().numbers()
                .skip(20) // 过滤前 20 个
                .limit(10) // 然后取 10 个
                .forEach(System.out::println);
    &#125;
&#125;
</code></pre>
<h1 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h1><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。</p>
<h2 id="mapToInt-ToIntFunction"><a href="#mapToInt-ToIntFunction" class="headerlink" title="mapToInt(ToIntFunction)"></a>mapToInt(ToIntFunction)</h2><p>操作同上，但结果是 <strong>IntStream</strong>;</p>
<p>mapToLong(ToLongFunction)</p>
<p>操作同上，但结果是 <strong>LongStream</strong>;</p>
<p>mapToDouble(ToDoubleFunction)</p>
<p>操作同上，但结果是 <strong>DoubleStream</strong>。</p>
<pre><code class="java">package com.test.day15;

// streams/FunctionMap.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class FunctionMap &#123;
    static String[] elements = &#123; &quot;12&quot;, &quot;&quot;, &quot;23&quot;, &quot;45&quot; &#125;;
    static Stream&lt;String&gt;
    testStream() &#123;
        return Arrays.stream(elements);//把数组转换成为流并返回
    &#125;
    static void test(String descr, Function&lt;String, String&gt; func) &#123;
        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
        testStream()
                .map(func)//将函数操作应用在输入流的元素中，并将返回值传递到输出流中。
                .forEach(System.out::println);
    &#125;
    public static void main(String[] args) &#123;
        test(&quot;add brackets&quot;, s -&gt; &quot;[&quot; + s + &quot;]&quot;);
        test(&quot;Increment&quot;, s -&gt; &#123;
                    try &#123;
//                        return s + 1;//错误的拼接了，流中一切元素为字符
                        return Integer.parseInt(s) + 1 + &quot;&quot;;//将字符串参数作为有符号的十进制整数进行解析并还原为字符串
                    &#125;
                    catch(NumberFormatException e) &#123;
                        return s;
                    &#125;
                &#125;
        );
        test(&quot;Replace&quot;, s -&gt; s.replace(&quot;2&quot;, &quot;9&quot;));
        //返回一个新的字符串，将所有字符”2“替换成”9“
        test(&quot;Take last digit&quot;, s -&gt; s.length() &gt; 0 ?
                s.charAt(s.length() - 1) + &quot;&quot; : s);//charAt返回指定索引处的 char 值。
    &#125;
&#125;
</code></pre>
<h2 id="流中元素基本类型的转换"><a href="#流中元素基本类型的转换" class="headerlink" title="流中元素基本类型的转换"></a>流中元素基本类型的转换</h2><pre><code class="java">package com.test.day15;

// streams/FunctionMap3.java
// Producing numeric output streams（ 产生数值输出流）
import java.util.*;
import java.util.stream.*;
class FunctionMap3 &#123;

    public static void main(String[] args) &#123;
        Stream.of(&quot;5&quot;, &quot;7&quot;, &quot;9&quot;)
                .mapToInt(Integer::parseInt)//int类型
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        Stream.of(&quot;17&quot;, &quot;19&quot;, &quot;23&quot;)
                .mapToLong(Long::parseLong)//long类型
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        Stream.of(&quot;17&quot;, &quot;1.9&quot;, &quot;.23&quot;)
                .mapToDouble(Double::parseDouble)//double类型
                .forEach(n -&gt; System.out.format(&quot;%f &quot;, n));
    &#125;
&#125;
</code></pre>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><ul>
<li><p>获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中（与 <code>map()</code> 所做的相同）</p>
</li>
<li><p>每个结果都是一个流，将其扁平化为单个元素并拼接到一起</p>
</li>
<li><p>可用来组合流中的方法（实现方式是将元素扁平化再实现流）例：</p>
</li>
</ul>
<pre><code class="java">Stream&lt;String&gt; a = words.stream().flatMap(w -&gt; codePoints(w));
</code></pre>
<ul>
<li><p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p>
</li>
<li><p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p>
</li>
<li><p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p>
</li>
<li><p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p>
</li>
</ul>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li>以参数顺序组合两个流。 </li>
</ul>
<pre><code class="java">package com.test.day15;

import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;
/*一个整数流开始，然后使用每一个整数去创建更多的随机数。*/
public class StreamOfRandoms &#123;
    static Random rand = new Random(47);
    //一个种子为47的随机数生成，多个相同种子的随机生成实例，生成的结果一致

    public static void main(String[] args) &#123;
        Stream.of(1,2,3,4,5)
        .flatMapToInt(i -&gt; IntStream.concat(
            //concat()，以参数顺序组合两个流，我们在每个随机 `Integer` 流的末尾添加一个 -1 作为标记
                rand.ints(0,100).limit(i)//根据i的值返回i个元素
                ,
                //生成随机数，仅返回0（包含）-100（不包含）之间的数
                IntStream.of(-1)//生成一个整数流包含-1
                )).forEach(n -&gt; System.out.format(&quot;%d\n&quot;,n));
    &#125;
&#125;
</code></pre>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h3><p>帮助调试。可无修改地查看流中的元素。</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>收集流中不重复的元素</p>
<h3 id="空流-Stream-empty"><a href="#空流-Stream-empty" class="headerlink" title="空流 Stream.empty()"></a>空流 Stream.empty()</h3><ul>
<li><p>如果你在没有任何上下文环境的情况下调用 Stream.empty()，Java 并不知道它的数据类型；</p>
</li>
<li><p>解决这个问题:1、2均可</p>
<pre><code class="java">1. Stream.&lt;String&gt;empty()//限定类型为String
    2.    Stream&lt;String&gt; s = Stream.empty();
</code></pre>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-05/">
        <h2>
            Optional类
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>用于，查看的流中元素返回提示而不是发生异常。</p>
</blockquote>
<p><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong>;</p>
<p><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty;</strong></p>
<p><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong>;</p>
<p><code>reduce()</code> 不再以 <code>identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code>identity</code> 对象成为其他形式的 <code>reduce()</code> 的默认结果，因此不存在空结果的风险）;</p>
<p>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code>average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</p>
<h1 id="解包-Optional"><a href="#解包-Optional" class="headerlink" title="解包 Optional"></a>解包 <strong>Optional</strong></h1><ul>
<li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li>
<li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>（括号中可定义）。</li>
<li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li>
<li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li>
</ul>
<h1 id="创建-Optional"><a href="#创建-Optional" class="headerlink" title="创建 Optional"></a>创建 Optional</h1><ul>
<li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li>
<li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li>
<li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li>
</ul>
<pre><code class="java">package com.test.day15;

import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class CreatingOptionals &#123;
    static void test(String testName, Optional&lt;String&gt; opt) &#123;
        System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
        System.out.println(opt.orElse(&quot;Null&quot;));//定义若不存在值则生成otherObject为null，并打印；若有值返回并打印值。
    &#125;

    public static void main(String[] args) &#123;
        test(&quot;empty&quot;, Optional.empty());////empty()：生成一个空 Optional。
        test(&quot;of&quot;, Optional.of(&quot;Howdy&quot;));//of(value)：将一个非空值包装到 Optional 里。
        try &#123;
            test(&quot;of&quot;, Optional.of(null));
        &#125; catch(Exception e) &#123;
            System.out.println(e);
        &#125;
        test(&quot;ofNullable&quot;, Optional.ofNullable(&quot;Hi&quot;));
        //ofNullable(value)：针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中

        test(&quot;ofNullable&quot;, Optional.ofNullable(null));
    &#125;
&#125;
</code></pre>
<h1 id="Optional-对象操作"><a href="#Optional-对象操作" class="headerlink" title="Optional 对象操作"></a>Optional 对象操作</h1><ul>
<li><p><code>filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。而流的 <code>filter()</code> 则会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。</p>
</li>
<li><p><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong>  于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。（与中间操作map类似）</p>
</li>
<li><p><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。（与中间操作flatmap类似）<code>Optional.flatMap()</code> 是为那些自己已经生成 <strong>Optional</strong> 的函数而设计的。可用来组合流中的方法（实现方式是将元素扁平化再实现流）例：</p>
<pre><code class="java">Optional&lt;Double&gt; a=Optional.of(-4.0).flatMap(Demo:invers).flatMap(Demo:squareRoot)
</code></pre>
</li>
</ul>
<p>以上方法都不适用于数值型 <strong>Optional</strong>。</p>
<pre><code class="java">// streams/OptionalFilter.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class OptionalFilter &#123;
    static String[] elements = &#123;
            &quot;Foo&quot;, &quot;&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Bingo&quot;
    &#125;;
    static Stream&lt;String&gt; testStream() &#123;
        return Arrays.stream(elements);
    &#125;
    static void test(String descr, Predicate&lt;String&gt; pred) &#123;
        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
        for(int i = 0; i &lt;= elements.length; i++) &#123;/
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst()
                            .filter(pred));
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        test(&quot;true&quot;, str -&gt; true);//返回所有元素包括空
        test(&quot;false&quot;, str -&gt; false);//返回空（Optional.empty）
        test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);
        test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);
        test(&quot;startsWith(\&quot;B\&quot;)&quot;,
                str -&gt; str.startsWith(&quot;B&quot;));
    &#125;
&#125;
</code></pre>
<h1 id="Optional-流"><a href="#Optional-流" class="headerlink" title="Optional 流"></a>Optional 流</h1><pre><code class="java">package com.test.day16;

// streams/Signal.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
public class Signal &#123;
    private final String msg;
    public Signal(String msg) &#123; this.msg = msg; &#125;
    public String getMsg() &#123; return msg; &#125;
    @Override
    public String toString() &#123;
        return &quot;Signal(&quot; + msg + &quot;)&quot;;
    &#125;
    static Random rand = new Random(47);//随机数
    public static Signal morse() &#123;
        switch(rand.nextInt(4)) &#123;//nextInt(4)，返回0-4之间的数
            case 1: return new Signal(&quot;dot&quot;);
            case 2: return new Signal(&quot;dash&quot;);
            default: return null;
        &#125;
    &#125;
    public static Stream&lt;Optional&lt;Signal&gt;&gt; stream() &#123;
        return Stream.generate(Signal::morse)//通过所提供的产生的每个元件的无限连续的无序流Supplier
                .map(signal -&gt; Optional.ofNullable(signal));//为空返回Optional.empty，不为空将值包包装在 Optional 中。
    &#125;
&#125;


package com.test.day16;

// streams/StreamOfOptionals.java
import java.util.*;
import java.util.stream.*;
public class StreamOfOptionals &#123;
    public static void main(String[] args) &#123;
        Signal.stream()
                .limit(10)
                .forEach(System.out::println);
        System.out.println(&quot; ---&quot;);
        Signal.stream()
                .limit(10)
                .filter(Optional::isPresent)//返回非空的元素，isPresent值存在返回true否返回flase
                .map(Optional::get)//从Optional中提取元素
                .forEach(System.out::println);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#006674>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-05/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-06/">
        <h2>
            终端操作(收集)
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>以下操作将会获取流的最终结果。至此我们无法再继续往后传递流。</p>
<p>终端操作（Terminal Operations）总是我们在流管道中所做的最后一件事。</p>
</blockquote>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li><code>toArray()</code>：将流转换成适当类型的数组。</li>
<li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组。</li>
</ul>
<pre><code class="java">// streams/RandInts.java
package streams;
import java.util.*;
import java.util.stream.*;
public class RandInts &#123;
    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
    public static IntStream rands() &#123;
        return Arrays.stream(rints);
    &#125;
&#125;
</code></pre>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><ul>
<li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li>
<li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。]</li>
<li><code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。</li>
</ul>
<pre><code class="java">package com.test.day16;

// streams/ForEach.java
import java.util.*;
import java.util.stream.*;

public class ForEach &#123;
    static final int SZ = 14;
    public static void main(String[] args) &#123;
        RandInts.rands().limit(SZ)//截取14个
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        RandInts.rands().limit(SZ)
                .parallel()
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
         /*在第一个流中，未使用 parallel() ，所以 rands() 按照元素迭代出现的顺序显示结果；
        在第二个流中，引入parallel() ，即便流很小，输出的结果顺序也和前面不一样。这是由于多处理器并行操作的原因。
        多次运行测试，结果均不同。多处理器并行操作带来的非确定性因素造成了这样的结果。*/
        System.out.println();
        RandInts.rands().limit(SZ)
                .parallel()//parallel()：实现多处理器并行操作。
                // 实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。
                .forEachOrdered(n -&gt; System.out.format(&quot;%d &quot;, n));//强制保持原始流顺序

    &#125;
&#125;

package com.test.day16;

// streams/RandInts.java
import java.util.*;
import java.util.stream.*;
public class RandInts &#123;
    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
    public static IntStream rands() &#123;
        return Arrays.stream(rints);//返回此数组流
    &#125;
&#125;
</code></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li>
<li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</li>
<li><strong>Collectors</strong> 里面没有特定的 <code>toTreeSet()</code>，但是我们可以通过将集合的构造函数引用传递给 <code>Collectors.toCollection()</code>，从而构建任何类型的集合。<strong>如下</strong>：</li>
</ul>
<pre><code class="java">// streams/TreeSetOfWords.java
import java.util.*;
import java.nio.file.*;
import java.util.stream.*;
public class TreeSetOfWords &#123;
    public static void
    main(String[] args) throws Exception &#123;
        Set&lt;String&gt; words2 =
                Files.lines(Paths.get(&quot;TreeSetOfWords.java&quot;))//Paths.get读取全文，Files.lines打开 Path 并将其转换成为行流。
                        .flatMap(s -&gt; Arrays.stream(s.split(&quot;\\W+&quot;)))// Arrays.stream() 将其转化成为流；并将结果展平映射成为单词流。
                        .filter(s -&gt; !s.matches(&quot;\\d+&quot;)) // No numbersmatches(\\d+) 查找并移除全数字字符串
                        .map(String::trim)//String.trim() 去除单词两边的空白，
                        .filter(s -&gt; s.length() &gt; 2) filter() //过滤所有长度小于3的单词，，最后将
                        .limit(100)//获取100个单词
                        .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(words2);//将元素收集至Tree集合构造器
    &#125;
&#125;

//1.将数据收集进一个列表(Stream 转换为 List，允许重复值，有顺序)
//创建流
Stream&lt;String&gt; language = Stream.of(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);
List&lt;String&gt; listResult = language.collect(Collectors.toList());
result.forEach(System.out::println);
//2.将数据收集进一个集合(Stream 转换为 Set，不允许重复值，没有顺序)
Stream&lt;String&gt; language = Stream.of(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);
Set&lt;String&gt; setResult = language.collect(Collectors.toSet());
setResult.forEach(System.out::println);
      List&lt;String&gt; list = Arrays.asList(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);  
      
</code></pre>
<h2 id="自定义收集"><a href="#自定义收集" class="headerlink" title="自定义收集"></a>自定义收集</h2><pre><code class="java">//用LinkedList收集
      List&lt;String&gt; linkedListResult = list.stream().collect(Collectors.toCollection(LinkedList::new));
      linkedListResult.forEach(System.out::println);
      System.out.println(&quot;--------------&quot;);
      
      //用CopyOnWriteArrayList收集
      List&lt;String&gt; copyOnWriteArrayListResult = list.stream().collect(Collectors.toCollection(CopyOnWriteArrayList::new));
      copyOnWriteArrayListResult.forEach(System.out::println);
      System.out.println(&quot;--------------&quot;);
      
      //用TreeSet收集
      TreeSet&lt;String&gt; treeSetResult = list.stream().collect(Collectors.toCollection(TreeSet::new));
      treeSetResult.forEach(System.out::println);
</code></pre>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><ul>
<li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li>
<li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li>
<li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li>
</ul>
<pre><code class="java">package com.test.day16;

// streams/Reduce.java
import java.util.*;
import java.util.stream.*;
class Frobnitz &#123;
    int size;
    Frobnitz(int sz) &#123; size = sz; &#125;
    @Override
    public String toString() &#123;
        return &quot;Frobnitz(&quot; + size + &quot;)&quot;;
    &#125;
    // Generator:
    static Random rand = new Random(47);
    static final int BOUND = 100;
    static Frobnitz supply() &#123;/*个方法对于 Supplier&lt;Frobnitz&gt; 是签名兼容的，
    我们可以将其方法引用传递给 Stream.generate()（这种签名兼容性被称作结构一致性）*/
        return new Frobnitz(rand.nextInt(BOUND));//随机返回0-100之间的数
    &#125;
&#125;
public class Reduce &#123;
    public static void main(String[] args) &#123;
        Stream.generate(Frobnitz::supply)//Stream.iterate和Stream.generate。这两个操作可以创建无限流：不像从固定集合创建的流那样有固定大小的流。
                .limit(10)
                .peek(System.out::println)//peek接收的参数类型为Consumer，而map接收的参数类型为Function
        //println 方法可以被调用是因为 Frobnitz 可以通过 toString() 方法转换成 String
                .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)/*reduce() 中的 Lambda 表达式使用了三元表达式来获取结果，
                当其长度小于 50 的时候获取 fr0 否则获取序列中的下一个值 fr1。当取得第一个长度小于 50 的 Frobnitz，只要得到结果就会忽略其他。*/
                .ifPresent(System.out::println);
    &#125;
&#125;
</code></pre>
<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>count()</code>：流中的元素个数;</p>
<p><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素;</p>
<p><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</p>
<h2 id="数字流信息"><a href="#数字流信息" class="headerlink" title="数字流信息"></a>数字流信息</h2><p><code>average()</code> ：求取流元素平均值;</p>
<p><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>;</p>
<p><code>sum()</code>：对所有流元素进行求和;</p>
<p><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul>
<li><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
<li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
</ul>
<pre><code class="java">package com.test.day16;
// streams/SelectElement.java
import java.util.*;
import java.util.stream.*;

public class SelectElement &#123;
    public static void main(String[] args) &#123;
        System.out.println(RandInts.rands().findFirst().getAsInt());//获取随机流中生成的头一个元素，并返回
        System.out.println(
                RandInts.rands().parallel().findFirst().getAsInt());
        System.out.println(RandInts.rands().findAny().getAsInt());//对于非并行流，findAny()会选择流中的第一个元素（即使从定义上来看是选择任意元素）。
        System.out.println(
                RandInts.rands().parallel().findAny().getAsInt());//parallel()并行化，findAny选择并行化后的第一个元素
    &#125;
&#125;
</code></pre>
<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><ul>
<li><code>allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。</li>
<li><code>anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。</li>
<li><code>noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li>
</ul>
<pre><code class="java">package com.test.day16;

// streams/Matching.java
// Demonstrates short-circuiting of *Match() operations
import java.util.stream.*;
import java.util.function.*;

interface Matcher extends BiPredicate&lt;Stream&lt;Integer&gt;, Predicate&lt;Integer&gt;&gt; &#123;&#125;

public class Matching &#123;
    static void show(Matcher match, int val) &#123;
        System.out.println(
                match.test(
                        IntStream.rangeClosed(1, 9)//生成1-9
                                .boxed()//将流元素装入包装器Integer
                                .peek(n -&gt; System.out.format(&quot;%d &quot;, n)),//返回由该流的元素，作为元素从所得流消耗的每个元件上附加地执行所述提供动作的流。
                        n -&gt; n &lt; val));//执行peek中操作
    &#125;/*    allMatch(Predicate) ：返回flase时停止计算
           anyMatch(Predicate)：在获得true时停止执行，如结尾仍未获得true。返回flase
    noneMatch(Predicate)：如果流的每个元素根据提供的 Predicate 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。*/
    public static void main(String[] args) &#123;
        show(Stream::allMatch, 10);
        show(Stream::allMatch, 4);//第5个值5，大于4，故停止计算（短路时直接结束此操作）
        show(Stream::anyMatch, 3);//在获得true时停止执行
        show(Stream::anyMatch, 0);
        show(Stream::noneMatch, 5);//在第一个 true 时停止执行计算，故返回flase
        show(Stream::noneMatch, 0);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#006674>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-06/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-07/">
        <h2>
            异常
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><img src="http://img.lbkzw.cn/img/20200821102446.png" alt="img"></p>
<ul>
<li><p>RuntimeException(运行时异常)会自动被 java 虚拟机抛出，所以不必在异常说明中把它们列出来,也不需要在异常说明中声明方法将抛出 RuntimeException 类型的异常</p>
</li>
<li><p>RuntimeException 也被称为“不受检查异常”，将被自动捕获,如果 没有被捕获而直达 main()，那么在程序退出前将调用异常的 printStackTrace() 方法。(返回栈轨迹信息)</p>
</li>
<li><p>要么<strong>声明</strong>异常要么<strong>处理</strong>异常(只有在你知道如何处理的情况下才捕获异常)。</p>
<pre><code class="java">package cn.day.a2;

// exceptions/LostMessage.java
// How an exception can be lost
class VeryImportantException extends Exception &#123;
    @Override
    public String toString() &#123;
        return &quot;A very important exception!&quot;;
    &#125;
&#125;
class HoHumException extends Exception &#123;
    @Override
    public String toString() &#123;
        return &quot;A trivial exception&quot;;
    &#125;
&#125;
public class LostMessage &#123;
    void f() throws VeryImportantException &#123;
        throw new VeryImportantException();
    &#125;
    void dispose() throws HoHumException &#123;
        throw new HoHumException();
    &#125;
    /*声明异常，而不做处理（交给调用的人处理）*/
    public static void main(String[] args) throws VeryImportantException &#123;//仅仅声明异常

            LostMessage lm = new LostMessage();
                lm.f();

            &#125;

    &#125;
    /*捕获并处理异常*/
//    public static void main(String[] args)  &#123;
//        try &#123;
//            LostMessage lm = new LostMessage();
//            try &#123;
//                lm.f();
//            &#125; finally &#123;
//                lm.dispose();
//            &#125;
//        &#125; catch(VeryImportantException | HoHumException e) &#123;
//            System.out.println(e);
//        &#125;
//        
//    &#125;
//
//&#125;

</code></pre>
</li>
<li><p>可以通过<strong>继承</strong>异常基类来<strong>自定义异常</strong></p>
<pre><code class="java">class SimpleException extends Exception &#123;&#125;

public class InheritingExceptions &#123;
    public void f() throws SimpleException &#123;
        System.out.println(
                &quot;Throw SimpleException from f()&quot;);
        throw new SimpleException();
    &#125;
    public static void main(String[] args) &#123;
        InheritingExceptions sed =
                new InheritingExceptions();
        try &#123;
            sed.f();
        &#125; catch(SimpleException e) &#123;
            System.out.println(&quot;Caught it!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h1><h2 id="声明多个异常"><a href="#声明多个异常" class="headerlink" title="声明多个异常"></a>声明多个异常</h2><pre><code class="java">void f() throws TooBig, TooSmall, DivZero &#123; // 方法体...&#125;
</code></pre>
<h2 id="声明所有异常"><a href="#声明所有异常" class="headerlink" title="声明所有异常"></a>声明所有异常</h2><pre><code class="java">catch(Exception e) &#123;
    System.out.println(&quot;Caught an exception&quot;);
&#125;
</code></pre>
<h2 id="声明子异常捕获父异常"><a href="#声明子异常捕获父异常" class="headerlink" title="声明子异常捕获父异常"></a>声明子异常捕获父异常</h2><blockquote>
<p>java7之后就可以通过编译了</p>
</blockquote>
<pre><code class="java">class BaseException extends Exception &#123;&#125;
class DerivedException extends BaseException &#123;&#125;

public class PreciseRethrow &#123;
    void catcher() throws DerivedException &#123;//声明子异常
        try &#123;
            throw new DerivedException();
        &#125; catch(BaseException e) &#123;//捕获父异常
            throw e;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><h2 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h2><pre><code class="java">// exceptions/SameHandler.java
class EBase1 extends Exception &#123;&#125;
class Except1 extends EBase1 &#123;&#125;
class EBase2 extends Exception &#123;&#125;
class Except2 extends EBase2 &#123;&#125;
class EBase3 extends Exception &#123;&#125;
class Except3 extends EBase3 &#123;&#125;
class EBase4 extends Exception &#123;&#125;
class Except4 extends EBase4 &#123;&#125;

public class SameHandler &#123;
    void x() throws Except1, Except2, Except3, Except4 &#123;&#125;
    void process() &#123;&#125;
    void f() &#123;
        try &#123;
            x();
            /*以下是分别捕获并处理异常*/
        &#125; catch(Except1 e) &#123;
            process();
        &#125; catch(Except2 e) &#123;
            process();
        &#125; catch(Except3 e) &#123;
            process();
        &#125; catch(Except4 e) &#123;
            process();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="多重捕获"><a href="#多重捕获" class="headerlink" title="多重捕获"></a>多重捕获</h3><ul>
<li>java7之后即使不同类型的异常也可通过**|**来连接捕获，进行异常处理</li>
</ul>
<pre><code>// exceptions/MultiCatch.java
public class MultiCatch &#123;
    void x() throws Except1, Except2, Except3, Except4 &#123;&#125;
    void process() &#123;&#125;
    void f() &#123;
        try &#123;
            x();

        &#125; catch(Except1 | Except2 | Except3 | Except4 e) &#123;
            process();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h2><ul>
<li>重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略。此外，异常对象的所有信息都得以保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。</li>
</ul>
<pre><code class="java">catch(Exception e) &#123;
    System.out.println(&quot;An exception was thrown&quot;);
    throw e;
&#125;
</code></pre>
<ul>
<li>当再次抛出异常时,printStackTrace() 方法显示的将是原来异常抛出点调用栈的信息，而并非重新抛出点的信息。可以调用 filInStackTrace() 方法更新异常抛出点调用栈的信息（这将返回一个 Throwable 对象）。</li>
</ul>
<pre><code class="java">package cn.day.a1;

public class Rethrowing &#123;
    public static void f() throws Exception &#123;
        System.out.println(
                &quot;originating the exception in f()&quot;);
        throw new Exception(&quot;thrown from f()&quot;);
    &#125;
    public static void g() throws Exception &#123;
        try &#123;
            f();
        &#125; catch(Exception e) &#123;
            System.out.println(
                    &quot;Inside g(), e.printStackTrace()&quot;);
            e.printStackTrace(System.out);
            throw e;//再次抛出后没有更新
        &#125;
    &#125;
    public static void h() throws Exception &#123;
        try &#123;
            f();
        &#125; catch(Exception e) &#123;
            System.out.println(
                    &quot;Inside h(), e.printStackTrace()&quot;);
            e.printStackTrace(System.out);
            throw (Exception)e.fillInStackTrace();//抛出并更新
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        try &#123;
            g();//抛出点的调用栈信息一致
        &#125; catch(Exception e) &#123;
            System.out.println(&quot;main: printStackTrace()&quot;);
            e.printStackTrace(System.out);
            
        &#125;
        try &#123;
            h();//抛出点的调用栈信息是更新前后的
        &#125; catch(Exception e) &#123;
            System.out.println(&quot;main: printStackTrace()&quot;);
            e.printStackTrace(System.out);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>在捕获异常之后抛出另一种异常,效果类似于使用 filInStackTrace()，有关原异常抛出点调用栈会丢失</li>
</ul>
<pre><code class="java">// exceptions/RethrowNew.java
// Rethrow a different object from the one you caught
class OneException extends Exception &#123;
    OneException(String s) &#123; super(s); &#125;
&#125;
class TwoException extends Exception &#123;
    TwoException(String s) &#123; super(s); &#125;
&#125;
public class RethrowNew &#123;
    public static void f() throws OneException &#123;
        System.out.println(
                &quot;originating the exception in f()&quot;);
        throw new OneException(&quot;thrown from f()&quot;);
    &#125;
    public static void main(String[] args) &#123;
        try &#123;
            try &#123;
                f();
            &#125; catch(OneException e) &#123;
                System.out.println(
                        &quot;Caught in inner try, e.printStackTrace()&quot;);
                e.printStackTrace(System.out);
                throw new TwoException(&quot;from inner try&quot;);//抛出不同异常
            &#125;
        &#125; catch(TwoException e) &#123;
            System.out.println(
                    &quot;Caught in outer try, e.printStackTrace()&quot;);
            e.printStackTrace(System.out);//此异常仅知道自己来自 main()，而对 f() 一无所知。
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><p>捕获一个异常并抛出另一个异常，同时想保持已捕获异常的信息。</p>
<h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><ul>
<li><p>异常有无发生，均执行的操作（抛出异常时紧跟异常处理语句后执行）</p>
<pre><code class="java">// exceptions/MultipleReturns.java
public class MultipleReturns &#123;
    public static void f(int i) &#123;
        System.out.println(
                &quot;Initialization that requires cleanup&quot;);
        try &#123;
            System.out.println(&quot;Point 1&quot;);
            if(i == 1) return;//返回，中断下面操作，但finally语句仍会执行。
            System.out.println(&quot;Point 2&quot;);
            if(i == 2) return;
            System.out.println(&quot;Point 3&quot;);
            if(i == 3) return;
            System.out.println(&quot;End&quot;);
            return;
        &#125; finally &#123;
            System.out.println(&quot;Performing cleanup&quot;);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        for(int i = 1; i &lt;= 4; i++)
            f(i);
    &#125;
&#125;
</code></pre>
</li>
<li><p>在任何finally语句中使用return，发生(抛出)的异常将静默。</p>
<pre><code class="javascript">public class ExceptionSilencer &#123;
    public static void main(String[] args) &#123;
        try &#123;
            throw new RuntimeException();
        &#125; finally &#123;
            // Using &#39;return&#39; inside the finally block
            // will silence any thrown exception.
            return;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>try中与finally中发生同时（抛出）异常，try中的异常将不被显示(设计缺陷)</p>
<pre><code class="java">package cn.day.a2;

// exceptions/LostMessage.java
// How an exception can be lost
class VeryImportantException extends Exception &#123;
    @Override
    public String toString() &#123;
        return &quot;A very important exception!&quot;;
    &#125;
&#125;
class HoHumException extends Exception &#123;
    @Override
    public String toString() &#123;
        return &quot;A trivial exception&quot;;
    &#125;
&#125;
public class LostMessage &#123;
    void f() throws VeryImportantException &#123;
        throw new VeryImportantException();
    &#125;
    void dispose() throws HoHumException &#123;
        throw new HoHumException();
    &#125;
    public static void main(String[] args) &#123;
        try &#123;
            LostMessage lm = new LostMessage();
            try &#123;
                lm.f();//由于finally也抛出异常，故此异常不被显示
            &#125; finally &#123;
                lm.dispose();
            &#125;
        &#125; catch(VeryImportantException | HoHumException e) &#123;
            System.out.println(e);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="异常限制"><a href="#异常限制" class="headerlink" title="异常限制"></a>异常限制</h1><ul>
<li>一个类可不声明其超类或实现接口中的异常</li>
<li>一个类不能声明与其超类中声明的异常无直接继承关系的异常</li>
<li>异常限制对构造器不起作用。</li>
</ul>
<pre><code class="java">package cn.day.a2;

/**重写的方法只能抛出在其基类版本中指定的异常，或从基类异常派生的异常**/
/*定义异常*/
class BaseballException extends Exception &#123;&#125;
class Foul extends BaseballException &#123;&#125;
class Strike extends BaseballException &#123;&#125;

/*声明异常*/
abstract class Inning &#123;
    Inning() throws BaseballException &#123;&#125;
    public void event() throws BaseballException &#123;
    &#125;
    public abstract void atBat() throws Strike, Foul;
    public void walk() &#123;&#125; 
&#125;
/*定义异常*/
class StormException extends Exception &#123;&#125;
class RainedOut extends StormException &#123;&#125;
class PopFoul extends Foul &#123;&#125;

/*一个接口中声明两个异常*/
interface Storm &#123;
    void event() throws RainedOut;
    void rainHard() throws RainedOut;
&#125;

/*继承上面含有声明异常的类并实现含有声明异常的接口*/
public class StormyInning extends Inning implements Storm &#123;
   
    public StormyInning()
            throws RainedOut, BaseballException &#123;&#125;//声明这个构造器可能发生的异常（来自接口与父类）
    public StormyInning(String s)
  throws BaseballException &#123;&#125;

    @Override
    public void rainHard() throws RainedOut &#123;&#125;
//声明了实现的接口异常
    @Override
    public void event() &#123;&#125;
    // 没有声明异常哦
    @Override
    public void atBat() throws PopFoul &#123;&#125;//覆盖方法可以声明继承了其超类所声明的异常的子异常
//    public void atBat() throws RainedOut &#123;&#125;//其接口有，但其超类未声明此异常，故不可这样做
//    public void atBat() throws BaseballException &#123;&#125;覆盖方法不能声明其超类中未声明且与其超类中声明的异常无直接继承关系的异常
    public static void main(String[] args) &#123;
        try &#123;
            StormyInning si = new StormyInning();
            si.atBat();
        &#125; catch(PopFoul e) &#123;
            System.out.println(&quot;Pop foul&quot;);
        &#125; catch(RainedOut e) &#123;
            System.out.println(&quot;Rained out&quot;);
        &#125; catch(BaseballException e) &#123;
            System.out.println(&quot;Generic baseball exception&quot;);
        &#125;
        try &#123;
            Inning i = new StormyInning();
            i.atBat();
        &#125; catch(Strike e) &#123;
            System.out.println(&quot;Strike&quot;);
        &#125; catch(Foul e) &#123;
            System.out.println(&quot;Foul&quot;);
        &#125; catch(RainedOut e) &#123;
            System.out.println(&quot;Rained out&quot;);
        &#125; catch(BaseballException e) &#123;
            System.out.println(&quot;Generic baseball exception&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h1><ul>
<li><p>异常处理，采用“就近原则”：异常子类可作为捕获参数用于捕获其父类类型的异常。</p>
<pre><code class="java">// exceptions/Human.java
// Catching exception hierarchies
class Annoyance extends Exception &#123;&#125;
class Sneeze extends Annoyance &#123;&#125;
public class Human &#123;
    public static void main(String[] args) &#123;
        // Catch the exact type:
        try &#123;
            throw new Sneeze();
        &#125; catch(Sneeze s) &#123;
            System.out.println(&quot;Caught Sneeze&quot;);
        &#125; catch(Annoyance a) &#123;
            System.out.println(&quot;Caught Annoyance&quot;);
        &#125;
        
        try &#123;
            throw new Sneeze();
        &#125; catch(Annoyance a) &#123;//可捕获Annoyance父类Sneeze的异常
            System.out.println(&quot;Caught Annoyance&quot;);
        &#125;
         catch(Sneeze a) &#123;//将永远无法捕获并处理异常，所以会报错。
            System.out.println(&quot;Caught Annoyance&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><ul>
<li>确保有无异常时打开的文件在结束之后均关闭</li>
</ul>
<pre><code class="java">static String readFirstLineFromFile(String path) throws IOException &#123;
      try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;//即使发生异常（）内的资源也会关闭
        return br.readLine();
      &#125;
    &#125;

/*try finally*/
static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException &#123;
      BufferedReader br = new BufferedReader(new FileReader(path));
      try &#123;
        return br.readLine();
      &#125; finally &#123;
        if (br != null) br.close();//如果close出现异常，则文件无法正常关闭
      &#125;
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#006674>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-07/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-08/">
        <h2>
            Java泛型
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>泛型是编译时泛型，用于检查类型安全以及类型推断，虚拟机运行时已经被擦除；</p>
<p>泛型的类型参数T在编译后为Object类型；</p>
<p>泛型方法能使方法独立于类而产生变化。</p>
<h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><pre><code class="java">/**泛型类*/
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&#123; 
    //key这个成员变量的类型为T由实例化时指定  
    private T key;

    public Generic(T value) &#123; //只有方法所在类声明了T泛型类，那么成员方法才可接收一个T类型的参数
        this.key = value;
    &#125;

    public T getKey()&#123; //这只是类中一个普通的成员方法，只不过其返回值是同泛型类T一样的类型
        //如为public F getKey()，将发生异常
        return key;
    &#125;
&#125;
</code></pre>
<h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><pre><code class="JAVA">/**泛型接口*/
//我们可以为接口传入无数个实参，形成无数种类型的Generator接口。
//定义一个泛型接口
public interface Generator&lt;T&gt; &#123;
    public T next();
&#125;

 //类实现泛型接口时，需将泛型的声明也一起加到类中
 //即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
 //如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;。
class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
    @Override
    public T next() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><pre><code class="java">/**泛型方法*/
//在泛型类中声明了一个泛型方法，使用泛型E，E可以为任意类型，可与方法所在类的类型相同，也可以不同。
//如下：这是一个泛型T的类，它有一个泛型E的泛型方法，这个泛型方法接收并返回一个E类型的参数（类型由实例决定）
public class Test1 &lt;T&gt; &#123;
    public &lt;E&gt; E function1(E a)&#123; return  a;&#125;
&#125;

 //    1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。
 //    2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,
  IllegalAccessException&#123;
        T instance = tClass.newInstance();
        return instance;
&#125;
/*  public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;
       为T的泛型接收一个为E的形参，这将发生异常
    &#125;  */
</code></pre>
<h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><p>当操作类型时，不需要使用类型的具体功能而只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p>
<p><strong>？</strong>和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>
<pre><code class="java">//’？’是类型实参，而不是类型形参 
public void showKeyValue1(Generic&lt;?&gt; obj)&#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&#125;
</code></pre>
<h1 id="要使静态方法接收泛型参数则必须将其写为泛型方法"><a href="#要使静态方法接收泛型参数则必须将其写为泛型方法" class="headerlink" title="要使静态方法接收泛型参数则必须将其写为泛型方法"></a>要使静态方法接收泛型参数则必须将其写为泛型方法</h1><pre><code class="java">public class StaticGenerator&lt;T&gt; &#123;
   
     //如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：
      //    &quot;StaticGenerator cannot be refrenced from static context&quot;
    
    public static &lt;T&gt; void show(T t)&#123;

    &#125;
&#125;
</code></pre>
<h1 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h1><p><strong>泛型的上下边界添加，必须与泛型的声明在一起</strong> </p>
<pre><code class="java">/*只准传入某种类型的父类或；只准传入某种类型的子类。*/
public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&#125;
/**泛型类的边界限定*/
public class Generic&lt;T extends Number&gt;&#123;
    private T key;

    public Generic(T key) &#123;
        this.key = key;
    &#125;

    public T getKey()&#123;
        return key;
    &#125;
&#125;
/**泛型方法的边界限定*/
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
    System.out.println(&quot;container key :&quot; + container.getKey());
    T test = container.getKey();
    return test;
&#125;
</code></pre>
<h1 id="限定"><a href="#限定" class="headerlink" title="限定"></a>限定</h1><ol>
<li>一个类如果没有限定类型，那么虚拟机将会使用Object对其类型进行替换</li>
<li>如果限定了类型，则将类型替换为限定的类型</li>
<li>如限定多个类型，则默认替换为第一个限定类型</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#607d8b>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-08/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-09/">
        <h2>
            IO流
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="流的分类："><a href="#流的分类：" class="headerlink" title="流的分类："></a>流的分类：</h2><p>操作数据单位：字节流、字符流<br>数据的流向：输入流、输出流<br>流的角色：节点流、处理流</p>
<h2 id="流的体系结构"><a href="#流的体系结构" class="headerlink" title="流的体系结构"></a>流的体系结构</h2><h3 id="整体结构体系"><a href="#整体结构体系" class="headerlink" title="整体结构体系"></a>整体结构体系</h3><img src="http://img.lbkzw.cn/img/20200830171143.png" alt="2020-08-30" style="zoom: 67%;" />


<h3 id="主要流"><a href="#主要流" class="headerlink" title="主要流"></a>主要流</h3><table>
<thead>
<tr>
<th><strong>抽象基类</strong></th>
<th><strong>节点流（或文件流）</strong></th>
<th><strong>缓冲流（处理流的一种）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream</td>
<td>FileInputStream   (read(byte[] buffer))</td>
<td>BufferedInputStream (read(byte[] buffer))</td>
</tr>
<tr>
<td>OutputStream</td>
<td>FileOutputStream  (write(byte[] buffer,0,len)</td>
<td>BufferedOutputStream (write(byte[] buffer,0,len) / flush()</td>
</tr>
<tr>
<td>Reader</td>
<td>FileReader (read(char[] cbuf))</td>
<td>BufferedReader (read(char[] cbuf) / readLine())</td>
</tr>
<tr>
<td>Writer</td>
<td>FileWriter (write(char[] cbuf,0,len)</td>
<td>BufferedWriter (write(char[] cbuf,0,len) / flush()</td>
</tr>
</tbody></table>
<h1 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h1><blockquote>
<p>直接作用于文件</p>
</blockquote>
<h2 id="字符流：FileReader与FileWriter"><a href="#字符流：FileReader与FileWriter" class="headerlink" title="字符流：FileReader与FileWriter"></a>字符流：FileReader与FileWriter</h2><pre><code class="java">  @Test
    public void testFileReaderFileWriter() &#123;
        FileReader fr = null;//为完美关闭流提供条件。
        //由下方代码得出：代码执行到finally时，若未创建流且变量fr为非null值，则将引起异常（为创建流而关闭流）
        FileWriter fw = null;
        try &#123;
            //1.创建File类的对象，指明读入和写出的文件
            File srcFile = new File(&quot;hello.txt&quot;);
            File destFile = new File(&quot;hello2.txt&quot;);

            //不能使用字符流来处理图片等字节数据
//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);
//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);


            //2.创建输入流和输出流的对象
            fr = new FileReader(srcFile);
            fw = new FileWriter(destFile);


            //3.数据的读入和写出操作
            char[] cbuf = new char[5];
            int len;//记录每次读入到cbuf数组中的字符的个数
            while((len = fr.read(cbuf)) != -1)&#123;//从流fr中将 cbuf.length 个字节的数据读入一个 char 数组中
//直到因到达流末尾而返回 -1时停止循环。
                fw.write(cbuf,0,len);

            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //4.关闭流资源
            //方式一：
//            try &#123;
//                if(fw != null)
//                    fw.close();
//            &#125; catch (IOException e) &#123;
//                e.printStackTrace();
//            &#125;finally&#123;
//                try &#123;
//                    if(fr != null)
//                        fr.close();
//                &#125; catch (IOException e) &#123;
//                    e.printStackTrace();
//                &#125;
//            &#125;
            //方式二：
            try &#123;
                if(fw != null)//确定创建了流
                    fw.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(fr != null)
                    fr.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;
</code></pre>
<h2 id="字节流：FileInputStream与FileOutputStream"><a href="#字节流：FileInputStream与FileOutputStream" class="headerlink" title="字节流：FileInputStream与FileOutputStream"></a>字节流：FileInputStream与FileOutputStream</h2><p>对于文本文件(.txt,.java,.c,.cpp…)，使用字符流处理;</p>
<p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理。</p>
<pre><code class="java">@Test                                                                    
public void testFileInputStream() &#123;                                      
    FileInputStream fis = null;                                          
    try &#123;                                                                
        //1. 造文件                                                         
        File file = new File(&quot;hello.txt&quot;);                               
                                                                         
        //2.造流                                                           
        fis = new FileInputStream(file);                                 
         /*1、2这样写也可以fis = new FileInputStream(&quot;hello.txt&quot;);会自动包裹*/                                                               
        //3.读数据                                                          
        byte[] buffer = new byte[5];  //这是个byte数组哦
        //由于中文在utf-8编码中占用3个字节（最高占用到6个字节），而每次读入5个字节可能发生乱码
        int len;//记录每次读取的字节的个数                                           
        while((len = fis.read(buffer)) != -1)&#123;                           
                                                                         
            String str = new String(buffer,0,len); //通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。                      
            System.out.print(str);                                       
                                                                         
        &#125;                                                                
    &#125; catch (IOException e) &#123;                                            
        e.printStackTrace();                                             
    &#125; finally &#123;                                                          
        if(fis != null)&#123;                                                 
            //4.关闭资源                                                     
            try &#123;                                                        
                fis.close();                                             
            &#125; catch (IOException e) &#123;                                    
                e.printStackTrace();                                     
            &#125;                                                            
                                                                         
        &#125;                                                                
    &#125;                                                                    
                                                                         
&#125;                                                                        
</code></pre>
<h1 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h1><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>作用于流，在流外再包裹一层流。</p>
<p>BufferedInputStream会一次性从文件中读取8192个(8Kb),存在缓冲区中,直到缓冲区装满了,才重新从文件中读取下一个8192个字节数组;</p>
<p>不会直接写到文件,先写到缓冲区中直到缓冲区写满,BufferedOutputStream才会把缓冲区中的数据一次性写到文件里;</p>
<p><code>flush()</code>刷新缓冲区，可以强制将缓冲区的内容全部写入输出流;close()方法关闭带缓冲流的流时，会自动刷新缓冲区后再关闭流。</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><pre><code class="java"> @Test
    public void testBufferedReaderBufferedWriter()&#123;
        BufferedReader br = null;
        BufferedWriter bw = null;
        try &#123;
            //创建文件和相应的流
            br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;)));
            bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;)));

            //读写操作
            //方式一：使用char[]数组
//            char[] cbuf = new char[1024];
//            int len;
//            while((len = br.read(cbuf)) != -1)&#123;
//                bw.write(cbuf,0,len);
//    //            bw.flush();
//            &#125;

            //方式二：使用String
            String data;
            while((data = br.readLine()) != null)&#123;
                //方法一：
//                bw.write(data + &quot;\n&quot;);//data中不包含换行符
                //方法二：
                bw.write(data);//data中不包含换行符
                bw.newLine();//提供换行的操作

            &#125;


        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭资源
            if(bw != null)&#123;

                try &#123;
                    bw.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if(br != null)&#123;
                try &#123;
                    br.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;

    &#125;
</code></pre>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h3><pre><code class="java">@Test
    public void BufferedStreamTest()&#123;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try &#123;
            //1.造文件
            File srcFile = new File(&quot;爱情与友情.jpg&quot;);
            File destFile = new File(&quot;爱情与友情3.jpg&quot;);
            //2.造流
            //2.1 造节点流
            FileInputStream fis = new FileInputStream((srcFile));
            FileOutputStream fos = new FileOutputStream(destFile);
            //2.2 造缓冲流
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);

            //3.复制的细节：读取、写入
            byte[] buffer = new byte[10];
            int len;
            while((len = bis.read(buffer)) != -1)&#123;
                bos.write(buffer,0,len);

//                bos.flush();//刷新缓冲区，可以强制将缓冲区的内容全部写入输出流

            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //4.资源关闭
            //要求：先关闭外层的流，再关闭内层的流
            if(bos != null)&#123;
                try &#123;
                    bos.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
            if(bis != null)&#123;
                try &#123;
                    bis.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
            //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
//        fos.close();
//        fis.close();
        &#125;
    &#125;
</code></pre>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>提供字节流与字符流之间的转换</p>
<pre><code class="java">package com.atguigu.java;

import org.junit.Test;

import java.io.*;

/**
 * 处理流之二：转换流的使用
 * 1.转换流：属于字符流
 *   InputStreamReader：将一个字节的输入流转换为字符的输入流
 *   OutputStreamWriter：将一个字符的输出流转换为字节的输出流
 *
 * 2. 解码：字节、字节数组  ---&gt;字符数组、字符串
 *    编码：字符数组、字符串 ---&gt; 字节、字节数组
 *
 *
 * 3.字符集
 *ASCII：美国标准信息交换码。
    用一个字节的7位可以表示。
 ISO8859-1：拉丁码表。欧洲码表
    用一个字节的8位表示。
 GB2312：中国的中文编码表。最多两个字节编码所有字符
 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。
 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。

 *
 *
 * @author shkstart
 * @create 2019 下午 4:25
 */
public class InputStreamReaderTest &#123;

    /*
    此时处理异常的话，仍然应该使用try-catch-finally
    InputStreamReader的使用，实现字节的输入流到字符的输入流的转换
     */
    /*
    此时处理异常的话，仍然应该使用try-catch-finally

    综合使用InputStreamReader和OutputStreamWriter
     */

    @Test
    public void test1()  &#123;
    FileInputStream fis = null;
    //在js中我们知道，catch也具有局部作用域，因此照本方法处理异常需要将引用流的变量在全局作用域声明
        // （方法中的变量不会默认初始化为null，需要手动处理）
    InputStreamReader isr =null;

        try &#123;
            fis = new FileInputStream(&quot;dbcp.txt&quot;);
//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集
            //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集
            isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//使用系统默认的字符集

            char[] cbuf = new char[20];
            int len;
            while((len = isr.read(cbuf)) != -1)&#123;
                String str = new String(cbuf,0,len);
                System.out.print(str);
            &#125;

        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (isr!=null)&#123;
                try &#123;
                    isr.close();
                &#125;catch (IOException e)&#123;
                    e.printStackTrace();
                &#125;

            &#125;

        &#125;

    &#125;
    @Test
    public void test2()&#123;
        InputStreamReader isr = null;
        OutputStreamWriter osw = null;
        try &#123;
            FileInputStream fis = new FileInputStream(new File(&quot;dbcp.txt&quot;));
            FileOutputStream fos = new FileOutputStream(new File(&quot;dbcp_gbk.txt&quot;));

            isr = new InputStreamReader(fis,&quot;utf-8&quot;);
            osw = new OutputStreamWriter(fos,&quot;gbk&quot;);

            //2.读写过程
            char[] cbuf = new char[20];
            int len;
            while((len = isr.read(cbuf)) != -1)&#123;
                osw.write(cbuf,0,len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;

            //3.关闭资源
            if (isr!=null)&#123;
                try &#123;
                    isr.close();
                &#125;catch (IOException e)&#123;
                    e.printStackTrace();
                &#125;

            &#125;
            if (isr!=null)&#123;
                try &#123;
                    osw.close();
                &#125;catch (IOException e)&#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><blockquote>
<p>将对象序列化为二进制流便于在网络中传输</p>
</blockquote>
<p>序列化:用ObjectOutputStream类保存基本类型数据或对象的机制<br>反序列化:用ObjectInputStream类读取基本类型数据或对象的机制</p>
<p>可序列化的类必须实现以下接口任意一个：</p>
<ul>
<li><p>Serializable</p>
<p>实现Serializable接口的类都有一个表示序列化版本标识符的静态变量:<code>private static final long serialVersionUID;</code><br>serialVersionUID用来进行版本控制;如果类没有显示定义这个静态常量,它的值是Java运行时环境根据类的内部细节自<br>动生成的;若类的实例变量做了修改,serialVersionUID 可能发生变化。</p>
</li>
<li><p>Externalizable</p>
</li>
</ul>
<pre><code class="java">import java.io.Serializable;

/**
 * Person需要满足如下的要求，方可序列化
 * 1.需要实现接口：Serializable
 * 2.当前类提供一个全局常量：serialVersionUID
 * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性
 *   也必须是可序列化的。（默认情况下，基本数据类型可序列化）
 *
 *
 * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
 *
 *
 * @author shkstart
 * @create 2019 上午 10:38
 */
/*一个将用以序列化的类*/
public class Person implements Serializable&#123;//实现接口：Serializable

    public static final long serialVersionUID = 475463534532L;//全局常量：serialVersionUID

    private String name;
    private int age;
    private int id;
    private Account acct;

    public Person(String name, int age, int id) &#123;
        this.name = name;
        this.age = age;
        this.id = id;
    &#125;

    public Person(String name, int age, int id, Account acct) &#123;
        this.name = name;
        this.age = age;
        this.id = id;
        this.acct = acct;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, id=&quot; + id +
                &quot;, acct=&quot; + acct +
                &#39;&#125;&#39;;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Person(String name, int age) &#123;

        this.name = name;
        this.age = age;
    &#125;

    public Person() &#123;

    &#125;
&#125;

class Account implements Serializable&#123;
    public static final long serialVersionUID = 4754534532L;
    private double balance;

    @Override
    public String toString() &#123;
        return &quot;Account&#123;&quot; +
                &quot;balance=&quot; + balance +
                &#39;&#125;&#39;;
    &#125;

    public double getBalance() &#123;
        return balance;
    &#125;

    public void setBalance(double balance) &#123;
        this.balance = balance;
    &#125;

    public Account(double balance) &#123;

        this.balance = balance;
    &#125;
&#125;
/*序列化操作开始*/
@Test
    public void testObjectOutputStream()&#123;
        ObjectOutputStream oos = null;

        try &#123;
            //1.
            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));
            //2.
            oos.writeObject(new String(&quot;我爱北京天安门&quot;));
            oos.flush();//刷新操作

            oos.writeObject(new Person(&quot;王铭&quot;,23));
            oos.flush();

            oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000)));
            oos.flush();

        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if(oos != null)&#123;
                //3.
                try &#123;
                    oos.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;

    &#125;

    /*
    反序列化：将磁盘文件中的对象还原为内存中的一个java对象
    使用ObjectInputStream来实现
     */
    @Test
    public void testObjectInputStream()&#123;
        ObjectInputStream ois = null;
        try &#123;
            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();//注意之前创建的是Person的对象
            Person p1 = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p);
            System.out.println(p1);

        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if(ois != null)&#123;
                try &#123;
                    ois.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;
    &#125;
</code></pre>
<h1 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h1><blockquote>
<p>可读可写、可盐可甜</p>
</blockquote>
<p><code>public RandomAccessFile(File file, String mode)</code><br><code>public RandomAccessFile(String name, String mode)</code><br>创建 RandomAccessFile 类实例需要指定一个 mode 参数,该参数指定 RandomAccessFile 的访问模式:</p>
<ol>
<li>r: 以只读方式打开</li>
<li>rw:打开以便读取和写入</li>
<li>rwd:打开以便读取和写入;同步文件内容的更新</li>
<li>rws:打开以便读取和写入;同步文件内容和元数据的更新</li>
</ol>
<p>如果模式为只读r。则不会创建文件,而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 </p>
<p>如果模式为rw读写，如果文件不存在则会去创建文件。</p>
<pre><code class="java">   @Test
    public void test1() &#123;

        RandomAccessFile raf1 = null;
        RandomAccessFile raf2 = null;
        try &#123;
            //1.
            raf1 = new RandomAccessFile(&quot;爱情与友情.jpg&quot;,&quot;r&quot;);
            raf2 = new RandomAccessFile(new File(&quot;爱情与友情12.jpg&quot;),&quot;rw&quot;);
            //2.
            byte[] buffer = new byte[1024];
            int len;
            while((len = raf1.read(buffer)) != -1)&#123;
                raf2.write(buffer,0,len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //3.
            if(raf1 != null)&#123;
                try &#123;
                    raf1.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
            if(raf2 != null)&#123;
                try &#123;
                    raf2.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;
    &#125;
/*插入数据*/
    @Test
    public void test2() throws IOException &#123;

        RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);

        raf1.seek(3);//将指针调到角标为3的位置
        raf1.write(&quot;xyz&quot;.getBytes());//使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组
        raf1.close();

    &#125;
</code></pre>
<h1 id="字节流实现图片加密解密"><a href="#字节流实现图片加密解密" class="headerlink" title="字节流实现图片加密解密"></a>字节流实现图片加密解密</h1><pre><code class="java">package com.atguigu.exer;

import org.junit.Test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author shkstart
 * @create 2019 下午 4:08
 */
public class PicTest &#123;

    //图片的加密
    @Test
    public void test1() &#123;

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try &#123;
            fis = new FileInputStream(&quot;爱情与友情.jpg&quot;);
            fos = new FileOutputStream(&quot;爱情与友情secret.jpg&quot;);

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) &#123;
                //字节数组进行修改
                //错误的
                //            for(byte b : buffer)&#123;
                //                b = (byte) (b ^ 5);
                //            &#125;
                //正确的
                for (int i = 0; i &lt; len; i++) &#123;
                    buffer[i] = (byte) (buffer[i] ^ 5);
                &#125;


                fos.write(buffer, 0, len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (fos != null) &#123;
                try &#123;
                    fos.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
            if (fis != null) &#123;
                try &#123;
                    fis.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;


    &#125;


    //图片的解密
    @Test
    public void test2() &#123;

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try &#123;
            fis = new FileInputStream(&quot;爱情与友情secret.jpg&quot;);
            fos = new FileOutputStream(&quot;爱情与友情4.jpg&quot;);

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) &#123;
                //字节数组进行修改
                //错误的
                //            for(byte b : buffer)&#123;
                //                b = (byte) (b ^ 5);
                //            &#125;
                //正确的
                for (int i = 0; i &lt; len; i++) &#123;
                    buffer[i] = (byte) (buffer[i] ^ 5);
                &#125;

                fos.write(buffer, 0, len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (fos != null) &#123;
                try &#123;
                    fos.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
            if (fis != null) &#123;
                try &#123;
                    fis.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;


    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#607d8b>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-09/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-10/">
        <h2>
            浅拷贝与深拷贝
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><blockquote>
<p>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。</p>
</blockquote>
<p>验证：</p>
<pre><code class="java">package com.data.test;

public class Students implements Cloneable&#123;
    //clone()方法是protected修饰的，因此需要实现Cloneable接口才能调用，同时需要覆写clone()方法才能调用。
    private int id;
    private int age;
    private String name;
    private Teacher teacher;

    public Students(int id, int age, String name, Teacher teacher) &#123;
        this.id = id;
        this.age = age;
        this.name = name;
        this.teacher = teacher;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public Teacher getTeacher() &#123;
        return teacher;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setTeacher(Teacher teacher) &#123;
        this.teacher = teacher;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Students&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, teacher=&quot; + teacher +
                &#39;&#125;&#39;;
    &#125;
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
            return super.clone();
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.data.test;

public class Teacher &#123;
    private String name;
    private String six;

    public Teacher(String name, String six) &#123;
        this.name = name;
        this.six = six;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public String getSix() &#123;
        return six;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setSix(String six) &#123;
        this.six = six;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Teacher&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, six=&#39;&quot; + six + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.data.test;

public class TestObject &#123;
    public static void main(String[] args) throws CloneNotSupportedException &#123;
        var stu = new Students(01,20,&quot;张三&quot;,new Teacher(&quot;王五&quot;,&quot;男&quot;));
        var stuClone =(Students)stu.clone();
        /*判断此俩对象地址是否相同*/
        if (stu.equals(stuClone))&#123;
            System.out.println(&quot;地址相同&quot;);
        &#125;else System.out.println(&quot;地址不同&quot;);
        /*toString查看数据*/
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证浅拷贝不拷贝对象仅仅拷贝对象引用*/
        System.out.println(&quot;----------验证浅拷贝不拷贝对象仅仅拷贝对象引用-----------&quot;);
        var aT = stu.getTeacher();
        aT.setName(&quot;尼古拉斯&quot;);
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证浅拷贝会复制字段*/
        System.out.println(&quot;----------验证浅拷贝会复制字段-----------&quot;);
        stu.setId(2);
        System.out.println(stu);
        System.out.println(stuClone);
        /*修改数据*/
        System.out.println(&quot;----------通过改变引用的方式进行数据修改(不影响原始对象即被拷贝的对象)-----------&quot;);
        stu.setTeacher(new Teacher(&quot;李四&quot;,&quot;女&quot;));
        //即使在clone后，stu与stuClone引用的仍是同一个对象，故可以通过改变引用的方式进行数据修改
        System.out.println(stuClone);
        System.out.println(stu);
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<img src="http://img.lbkzw.cn/img/20200927111340.png" alt="image-20200927111340317" style="zoom:50%;" />

<h1 id="对象的toString"><a href="#对象的toString" class="headerlink" title="对象的toString"></a>对象的toString</h1><p>未覆盖toString：</p>
<blockquote>
<p>打印的是该对象的地址</p>
</blockquote>
<img src="http://img.lbkzw.cn/img/20200927103720.png" alt="image-20200927103720635" style="zoom:50%;" />

<p>覆盖toString：</p>
<pre><code class="java">@Override
    public String toString() &#123;
        return &quot;Students&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, teacher=&quot; + teacher +
                &#39;&#125;&#39;;//teacher是一个对象的引用
    &#125;
</code></pre>
<img src="http://img.lbkzw.cn/img/20200927103948.png" alt="image-20200927103948710" style="zoom:50%;" />

<p>由于未覆盖teacher引用对象的toString，故打印出其引用对象的地址。</p>
<p>覆盖teacher引用对象的toString</p>
<pre><code class="java">@Override
    public String toString() &#123;
        return &quot;Teacher&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, six=&#39;&quot; + six + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
</code></pre>
<p>运行结果：</p>
<img src="http://img.lbkzw.cn/img/20200927104304.png" alt="image-20200927104304776" style="zoom:50%;" />

<h1 id="深度拷贝"><a href="#深度拷贝" class="headerlink" title="深度拷贝"></a>深度拷贝</h1><ol>
<li>为类重写原始类与克隆类的clone方法，实现其自我克隆：<br>这个缺点是：如果克隆类中也引用了一个对象则又需要对这个对象的类实现Cloneable接口并覆盖其clone方法，接着再克隆这个对象，周而复始，无往不利。</li>
</ol>
<pre><code class="java">/*Students类的clone*/
@Override
    protected Object clone() throws CloneNotSupportedException &#123;
            var cloneStudents = (Students)super.clone();
            cloneStudents.teacher = (Teacher)teacher.clone();
            //对新克隆的Students对象中的元素即teacher引用的对象进行克隆。
            return cloneStudents;
    &#125;



/*Teacher类的clone*/
@Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
    
</code></pre>
<ol start="2">
<li>利用序列化：</li>
</ol>
<p>一个用来序列化的类</p>
<pre><code class="java">package com.data.test;

import java.io.*;

public class Copy implements Serializable &#123;
    private static final long serialVersionUID = 1L;
    protected &lt;T&gt;T copy() throws IOException, ClassNotFoundException &#123;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);
        /*反序列化*/
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return (T) ois.readObject();

    &#125;
&#125;
</code></pre>
<p>原始类与克隆类继承copy类（用于序列化操作）</p>
<pre><code class="java">public class Students extends Copy&#123;...&#125;
public class Teacher extends Copy&#123;...&#125;
</code></pre>
<pre><code class="java">package com.data.test;

import java.io.IOException;

public class TestObject &#123;
    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;
        var stu = new Students(01,20,&quot;张三&quot;,new Teacher(&quot;王五&quot;,&quot;男&quot;));
        Students stuClone =stu.copy();
        /*判断此俩对象地址是否相同*/
        if (stu.equals(stuClone))&#123;
            System.out.println(&quot;地址相同&quot;);
        &#125;else System.out.println(&quot;地址不同&quot;);
        /*toString查看数据*/
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证拷贝对象*/
        System.out.println(&quot;----------验证拷贝对象-----------&quot;);
        var aT = stu.getTeacher();
        aT.setName(&quot;尼古拉斯&quot;);
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证复制字段*/
        System.out.println(&quot;----------验证复制字段-----------&quot;);
        stu.setId(2);
        System.out.println(stu);
        System.out.println(stuClone);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#016a99>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-10/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-11/">
        <h2>
            1~4章
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="JavaBeans模式"><a href="#JavaBeans模式" class="headerlink" title="JavaBeans模式"></a>JavaBeans模式</h1><blockquote>
<p>当我们需要传入多个参数构造对象时（比如有时传入2个参数，有时传入20个参数），可采用“重叠构造器模式”即利用“重载”机制。</p>
<p>但如果需要传入的参数是2-2000个呢？</p>
<p>我们总不能复写2000个构造器吧。</p>
<p>我们可采用: <strong>JavaBeans模式</strong></p>
</blockquote>
<p>用一个无参数的构造器创建对象，然后通过多个set方法设置参数。</p>
<pre><code class="java">public class myJavaBeans &#123;
    private int id;
    private String name;
    private String sex;
    /*更多字段省略*/
    public myJavaBeans() &#123;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
&#125;
</code></pre>
<p><em>这个方法模式存在线程安全</em></p>
<p>下面有一种Builder模式可保证线程安全</p>
<p><strong>Builder模式</strong></p>
<p>使用<strong>静态内部类</strong>（静态工厂方法）设置属性（参数），最后创建类（返回其父类的对象）完成对象初始化。</p>
<pre><code class="java">public class myBuilder &#123;
    private int id;
    private String name;
    private String sex;
    
    public static class Builder  &#123;//静态内部类只会被加载一次
        private int id;
        private String name;
        private String sex;

        public Builder() &#123;
        &#125;

        public Builder setId(int id) &#123;
            this.id = id;
            return this;//返回this，用于实现链接式调用
        &#125;

        public Builder setName(String name) &#123;
            this.name = name;
            return this;
        &#125;

        public Builder setSex(String sex) &#123;
            this.sex = sex;
            return this;
        &#125;
        //通过此方法返回内部类对象，此时内部类对象
        public myBuilder builder()&#123;
            return new myBuilder(this);
        &#125;
    &#125;

    private myBuilder(Builder builder) &#123;
        //构造器传入静态内部类builder对象，对myBuilder进行初始化。
        this.id = builder.id;
        this.name = builder.name;
        this.sex = builder.sex;
    &#125;

    public static void main(String[] args) &#123;
        myBuilder demoMyBuilder = new myBuilder.Builder().setId(0).setName(&quot;张三&quot;).setSex(&quot;男&quot;).builder();
        //此内部类的set方法返回其本身，故可以将多个set方法调用链接起来
        System.out.println(demoMyBuilder.sex);
        System.out.println(demoMyBuilder.id);
        System.out.println(demoMyBuilder.name);
    &#125;
&#125;
</code></pre>
<p>使用泛型构建任何对象</p>
<pre><code class="java">public interface Builder1&lt;T&gt; &#123;
    public T build();
&#125;
</code></pre>
<h1 id="单例模式Singleton"><a href="#单例模式Singleton" class="headerlink" title="单例模式Singleton"></a>单例模式Singleton</h1><ol>
<li><p>仅设置一个私有构造器，使用公共的final静态字段构造对象。</p>
<pre><code class="java">
public class Elvis &#123;
    public static final Elvis INSTANCE = new Elvis();//加载类时将自动创建对象
    private Elvis()&#123;&#125;
    public void leaveTheBuilding()&#123;&#125;
&#125;
</code></pre>
</li>
<li><p>通过静态工厂方法:设置一个私有构造器，一个私有final静态字段（构造对象），最后通过一个静态方法返回final静态字段。</p>
<pre><code class="java">class Elvis1&#123;
    //1.字段私有化
    private static final Elvis1 INSTANCE = new Elvis1();
    //2.构造器私有化
    private Elvis1()&#123;&#125;
    //2.静态工厂方法返回对象引用
    public static Elvis1 getInstance()&#123;return INSTANCE;&#125;
    public void leaveTheBuilding()&#123;&#125;
&#125;
</code></pre>
<h1 id="消除过期元素"><a href="#消除过期元素" class="headerlink" title="消除过期元素"></a>消除过期元素</h1></li>
</ol>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.EmptyStackException;

public class Stack &#123;
    private Object[] elements;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private int size = 0;
    public Stack()&#123;
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    &#125;
    //动态数组
    private void ensureCapacity()&#123;
        if (elements.length == size)&#123;
            elements = Arrays.copyOf(elements,2*size+1);
        &#125;
    &#125;
    //添加元素
    public void push(Object e)&#123;
        ensureCapacity();//先判断数组是否有空间（空间不足则扩展空间）
        elements[size++] = e;
    &#125;
    
    //弹出元素
//    public Object pop()&#123;
//        if (size == 0)&#123;//栈为空抛出异常
//            throw new EmptyStackException();
//        &#125;
//        return elements[--size];
//        //注意：即使连续使用多个pop()方法，经历--size的元素仍然存在于数组中
//    &#125;
    public Object pop()&#123;
        if (size == 0)&#123;
            throw new EmptyStackException();
        &#125;
        Object result = elements[--size];
        elements[size] = null;//将索引赋值为null，消除过期元素
        return result;
    &#125;
&#125;
</code></pre>
<h1 id="使类与成员的可访问性最小化"><a href="#使类与成员的可访问性最小化" class="headerlink" title="使类与成员的可访问性最小化"></a>使类与成员的可访问性最小化</h1><ol>
<li>创建类时不声明则默认为缺省即包访问级别，声明为protected时仅可被子类、同一包内的类访问。</li>
<li>子类覆盖父类方法时访问级别不得低于其父类</li>
</ol>
<p><strong>闭包性：public&lt;default（缺省级别，默认）&lt;protected&lt;private</strong></p>
<p>private与protected不能用来修饰类；</p>
<p>只有同一包内的另一个类迫切需要访问一个成员时，我们才会将private修改为protected。</p>
<h1 id="在公共类中使用访问方法而非公共-域"><a href="#在公共类中使用访问方法而非公共-域" class="headerlink" title="在公共类中使用访问方法而非公共 域"></a>在公共类中使用访问方法而非公共 域</h1><ol>
<li>将公共类字段私有化，通过set、get方法对其进行修改、访问。</li>
<li>可使用不可变的公共字段：<code>public final int ID;</code></li>
</ol>
<h1 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h1><ol>
<li><p>字段采用是<code> private final</code>修饰，提供创建新对象的方法而不提供修改的方法,修改时返回新对象。</p>
<pre><code class="java">public final class Complex &#123;
    private final double re;
    private final double im;

    public Complex(double re, double im) &#123;
        this.re = re;
        this.im = im;
    &#125;
    public Complex add(Complex o)&#123;//修改时返回新对象
        return new Complex(re-o.re,im+o.re);
    &#125;
&#125;
</code></pre>
</li>
<li><p>.字段采用是 <code>private final</code>修饰，有仅一个私有构造器，通过静态工厂方法返回对象</p>
<pre><code class="java">public final class Complex &#123;
    private final double re;
    private final double im;

    private Complex(double re, double im) &#123;
        this.re = re;
        this.im = im;
    &#125;
    public static Complex valueOf(double re, double im)&#123;
        return new Complex(re,im);
    &#125;
&#125;
</code></pre>
</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/EffectiveJava" style=color:#6484be>
                EffectiveJava
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-11/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-Aop/">
        <h2>
            简单使用动态代理
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="简单使用动态代理"><a href="#简单使用动态代理" class="headerlink" title="简单使用动态代理"></a>简单使用动态代理</h1><blockquote>
<p>使用Aop在不改变原有结构下对类的功能进行增强</p>
</blockquote>
<p>1.目标类接口</p>
<pre><code class="java">package cn.itthree.aop.service;
/**
 *
 目标接口* */
public interface UsbSell &#123;
    /*amount表示单次购买数量
     * 返回值是一个u盘的价格*/
    float sell(int amount);
&#125;
</code></pre>
<p>2.目标方法</p>
<pre><code class="java">package cn.itthree.aop.factory;


import cn.itthree.aop.service.UsbSell;

/**目标类*/
public class UsbKingFactory implements UsbSell &#123;
    @Override
    //目标方法
    public float sell(int amount) &#123;
        System.out.println(&quot;目标类中执行了目标方法调用&quot;);
        return 85.0f;
    &#125;
&#125;
</code></pre>
<p>3.一个简单的代理类</p>
<pre><code class="java">package cn.itthree.aop.handler;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MySellHandler implements InvocationHandler &#123;
    private Object target = null;
    public MySellHandler(Object target) &#123;
        this.target = target;
    &#125;

    @Override
    //动态代理对象需要传入
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        //执行目标方法并获取返回值
        Object res = null;
        res = method.invoke(target,args);
        //功能增强
        //在不改变结构的情况下对目标类进行增强
        if (res != null)&#123;
            Float price = (Float)res;
            price += 25;
            res = price;
        &#125;
        return res;

    &#125;
&#125;
</code></pre>
<p>4.测试主程序</p>
<pre><code class="java">package cn.itthree.aop;

import cn.itthree.aop.factory.UsbKingFactory;
import cn.itthree.aop.handler.MySellHandler;
import cn.itthree.aop.service.UsbSell;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class MainShop &#123;
    public static void main(String[] args) &#123;
        //1.创建目标对象
        UsbSell factory =  new UsbKingFactory();
        //2.创建InvocationHandler对象
        InvocationHandler handler = new MySellHandler(factory);
        //3.创建代理对象
        /*
        public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
                                          */
        //传入3个参数：
        //1.目标类
        //3.目标类的接口
        //3.InvocationHandler对象
        UsbSell proxy  = (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),handler);
        //4.通过代理执行方法
        float price = proxy.sell(1);
        System.out.println(&quot;动态代理对象，调用方法： &quot;+price);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AOP" style=color:#006674>
                AOP
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-Aop/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-Jsp-01/">
        <h2>
            Jsp
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JavaWeb">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JavaWeb
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Jsp书写规则"><a href="#Jsp书写规则" class="headerlink" title="Jsp书写规则"></a>Jsp书写规则</h1><p><code>&lt;% %&gt;</code>中书写Java代码</p>
<pre><code>&lt;%
    Students stu1 = new Students(&quot;张三&quot;,1);
    Students stu2 = new Students(&quot;李四&quot;,2);
    Students stu3 = new Students(&quot;Li Si&quot;,3);
    List&lt;Students&gt; list = new ArrayList&lt;&gt;();
    list.add(stu1);
    list.add(stu2);
    list.add(stu3);
%&gt;
</code></pre>
<p><code>&lt;%= %&gt;</code>用于变量传值</p>
<p>如下代码，for循环为一个整体，用&lt;%分隔包裹实现输出值到页面。</p>
<p>究其根本，仍是使用流，如：</p>
<pre><code class="java">PrintWriter out = servletResponse.getWriter();
out.print(&quot;&lt;center&gt;&lt;h1&gt;廉颇老矣，尚能饭否？&lt;/h1&gt;&lt;/center&gt;&quot;);
</code></pre>
<pre><code class="jsp">&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;姓名&lt;/td&gt;
        &lt;td&gt;学号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;%
        for (Students value:list)&#123;

    %&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;%=value.getName()%&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%=value.getId()%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;%
        &#125;
    %&gt;
&lt;/table&gt;
</code></pre>
<h1 id="Jsp内置对象"><a href="#Jsp内置对象" class="headerlink" title="Jsp内置对象"></a>Jsp内置对象</h1><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>​     类型：HttpServletRequest<br>​     作用: 在JSP文件运行时读取请求包信息并与Servlet在请求转发过程中实现数据共享</p>
<pre><code class="jsp">&lt;!--
  浏览器输入： http://localhost:8080/myWeb/request.jsp?userName=张三&amp;password=123
--&gt;
&lt;%
   //在JSP文件执行时，借助于内置request对象读取请求包参数信息
    String userName = request.getParameter(&quot;userName&quot;);
    String password =request.getParameter(&quot;password&quot;);
%&gt;

来访用户姓名:&lt;%=userName%&gt;&lt;br/&gt;
来访用户密码:&lt;%=password%&gt;
</code></pre>
<p>效果图：</p>
<p><img src="http://img.lbkzw.cn/img/20201101154914.png" alt="image-20201101154914442"></p>
<h3 id="ServletContext-全局作用域对象"><a href="#ServletContext-全局作用域对象" class="headerlink" title="ServletContext(全局作用域对象)"></a>ServletContext(全局作用域对象)</h3><p>同一个网站中Servlet与Jsp，都可以通过ServletContext实现数据共享</p>
<p>jsp中设置全局作用域对象：</p>
<pre><code class="jsp">&lt;%
    application.setAttribute(&quot;key1&quot;, &quot;hello world&quot;);
%&gt;
</code></pre>
<pre><code class="java">@WebServlet(&quot;/Servlet1&quot;)
public class Servlet1 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        ServletContext application = request.getServletContext();//获取全局作用域对象
        String value = (String)application.getAttribute(&quot;key1&quot;);//通过键获取值（获取作用域内的数据）
        System.out.println(value);
    &#125;
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<p><img src="http://img.lbkzw.cn/img/20201101161507.png" alt="image-20201101161507410"></p>
<pre><code>###  session
</code></pre>
<p>数据共享：</p>
<p>第一个jsp文件</p>
<pre><code class="jsp">&lt;%
     Integer value=(Integer) session.getAttribute(&quot;key1&quot;);
%&gt;
</code></pre>
<p>第二个jsp文件</p>
<pre><code class="jsp">&lt;%
   // HttpSession session = request.getSession();
   session.setAttribute(&quot;key1&quot;, 200);
%&gt;
</code></pre>
<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><blockquote>
<p>jsp默认支持el表达式。如要忽略el表达式需要设置jsp中<code>page</code>指令中：<code>isELIgnored=&quot;true&quot; ;</code>忽略当前这个el表达式则于<code>$&#123;&#125;</code>前加<code>/</code>即可</p>
</blockquote>
<p>##运算符</p>
<p>算数运算符： + - * /(div) %(mod)</p>
<p>比较运算符： &gt; &lt; &gt;= &lt;= == !=</p>
<p>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</p>
<p>空运算符： empty</p>
<ul>
<li>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</li>
<li>如：<code>$&#123;empty list&#125;</code>判断字符串、集合、数组对象是否为null或者长度为0</li>
<li><code>$&#123;not empty str&#125;</code>判断字符串、集合、数组对象是否不为null 并且 长度&gt;0\</li>
</ul>
<pre><code class="jsp">&lt;h3&gt;EL运算&lt;/h3&gt;
$&#123;1+2&#125;
$&#123;1-2&#125;
$&#123;1*2&#125;
$&#123;1/2&#125;
&lt;h3&gt;empty&lt;/h3&gt;
&lt;%
    String str = &quot;&quot;;
    request.setAttribute(&quot;str&quot;,str);

    List list = new ArrayList();
    request.setAttribute(&quot;list&quot;,list);
%&gt;
$&#123;not empty str&#125;
$&#123;not empty list&#125;

&lt;h3&gt;EL传值&lt;/h3&gt;
&lt;%
request.setAttribute(&quot;name&quot;,&quot;张三&quot;);
session.setAttribute(&quot;name&quot;,&quot;李四&quot;);
request.setAttribute(&quot;age&quot;,&quot;19&quot;);
%&gt;
$&#123;requestScope.name&#125;
$&#123;requestScope.age&#125;
&lt;%--不指定域时依次从最小的域中查找是否有该键对应的值，直到找到为止。--%&gt;
$&#123;name&#125;
$&#123;sessionScope.name&#125;
</code></pre>
<p>运行结果：</p>
<p><img src="http://img.lbkzw.cn/img/20201101231746.png" alt="image-20201101231746003"></p>
<p>User.java</p>
<pre><code class="java">package cn.threecloth.el;

import java.text.SimpleDateFormat;
import java.util.Date;

public class User &#123;
    //逻辑视图
    private String name;
    private int age;
    private Date birthday;
    public String getBir()&#123;
        //格式化日期返回String日期数据
        if(birthday!=null)&#123;
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            return sdf.format(birthday);
        &#125;else &#123;
            return &quot;&quot;;

        &#125;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public Date getBirthday(Date date) &#123;
        return birthday;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public void setBirthday(Date birthday) &#123;
        this.birthday = birthday;
    &#125;
&#125;
</code></pre>
<p>##获取值</p>
<blockquote>
<p> el表达式只能从域对象中获取值.    </p>
</blockquote>
<p><code>$&#123;域名称.键名&#125;</code>：从指定域中获取指定键的值.</p>
<p>如果不指明域，那么将依次从最小的域中查找是否有该键对应的值，直到找到为止。如：<code> $&#123;键名&#125;</code></p>
<ul>
<li>域名称：<ol>
<li>pageScope        –&gt; pageContext</li>
<li>requestScope     –&gt; request</li>
<li>sessionScope     –&gt; session</li>
<li>applicationScope –&gt; application（ServletContext）</li>
</ol>
</li>
</ul>
<pre><code class="jsp">&lt;%
    User user = new User();
    user.setAge(19);
    user.setName(&quot;张三&quot;);
    user.setBirthday(new Date());
    request.setAttribute(&quot;user&quot;,user);

    List list = new ArrayList();
    list.add(&quot;aaa&quot;);
    list.add(&quot;bbb&quot;);
    list.add(&quot;ccc&quot;);
    request.setAttribute(&quot;list&quot;,list);

    Map map = new HashMap();
    map.put(&quot;name&quot;,&quot;张三&quot;);
    map.put(&quot;user&quot;,user);
    map.put(&quot;list&quot;,list);

    request.setAttribute(&quot;map&quot;,map);
%&gt;
&lt;h3&gt;el获取对象中的值&lt;/h3&gt;
&lt;%--
    * 通过的是对象的属性来获取
        * setter或getter方法，去掉set或get，在将剩余部分，首字母变为小写。
        * setName --&gt; Name --&gt; name
--%&gt;
$&#123;user.bir&#125;&lt;br&gt;
&lt;%--指定作用域获取值--%&gt;
$&#123;requestScope.user.age&#125;&lt;br&gt;
$&#123;requestScope.user.name&#125;&lt;br&gt;
&lt;h3&gt;获取list集合中的值&lt;/h3&gt;
$&#123;list&#125;&lt;br&gt;
$&#123;list[0]&#125;&lt;br&gt;
$&#123;list[1]&#125;&lt;br&gt;
$&#123;list[2]&#125;&lt;br&gt;
&lt;h3&gt;获取map集合中的值与对象&lt;/h3&gt;
$&#123;map.name&#125;
$&#123;map.user&#125;
$&#123;map.user.age&#125;
$&#123;map.list[0]&#125;
&lt;h3&gt;动态获取虚拟目录&lt;/h3&gt;
$&#123;pageContext.request.contextPath&#125;
</code></pre>
<p>运行结果：</p>
<img src="http://img.lbkzw.cn/img/20201101232011.png" alt="image-20201101232011676" style="zoom:50%;" />

<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><blockquote>
<p>用于简化和替换jsp页面上的java代码</p>
</blockquote>
<pre><code class="jsp">
&lt;%
    List list = new ArrayList();
    list.add(new User(&quot;张三&quot;,23,new Date()));
    list.add(new User(&quot;李四&quot;,18,new Date()));
    list.add(new User(&quot;王五&quot;,19,new Date()));
    request.setAttribute(&quot;list&quot;,list);
%&gt;
&lt;table border=&quot;1&quot; width=&quot;500&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;编号&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;年龄&lt;/th&gt;
        &lt;th&gt;生日&lt;/th&gt;
    &lt;/tr&gt;
    &lt;c:forEach  var=&quot;user&quot; varStatus=&quot;s&quot; items=&quot;$&#123;list&#125;&quot;&gt;
        &lt;%--foreach:相当于java代码的for语句--%&gt;

        &lt;c:if test=&quot;$&#123;s.count % 2 != 0&#125;&quot;&gt;
           &lt;%--if:相当于java代码的if语句,test中写布尔表达式--%&gt;
            &lt;%--如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容--%&gt;
            &lt;tr bgcolor=&quot;red&quot;&gt;
                &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;user.bir&#125;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:if&gt;
        &lt;c:if test=&quot;$&#123;s.count % 2 == 0&#125;&quot;&gt;
            &lt;tr  bgcolor=&quot;green&quot;&gt;
                &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;user.bir&#125;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:if&gt;
    &lt;/c:forEach&gt;
</code></pre>
<pre><code class="jsp">&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;
&lt;%@ page import=&quot;java.util.List&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;%--引入jsl表达式包--%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
    List list = new ArrayList();
    list.add(&quot;aaa&quot;);
    list.add(&quot;bbb&quot;);
    list.add(&quot;ccc&quot;);
    request.setAttribute(&quot;list&quot;,list);
    request.setAttribute(&quot;number&quot;,4);
%&gt;
&lt;%--取出域中集合的值--%&gt;
&lt;c:if test=&quot;$&#123;not empty list&#125;&quot;&gt;
    $&#123;list[0]&#125;
&lt;/c:if&gt;
&lt;br&gt;
&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt;
    第$&#123;s.count&#125;次遍历&amp;nbsp;当前索引$&#123;s.index&#125;&amp;nbsp;当前值$&#123;str&#125;&amp;nbsp;当前状态$&#123;s&#125;
    &lt;br&gt;
&lt;/c:forEach&gt;
&lt;hr&gt;
&lt;%--
属性：
begin：开始值
end：结束值
var：临时变量
step：步长
varStatus:循环状态对象
index:容器中元素的索引，从0开始
count:循环次数，从1开始
items:容器对象
&lt;%--判断奇偶--%&gt;
&lt;br&gt;
&lt;c:if test=&quot;$&#123;number%2==0&#125;&quot;&gt;
    $&#123;number&#125;为偶数
&lt;/c:if&gt;
&lt;c:if test=&quot;$&#123;number%2!=0&#125;&quot;&gt;
    $&#123;number&#125;为奇数
&lt;/c:if&gt;
&lt;HR color=#987cb9 SIZE=1&gt;
&lt;h3&gt;switch&lt;/h3&gt;
    &lt;%--choose:相当于java代码的switch语句
        1. 使用choose标签声明                     相当于switch声明
        2. 使用when标签做判断                     相当于case
        3. 使用otherwise标签做其他情况的声明        相当于default--%&gt;
&lt;c:choose&gt;
&lt;%--    以下相当于case ：--%&gt;
    &lt;c:when test=&quot;$&#123;number==1&#125;&quot;&gt;星期一&lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;number==2&#125;&quot;&gt;星期二&lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;number==3&#125;&quot;&gt;星期三&lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;number==4&#125;&quot;&gt;星期四&lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;number==5&#125;&quot;&gt;星期五&lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;number==6&#125;&quot;&gt;星期六&lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;number==7&#125;&quot;&gt;星期日&lt;/c:when&gt;
&lt;%--以下相当于default    --%&gt;
    &lt;c:otherwise&gt;
        输入数字有误
    &lt;/c:otherwise&gt;
&lt;/c:choose&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#006674>
                Java
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Jsp" style=color:#6484be>
                Jsp
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-Jsp-01/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/3/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/2">
                <span class="page-num">
                    2
                </span>
            </a>
            

            
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
        </span>
        

        <span class="current">
            4
        </span>

        
        <span>
            <a href="/page/5/">
                <span class="page-num">
                    5
                </span>
            </a>
            
            <a href="/page/6">
                <span class="page-num">
                    6
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/5/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>