
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/20/js-03/">
        <h2>
            JS函数
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>函数方法（方法体同声明均提升到顶部位置）</p>
<pre><code class="JavaScript">function printprops(o)&#123;
            for(var p in o)&#123;
                console.log(p + &quot;:&quot; + o[p] + &quot;\n&quot;);

            &#125;
        &#125;//返回nudefined
</code></pre>
<p>函数表达式（方法体原地保留、仅提前声明）</p>
<pre><code class="javascript">        var f = function(x)&#123;return x*x;&#125;//适合做只用一次的函数
</code></pre>
<p>函数中声明的变量仅在函数体内可见，因此可用函数来声明局部变量（也可通过let方法声明局部块）</p>
<pre><code class="javascript">        (function()&#123;/*局部变量*/&#125;());//结束并立即调用函数
</code></pre>
<p>函数是特殊的对象，所以也可拥有属性、方法，还可使用Function构造函数对象</p>
<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><ul>
<li><p>省略的实参都是undefined，多出的参数自动省略</p>
</li>
<li><p>函数可赋值给变量、存储在数组、对象属性中（称为方法），还可作为参数传入另一函数</p>
<pre><code class="javascript">/**函数赋值于变量*/
function square(x)&#123;return x*x;&#125;
var s = square;
/**函数作为对象属性，此时叫方法*/
var o=&#123;square:function(x)&#123;return x*x;&#125;&#125;;
/*函数存储在数组中*/
var a = [function(x)&#123;return x*x;&#125;,20];
a[0](a[1]);//看似nb的直接量调用a0的括号中装上a1，哈哈
</code></pre>
</li>
<li><p>内部函数可使用外部函数的参数和变量</p>
<pre><code class="javascript">function hypotenuse(a,b)&#123;
            function square(x)&#123;return x*x;&#125;
            return Math.sqrt(square(a)+square(b))
    //调用square函数时，传入了外部函数的a,b参数
        &#125;
</code></pre>
</li>
</ul>
<h2 id="函数作为对象方法"><a href="#函数作为对象方法" class="headerlink" title="函数作为对象方法"></a>函数作为对象方法</h2><pre><code class="js">var o =&#123;
            m:function()&#123;//函数作为对象方法
                var self = this;//指代对象O
                console.log(this====o);
                f();
                function f()&#123;//嵌套函数
                    console.log(this===o);//这里的this不是O
                    console.log(self===o);
                &#125;
            &#125;
        &#125;;
        o.m();
</code></pre>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><pre><code class="javascript">var o = new Object();//无参数构造函数
var o = new Object;//无参数构造函数
</code></pre>
<h1 id="实参对象"><a href="#实参对象" class="headerlink" title="实参对象"></a>实参对象</h1><ul>
<li><p>arguments标识符指向实参对象引用</p>
<pre><code class="javascript">function f(x)&#123;
            console.log(x);
            arguments[0]=null;//修改参数x
            console.log(x);
        &#125;
</code></pre>
<h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><ul>
<li><p>指代当前执行的函数</p>
<pre><code class="javascript">    var factorial = function(x)&#123;
            if(x&lt;=1)return 1;
            return x*arguments.callee(x-1);//递归调用
        &#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>接收任意数量的实参</p>
<pre><code>function max(/*number...*/)&#123; &#125;
</code></pre>
</li>
</ul>
<h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><pre><code class="javascript">uniquelnteger.counter = 0;//为函数属性设置初始值
function uniquelnteger()&#123;
    return uniquelnteger.counter++;
&#125;
/**作为数组储存*/
function factorial(n)&#123;
            if(isFinite(n)&amp;&amp;n&gt;0&amp;&amp;n===Math.round(n))&#123;
                if(!(n in factorial))//判断n在不在
                factorial[n]=n*factorial(n-1);//计算并存储a
                return factorial[n];
            &#125;else return NaN;
        &#125;factorial[1]=1
</code></pre>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><pre><code class="javascript">var scope = &quot;global scope&quot;;
        function checkscope()&#123;
            var scope = &quot;local scope&quot;;
            function f()&#123;return scope;&#125;
            return f();
        &#125;
        checkscope();//返回局部变量值local scope

/**************类似java对象之间的闭包性*******************/
function counter()&#123;
            var n = 0;
            return&#123;
                count:function()&#123;return n++;&#125;,
                reset:function()&#123;n = 0;&#125;
            &#125;;
        &#125;
        var c = counter(),d = counter();//即分别创建两个作用域链
        c.count(),d.count();//初始值都是0，调用后+1
        c.reset();//重置c为0，对其中一个作用域lian
        c.count(),d.count();//c-0 ，d-1
/*******************实现存取器***************/
//用参数n保存变量值
function counter(n)&#123;
    return&#123;
        get count()&#123;return n++;&#125;,
        set count(m)&#123;
            if(m&gt;=n)n=m;
            else throw Error(&quot;count can only be set to a larger value&quot;);
        &#125;
    &#125;;
&#125;
var c = counter(1000);
c.count;
c.count;//访问（读）操作
c.count = 2000;//写操作

/********访问实例：********/
/*错误的闭包示范*/
        function constfuncs()&#123;
            var funcs=[];
            for(var i=0;i&lt;10;i++)
            funcs[i]=function()&#123;return i;&#125;;//闭包内的i是同一个i，即最终i=10
            return funcs;//最终返回10
        &#125;
        var funcs=constfuncs();
        funcs[5]()//10
/*正确的闭包示范*/    
        function constfuncs(v)&#123;return function()&#123;return v;&#125;;&#125;
        var funcs =[];
        for(var i = 0 ;i&lt;10; i++)funcs[i]=constfuncs(i);//在闭包外每个i都是不同的i
        funcs[5]()//5
</code></pre>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call( ),apply( )"></a>call( ),apply( )</h2><pre><code class="javascript">f.call(o);//以对象o的方法形式调用函数f
f.apply(o);
f.call(o ,1,2)//以对象o的方法形式调用函数f，并传入参数
f.apply(o,[1,2]);
</code></pre>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind( )"></a>bind( )</h2><ul>
<li><p>绑定，一个函数调用bind( )方法，并传入一个对象，那么bind( )方法会返回一个新的函数，调用新的函数即可把原函数当作传入对象的方法来使用</p>
<pre><code class="javascript">function f(y)&#123;return this.x+y;&#125;;//函数
var o =&#123;x:1;&#125;;//对象
var g = f.bind(o);//新函数
g(2);//调用新函数
</code></pre>
</li>
</ul>
<h1 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li>每次调用**Function( )**就会创建新对象</li>
</ul>
<pre><code class="javascript">var f = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x*y&quot;);
//等同于 var f=function(x,y)&#123;return x*y&#125;
</code></pre>
<ul>
<li>Function( )构建对象的函数体编译会在顶层函数（全局作用域）进行</li>
</ul>
<pre><code class="javascript">var scope = &quot;hello&quot;;
function a()&#123;
var scope = &quot;world&quot;;
return new Function(&quot;return scope&quot;);
&#125;
a()();//返回hello
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#016a99>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/js-03/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/js-04/">
        <h2>
            JS对象
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><ul>
<li>字符串、布尔值、数字等可通过包装器，构造一个临时对象</li>
<li>必要时，js会进行包装器与字符串、数字、布尔值的相互转换</li>
</ul>
<pre><code class="js">var a = &quot;hello&quot;;
var word = a.substring(a.indexOf(&quot;&quot;)+1,a.length);//结果word=ello
//substring() 方法用于提取字符串中介于两个指定下标之间的字符。
//indexOf() 方法返回某个指定的字符串值在字符串中首次出现的位置。
</code></pre>
<h1 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h1><pre><code class="js">/*像py里的字典*/
var book =&#123;
    &quot;main title&quot;:&quot;The Definitive Guide&quot;,
    &quot;author&quot;:&quot;David Flanagan&quot;
&#125;;
//对象直接量的原型为constructor.prototype
</code></pre>
<h1 id="new创建对象"><a href="#new创建对象" class="headerlink" title="new创建对象"></a>new创建对象</h1><pre><code class="js">var mydate = new Date();//new+构造函数创建对象 
</code></pre>
<h1 id="删除、查询、添加、继承"><a href="#删除、查询、添加、继承" class="headerlink" title="删除、查询、添加、继承"></a>删除、查询、添加、继承</h1><pre><code class="js">/*添加、查询对象属性 */
 var customer=&#123;a1:&quot;1&quot;,a2:&quot;2&quot;,a3:&quot;3&quot;&#125;
 var addr=&quot;&quot;;
 for(i=0;i&lt;4,i++)&#123;//拼接customer属性
     addr+=customer[&quot;a&quot;+i]+&#39;\n&#39;
 &#125;
 customer.a4 =&#39;4&#39;;//为customer创建一个名为a4的属性，值为4
 customer[a5]=&quot;5&quot;//为customer创建一个名为a5的属性，值为5
 var mynumber =customer.a4;//查询customer的a4属性，并将其赋值于此变量
/*继承对象、删除对象属性*/
 var o = &#123;&#125;
 o.x = 1;
 var p = inherit(o);//继承对象，包含其toString方法与属性
 p.y = 2;
 delete p.x;//delete无法删除对象继承的属性，可直接在其父上操作 delete o.x;
 var q = inherit(p);
 q.z = 3;
 var s = q.toString();
/*delete:用来删除对象属性（包含数组元素），也可删除未使用var声明的变量包含（this.的全局变量）*/
</code></pre>
<h1 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h1><ul>
<li><p>读取、写入、可枚举、可配置</p>
</li>
<li><p>只有getter方法，就是只读属性</p>
</li>
<li><p>只有setter方法 ，就是只写属性  </p>
</li>
</ul>
<pre><code class="js">/*直接定义存储器属性*/
var random = &#123;
    get octet()&#123;
        return Math.floor(Math.random() *256);
    &#125;,
    get uint16()&#123;
        return Math.floor(Math.random() *65536);
    &#125;,
    get int16()&#123;
        return Math.floor(Math.random() *65536)-32768;
    &#125;
&#125;;
</code></pre>
<pre><code class="js">/*老式api*/
__lookupGetter__(),__lookupSetter__()//返回属性的getter与setter方法；
__defineSetter__(),__defineGetter__()//定义属性的getter与setter方法；//有两个参数，第一个为属性名字，第二个是getter与seeter方法
</code></pre>
<h2 id="设置属性特性"><a href="#设置属性特性" class="headerlink" title="设置属性特性"></a>设置属性特性</h2><p><strong>属性特性</strong>  包括：值、可写性、可枚举性、可配置性，分别对应：value,writable,enumerable,configurable</p>
<pre><code class="js">/**
 * 设置属性特性
 */
/*单个 */
var o =&#123;&#125;;
Object.defineProperty(o,&quot;x&quot;,&#123;value:1,writable:true,enumerable:false,configurable:true&#125;);
//Object.defineProperty方法修改自己已有属性或创建自有属性，不可修改继承属性
Object.keys(o);//将o.x属性变为只读
o.x =2 ;//操作失败
Object.defineProperty(o,&quot;x&quot;,&#123;value:2&#125;);

/*多个 */
var p = Object.defineProperties(&#123;&#125;,&#123;x:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,
    y:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,
    r:&#123;get:function()&#123;return Math.sqrt(this.x*this.x+this.y*this.y)&#125;,
enumerable:true,configurable:true&#125;
&#125;);



/*复制属性特性 */
Object.defineProperty(Object.prototype,&quot;extend&quot;,
/*定义Object.prototype.extend*/
&#123;writable:true,enumerable:false,configurable:true,value:function(o)&#123;
    var names = Object.getOwnPropertyNames(o);//得到所有自由属性包括不可枚举属性
    for (var i = 0; i&lt; names.length; i++)&#123;
        if(names[i]in this)continue;//如果属性已存在，则跳过
        var desc = Object.getOwnPropertyDescriptor(o,names[i]);//为this创建一个属性
        Object.defineProperty(this,names[i],desc);
    &#125;
&#125;&#125;);
</code></pre>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><ul>
<li>获取对象的属性描述</li>
</ul>
<pre><code class="js">对于继承属性与不存在属性均返回undefined
</code></pre>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><ul>
<li>修改已创建对象的属性特性，不能修改继承属性</li>
</ul>
<pre><code class="js">/*用法：Object.defineProperty(操作对象，属性名，&#123;属性描述符对象：value,writable,enumerable,configurable&#125;)*/
var o =&#123;&#125;;
Object.defineProperty(o,&quot;x&quot;,&#123;value:1,writable:true,enumerable:false,configurable:true&#125;);//为对象O创建一个不可枚举的属性x
//修改或创建完成后返回新的对象
</code></pre>
<h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><ul>
<li>同时修改多个对象属性特性，不能修改继承属性</li>
</ul>
<pre><code class="js">var p = Object.defineProperties(&#123;&#125;,&#123;x:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,//p是一个空对象
                                    /*为其创建x，y，r属性*/
    y:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,
    r:&#123;get:function()&#123;return Math.sqrt(this.x*this.x+this.y*this.y)&#125;,
enumerable:true,configurable:true&#125;
&#125;);
</code></pre>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul>
<li>通过对象直接量创建的对象使用Object.prototype作为它们的原型</li>
<li>new创建的对象，prototype作为其原型</li>
<li>Object.create()创建的对象，使用第一个参数作为其原型（可以是null）</li>
</ul>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><ul>
<li>创建</li>
</ul>
<pre><code class="js">var p =&#123;x:1&#125;;
var o =Object.create(p);//使用原型p创建对象o
p.isPrototype(o)//o继承至p?
Object.prototype.isPrototypeOf(o)//P继承至Object.prototype？
</code></pre>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><ul>
<li>查询对象原型</li>
</ul>
<pre><code class="js">var a = &#123;&#125;;
Object.getPrototypeOf(a);
</code></pre>
<h1 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h1><ul>
<li>是否可以添加、删除属性；</li>
</ul>
<pre><code class="js">/*将对象传入*/
Object.esExtensible()//判断对象是否可扩展
Object.isSealed()//检测对象是否封闭（不可扩展）
Object.prevenExtensions()//将对象自身转换为不可扩展的（此操作不可逆），其原型添加属性时此对象仍会继承这些属性
Object.seal()//与Object.prevenExtensions()类似
Object.freeze()//冻结：不可扩展且数据属性设置为只读（setter存储器属性不受影响）
Object.isFrozen();//检测是否冻结
/*创建一个封闭（不可扩展）对象，包含一个冻结原型一个不可枚举属性*/
var o = Object.seal(Object.create(Object.freeze(&#123;x:1&#125;),&#123;y:&#123;value:2,writable:true&#125;&#125;));
</code></pre>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><pre><code class="js">/*序列化对象 */
o = &#123;x:1,y:&#123;z:[false,null,&quot;&quot;]&#125;&#125;;
s = JSON.stringify(o);//序列化对象o（转换为字符串）
p = JSON.parse(s);//还原为对象,p是深度复制
</code></pre>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#006674>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/js-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/js-05/">
        <h2>
            JS数组
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>Js数组是无类型的，其元素可以为任意类型，也可以是任意对象或数组；</p>
<p>Js数组是动态的，无需声明其大小，数组长度会根据需要增长与缩减；</p>
<p>省略的数组直接量将被赋予undefined值；</p>
<p>数组是对象的特殊形式，所以其可以从原型中继承元素，可以定义元素的getter与setter方法；数组的索引是对象属性名的特殊类型。</p>
<pre><code class="js">var b = [1,,3]//索引1处值即为undefined
var c = [,];//空数组，因为数组直接量结尾处的“,”可选加与不加，数组中只有1个“,”时默认为是结尾处的“,”
var d = [];//空数组
var d = new Array(10);//利用Array()构造函数创建一个预分配大小的数组。
</code></pre>
<pre><code class="js">/*负值与非整数的数组索引，将被转换为字符串，字符串作为属性名使用*/
var a = [3.1415926] = pi;
var b = [-180] = deg;
</code></pre>
<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><pre><code class="js">a = new Array(5);//a为空数组，但其长度为5
b = [];
b[1000] = 122;//添加一个元素，数组长度为1001
/*length属性小于当前长度时，超出length值-1的元素将被删除。*/
b.length = 999;//此时数组为空。
/*让数组变为只读*/
c = [1,2,3];
Object.defineProperty(a,&quot;length&quot;,&#123;writable:false&#125;)//将length属性设置为不可写
</code></pre>
<h1 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h1><p>栈、队列、双端队列的实现。</p>
<h2 id="push-unshift"><a href="#push-unshift" class="headerlink" title="push(),unshift()"></a>push(),unshift()</h2><blockquote>
<p>**push()**在尾部添加元素;</p>
<p>**unshift()**在头部添加元素.</p>
</blockquote>
<pre><code class="js">a = [];
a.push(&quot;pu&quot;);//与直接量添加a[a.length]=&quot;pu&quot;;效果相同
a.unshift(&quot;d&quot;,&quot;j&quot;);//unshif插入元素是一次性插入的，所以不会影响顺序
/*delete可删除数组元素（数组是特殊对象），但不改变其长度*/
delete a[0];
</code></pre>
<h2 id="pop-shift"><a href="#pop-shift" class="headerlink" title="pop(),shift()"></a>pop(),shift()</h2><ul>
<li><p>栈的实现（配合push()）：pop() 减少数组1长度（即删除末尾元素），并返回被删除的元素值</p>
</li>
<li><p>队列的实现（配合unshift()）：shift()从头部删除一个元素，并将被删除元素以后的元素索引减一（队列，所有人向前走一步）</p>
</li>
</ul>
<p><strong><em>双端队列：push(),unshift() pop(),shift()实现。</em></strong></p>
<h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><ul>
<li>一般，调用的函数作为forEach第一个参数，调用函数一般提供3个参数：数组元素、元素索引、数组本身</li>
<li>forEach只能利用”异常“机制终止遍历</li>
</ul>
<pre><code class="js">var data = [1,2,3,4,5,];
var sum = 0;
data.forEach(function(value)&#123;sum+=value;&#125;);//求和
data.forEach(function(v,i,a)&#123;a[i]=v+1;&#125;);//每个元素+1
/*终止遍历*/
function foreach(a,f,t)&#123;
    try&#123;a.forEach(f,t);&#125;
    catch(e)&#123;if(e===foreach.break)return;else throw e;&#125;
&#125;
foreach.break = new Error(&quot;Stoplteration&quot;);
</code></pre>
<h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul>
<li>将数组组成字符串返回</li>
</ul>
<pre><code class="js">/*join */
var a = [1,2,3,4]
a.join();//默认以“,”分隔
a.join(&#39;_&#39;);//自定义元素分隔(_)
/*split */
var b = &quot;hello World&quot;
var c =b.split(正则表达式或字符串);//将字符串分割为若干块并创建一个数组
</code></pre>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><ul>
<li>逆序数组元素（直接在原数组中排序），并返回排序后的数组</li>
</ul>
<pre><code class="js">var a = [1,2,3,4]
a.reverse()
</code></pre>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><ul>
<li>默认以字母顺序进行排序，且返回排序后的数组</li>
<li>undefined 元素会被排列到尾部</li>
<li>自定义排序：sort接受一个比较函数，该函数有两个比较参数，返回小于0的值则第一个参数在前，反之第二个参数在前。</li>
</ul>
<pre><code class="js">/*排列数值*/
var a = [12,574,88,78];
a.sort();
a.sort(function(a,b)&#123;return a-b;&#125;)
/*排列字符串且不区分大小写*/
a = [&#39;ant&#39;,&#39;Bug&#39;,&#39;cos&#39;]
a.sort(function(s,t)&#123;var a = s.toLowerCase();var b = t.toLowerCase();
if(a&lt;b)return -1;//写小于0的任意值
if(a&gt;b)return 1;//写大于0的任意值
return 0;//相等返回0
&#125;);
</code></pre>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><ul>
<li>创建并返回新的数组</li>
<li>如果其参数中包含某个数组则添加其元素，创建并返回新的数组</li>
</ul>
<pre><code class="js">var a = new Array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);
var b = new Array(&#39;1f&#39;,&#39;2f&#39;,&#39;3f&#39;);
a.concat(4,5,6,b);//a = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 4, 5, 6, &quot;1f&quot;, &quot;2f&quot;, &quot;3f&quot;];
</code></pre>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><ul>
<li>返回数组参数指定位置的片段或子数组</li>
</ul>
<pre><code class="js">var a = new Array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);
a.slice(0,2)//返回[&quot;1&quot;, &quot;2&quot;]，返回第一个参数位置（包含第一个位置）到第2个参数位置前的子数组。
</code></pre>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><ul>
<li>插入或删除数组元素，并返回一个包含已删除元素的数组。</li>
<li>第一个参数指定了插入或删除的位置，第二个参数指定了删除元素的数量（若是添加则此参数填0）</li>
</ul>
<pre><code class="js"> var a =[1,32,95,98,6,,78];
 a.splice(2, 0,&#39;f1&#39;);//删除0个在索引2前插入&#39;f1&#39;
 a.splice(4,1,[1,5,,6],&#39;j&#39;);//在索引4出删除1个元素并插入一个数组[1,5,,6]与一个元素&#39;j&#39;
</code></pre>
<h2 id="toString与toLocaleString"><a href="#toString与toLocaleString" class="headerlink" title="toString与toLocaleString"></a>toString与toLocaleString</h2><ul>
<li>toString将每个元素转换为字符串，并输出用逗号分隔的字符串列表。</li>
<li>toLocaleString使用“本地化“版本的toString，将元素转换为字符串并分隔（自定义）</li>
</ul>
<h1 id="Es-5数组方法"><a href="#Es-5数组方法" class="headerlink" title="Es 5数组方法"></a>Es 5数组方法</h1><p>大多数方法第一个参数接收一个函数，并对数组中每个元素调用一次该函数；</p>
<p>对于稀疏数组中不存在的元素（undefined），不调用传递函数；</p>
<p>调用函数一般提供3个参数：数组元素、元素索引、数组本身。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>将数组的所有元素传递给指定函数，并返回一个包含该函数返回值的数组</li>
</ul>
<pre><code class="js">var a = [1,5];
var b = a.map( function(x)&#123; return x*x;&#125;);//返回的是新数组哦
</code></pre>
<h2 id="fileter"><a href="#fileter" class="headerlink" title="fileter"></a>fileter</h2><ul>
<li>返回数组元素的子集</li>
<li>只返回稠密数组（自动跳过稀疏数组中为空的元素）</li>
</ul>
<pre><code class="js">/*返回子集 */
var a= [1,5,98,8];
var b = a.filter(function(x)&#123;return x&gt;5;&#125;);//过滤
var c = a.filter(function(x,y)&#123;return y%2==0;&#125;);

/*压缩空缺*/
var a = a.filter(function(x)&#123;return x!==undefined &amp;&amp; x!=null;&#125;);
</code></pre>
<h2 id="every与some"><a href="#every与some" class="headerlink" title="every与some"></a>every与some</h2><ul>
<li><p>对数组元素按照指定的函数进行判定，返回布尔值</p>
</li>
<li><h4 id="every针对所有元素，some仅当一些元素"><a href="#every针对所有元素，some仅当一些元素" class="headerlink" title="every针对所有元素，some仅当一些元素"></a>every针对所有元素，some仅当一些元素</h4></li>
<li><p>一旦every与some确定结果，遍历便停止了</p>
<pre><code class="js">var a =[1,5,8,,9];
a.every(function(x)&#123;return x &lt; 5 ;&#125;);//数组中全部元素大于5？否，返回false
a.some(function(x)&#123;return x &lt;5;&#125;);//数组中有元素大于5？yes，返回false
</code></pre>
</li>
</ul>
<h2 id="reduce与reduceRight"><a href="#reduce与reduceRight" class="headerlink" title="reduce与reduceRight"></a>reduce与reduceRight</h2><ul>
<li>reduce 使用指定函数使数组元素相互结合，其有两个参数第一个是“到目前为止操作的结果”，第二个是初始值。（可不写初始值，默认数组第一个元素为初始值）</li>
</ul>
<pre><code class="js">var a = [1,2,5]
var sum = a.reduce(function(x,y)&#123;return x+y&#125;，2)//sum =8
var sum = a.reduce(function(x,y)&#123;return x+y&#125;)//sum =10
</code></pre>
<ul>
<li>reduceRight和reduce操作相同，但其从右到左处理数组</li>
</ul>
<h2 id="indexOf-与-lastIndexOf"><a href="#indexOf-与-lastIndexOf" class="headerlink" title="indexOf 与 lastIndexOf"></a>indexOf 与 lastIndexOf</h2><ul>
<li>依照给定的值在数组中搜索元素，返回找到的第一个元素，不存在则返回-1</li>
<li>indexOf从头开始搜索 lastIndexOf从尾开始搜索</li>
<li>第一个参数是要搜索的值，第二个参数（可省略）指定从哪个索引开始搜索</li>
</ul>
<pre><code class="js">function findall(a,x)&#123;//传入数组与将要查找的值
    var results = [],len = a.length,pos = 0;//
    while(pos&lt;len)&#123;pos = indexOf(x,pos);//从索引o开始搜索
    if(pos===-1)break;results.push(pos);pos +=1;//找不到结束；否则在数组results中存储索引，继续搜索
&#125;
return results;
&#125;
</code></pre>
<h1 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h1><ul>
<li>类数组对象没有继承自Array.prototype,但其仍可使用Function.call方法调用数组方法</li>
</ul>
<pre><code class="js">var a = &#123;&quot;0&quot;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3&#125;
Array.prototype.join.call(a,&quot;+&quot;)//调用join方法
Array.prototype.slice.call(a,0)//调用slice方法
Array.prototype.map.call(a,function(x)&#123;return x.toLowerCase();&#125;)//调用map方法
</code></pre>
<h1 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h1><ul>
<li><strong>charAt</strong> 方法可用来访问单个字符(即可对字符串采取索引访问操作)</li>
<li>数组的通用操作也适用于字符串</li>
</ul>
<pre><code class="js">var a = &quot;hello!&quot;
a.charAt(2)//返回&#39;l&#39;
Array.prototype.filter.call(a,function(x)&#123;return x.match(/[^aeiou]/);&#125;)//只匹配非元音字符
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#607d8b>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/js-05/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/jvm-01/">
        <h2>
            运行时数据区域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><img src="https://i.loli.net/2020/07/30/eLwO5syKpnhjivJ.png" style="zoom:25%;" />



<ul>
<li><p>程序计数器：每个线程都有一个程序计数器，它指示当前线程所执行字节码的行号</p>
</li>
<li><p>Java虚拟机栈：每个方法执行时均会创建一个栈帧，其存储<strong>局部变量表</strong>（基本类型与对象引用）、操作数栈、动态连接、方法出口等信息</p>
</li>
<li><p>本地方法栈：与Java虚拟机栈类似，其<strong>为本地方法服务</strong></p>
</li>
<li><p>Java堆（GC堆）：在虚拟机运行时创建用以存放对象实例，且为所有线程共享。</p>
</li>
<li><p>方法区：存储已被虚拟机加载的类型信息、常量、静态变量、编译后的代码缓存等数据，且为所有线程共享。</p>
<ol>
<li>运行时常量池：属于方法区，在加载类后class文件中的常量池表（字面量、符号引用）将存入运行时常量池</li>
</ol>
</li>
<li><p>直接内存（不属于运行时数据区域）：基于通道与缓冲区的I/O方式，其使用Native函数库直接分配堆外内存，并通过存储在Java堆中的<em>DirectByteBuffer</em>对象作为这块内存的引用进行操作</p>
</li>
</ul>
<h1 id="为对象分配内存："><a href="#为对象分配内存：" class="headerlink" title="为对象分配内存："></a>为对象分配内存：</h1><ul>
<li><p>创建对象时，虚拟机首先检测这个类是否已被<strong>加载、解析、初始化</strong>，如没有则首先执行<strong>类的加载过程</strong>。</p>
</li>
<li><p>垃圾收集器的<strong>空间整理能力</strong>决定<strong>堆是否规整</strong></p>
</li>
</ul>
<h2 id="分配堆内存的两种方式："><a href="#分配堆内存的两种方式：" class="headerlink" title="分配堆内存的两种方式："></a>分配堆内存的两种方式：</h2><h3 id="指针碰撞："><a href="#指针碰撞：" class="headerlink" title="指针碰撞："></a>指针碰撞：</h3><ul>
<li><strong>Java堆内存是规整的</strong>，有一个指针其两边分别是已使用、未使用的堆内存，分配内存时把指针向未使用的一边挪动一段与对象大小相同的距离</li>
</ul>
<p><img src="https://i.loli.net/2020/07/30/tV7RKAgXQWTykm5.png"></p>
<h3 id="空闲列表："><a href="#空闲列表：" class="headerlink" title="空闲列表："></a>空闲列表：</h3><ul>
<li><strong>Java堆内存不是规整的</strong>，使用与未使用的堆内存纵横交错，需要使用一个列表记录未使用的堆内存，分配内存时从列表中找到一块足够大的堆内存分配给对象</li>
</ul>
<p><img src="https://i.loli.net/2020/07/30/KoeInBvdQrjkEYS.png"></p>
<h2 id="对象内存分配的细节"><a href="#对象内存分配的细节" class="headerlink" title="对象内存分配的细节"></a>对象内存分配的细节</h2><ul>
<li>为对象分配堆内存空间时为防止<strong>同一时间创建多个对象的内存分配冲突</strong>（对象A、B分配同一块内存），可采用以下两种操作：</li>
</ul>
<ol>
<li>上锁：为分配的内存空间进行同步处理</li>
<li>闭包（本地线程分配缓冲）：为每个线程预先分配一块内存</li>
</ol>
<ul>
<li>分配完堆内存后，虚拟机将堆内存初始化值为0（对象头除外）</li>
<li>对象内存分为3个部分：对象头、实例数据、对其填充</li>
</ul>
<h1 id="对象、方法区"><a href="#对象、方法区" class="headerlink" title="对象、方法区"></a>对象、方法区</h1><h2 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h2><ul>
<li>句柄访问：Java栈中reference存储对象的句柄地址，句柄中包含对象的实例、类型数据的地址信息</li>
<li><img src="https://i.loli.net/2020/08/19/XxgJA5zpeWqZFt6.jpg" alt="screenshot_2020_07_30T15_08_55+0800" style="zoom:50%;" /></li>
<li>直接指针访问：Java栈中reference直接存储对象地址<img src="https://i.loli.net/2020/08/19/YsgivyGItW4ALkH.jpg" alt="screenshot_2020_07_31T16_03_41+0800" style="zoom:50%;" /></li>
</ul>
<h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><ul>
<li><p>引用计数算法：每个对象都有一个引用计数器，每当被一个地方引用时计数器值便加一，每当失去一个引用计数器值便减一（不采用）</p>
</li>
<li><p>可达性分析算法：通过<strong>GCRoots</strong>根对象作为起点，根据引用关系向下搜索，构成一条<strong>引用链</strong>如果某个对象到<strong>GCRoots</strong>间没有任何引用链，那么这个对象就是可回收的。</p>
<img src="https://i.loli.net/2020/08/19/Jre7x8wUvLEchsP.jpg" alt="screenshot_2020_07_30T20_21_36+0800" style="zoom:50%;" />

</li>
</ul>
<h2 id="回收对象："><a href="#回收对象：" class="headerlink" title="回收对象："></a>回收对象：</h2><ul>
<li>可达性分析算法中可回收的对象并<strong>不会被立即回收</strong>，而是对其进行第二次筛选；</li>
<li>如此对象有覆盖finalize（）方法且此方法且未被虚拟机调用，则执行finalize（）方法，并将其放入F—Queue队列中（<strong>低优先级的Finalizer线程</strong>将执行finalize（）方法），在此期间如<strong>对象与引用链建立联系则不会被回收</strong>（如赋值、引用等）</li>
</ul>
<h2 id="回收方法区："><a href="#回收方法区：" class="headerlink" title="回收方法区："></a>回收方法区：</h2><ul>
<li>方法区的垃圾回收分为两部分，<strong>废弃的常量</strong>与<strong>不再使用的类型</strong>：</li>
</ul>
<ol>
<li>废弃的常量：一个常量<strong>不被引用</strong>，则这个常量将被从常量池中清除（接口、方法、字段符号与之类似）</li>
<li>不再使用的类型：需要满足以下3个条件方<strong>可被回收</strong>（而不是立即回收）<ul>
<li>该类不存在<strong>任何实例</strong>（实例均被回收）</li>
<li>加载该类的<strong>加载器</strong>已被回收</li>
<li>该类对应的<strong>class对象没有被引用</strong>，且<strong>无法通过反射</strong>访问该类的方法</li>
</ul>
</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Jvm虚拟机" style=color:#006674>
                Jvm虚拟机
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/jvm-01/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/5/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <a href="/page/5/">
                <span class="page-num">
                    5
                </span>
            </a>
        </span>
        

        <span class="current">
            6
        </span>

        

    </div>

    <div class="next">
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>