
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/20/shell-01/">
        <h2>
            Shell入门
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Ubuntu">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Ubuntu
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>变量分为用户变量与系统变量</li>
<li>为变量赋值时“=”号两边不能有空格</li>
<li>可在``中写入命令，并将其交给变量引用，也可采用：       变量=$(命令 )     达到相同的效果</li>
</ul>
<pre><code class="shell">#!/bin/bash  
#头文件，表明此脚本使用bash shell编写
echo &quot;hello,world!&quot; #打印字符串
echo &quot;PATH=$PATH&quot; #$表示变量引用，此处引用的是系统变量
echo &quot;user=$USER&quot;
A=100
echo &quot;A=$A&quot; #打印用户定义的变量
unset#扰乱，就是删除前一个变量的值
echo &quot;A=$A&quot;

RESULT=`ls -l /home`#这个变量引用一个命令ls -l /home
echo $RESULT #打印这个变量（命令运行的结果）
echo &quot;&quot;
MY_DATE=$(date)#这个变量引用一个命令date
echo &quot;data=$MY_DATE&quot;
</code></pre>
<h3 id="环境变量（全局变量）"><a href="#环境变量（全局变量）" class="headerlink" title="环境变量（全局变量）"></a>环境变量（全局变量）</h3><ul>
<li>在/etc/profile 文件中定义环境变量<code>TOMCAT_HOME=/opt/tomcat export TOMCAT_HOME</code>export将 shell 变量输出为环境变量</li>
<li>定义环境变量后使用<code>source /etc/profile</code>让其生效</li>
</ul>
<pre><code class="shell">#!/bin/bash
:&lt;&lt;!
注释代码块使用:&lt;&lt;!将要被注释的代码块!
echo &quot;hello,world!&quot;
echo &quot;PATH=$PATH&quot;
echo &quot;user=$USER&quot;
a=100
echo &quot;a=$a&quot;
unset
echo &quot;a=$a&quot;

RESULT=`ls -l /home`
echo $RESULT
echo &quot;&quot;
MY_DATE=$(date)
echo &quot;data=$MY_DATE&quot;
!
echo $TOMCAT_HOME
readonly B=10#静态变量无视unset
unset
echo $B       
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/28/ZEUp9VBFqQoKJGW.png" alt="image-20200728224210596"  /></p>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><pre><code class="shell">#!/bin/bash

echo $$#当前进程的进程号(PID)
./a.sh &amp; #执行此脚本，后台运行
echo $! #后台运行的进程号
echo $? #上一次执行命令返回的状态（0为正常，否则上一个命令没有正确执行）
~        
</code></pre>
<h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><pre><code class="shell">#!/bin/bash

echo &quot;$0 $1 $2&quot; #分别对应第 0 1 2个位置参数 ，0对应命令本身，如下图 参数1对应4、参数2对应5 
echo $* #所有位置参数（不包括位置0），将其作为整体对待
echo $@  #所有位置参数（不包括位置0），将其分别对待
echo $#    #所有位置参数个数（不包括位置0）
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/QHgrA1v4Y5lCZjT.png"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>3种书写形式：<ol>
<li><code>$((运算式))</code></li>
<li><code>$[运算式]</code></li>
<li><code>expr m + n</code> <code>expr m - n</code>   注意 expr 运算符间要有空格<br>  乘,除,取余：<code>expr \*, /, %</code></li>
</ol>
</li>
</ul>
<pre><code class="shell">#!/bin/bash
#注意运算符前后的空格，必须有哦
A=$((4 + 8))
B=$[4 * 8]
C=`expr 4 \* 8`
echo &quot;$A&quot;
echo &quot;$B&quot;
echo &quot;$C&quot;
</code></pre>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li>常用判断条件<ol>
<li>两个整数的比较<br>= 字符串比较<br>-lt 小于<br>-le 小于等于<br>-eq 等于<br>-gt 大于<br>-ge 大于等于-ne 不等于</li>
<li>按照文件权限进行判断<br>-r 有读的权限 [ -r 文件 ]<br>-w 有写的权限<br>-x 有执行的权限</li>
<li>按照文件类型进行判断<br>-f 文件存在并且是一个常规的文件<br>-e 文件存在<br>-d 文件存在并是一个目录</li>
</ol>
</li>
</ul>
<pre><code class="shell">#!/bin/bash
#比较字符串
if [ &quot;b&quot; = &quot;b&quot; ]
then
        echo &quot;Yes&quot;
fi
#比较数值
if [ 4 -eq 4 ]
then
        echo &quot;Yes&quot;
fi
#判断文件
if [ -d /home ]
then#满足条件执行：
        echo &quot;Yes&quot;       
fi #if反过来结尾
</code></pre>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>if elif </li>
</ul>
<pre><code class="shell">#!/bin/bash

if [ $0 = &quot;./a.sh&quot; ]#注意[ 之间的 ]空格
then
        echo &quot;Yes&quot;
elif [ $1 -eq 4 ]
then
        echo &quot;Yes&quot;
elif [ $2 = &quot;b&quot; ]
then
        echo &quot;Yes&quot;
fi
              
</code></pre>
<p>运行结果：</p>
<p><img src="https://i.loli.net/2020/07/30/PoYBhMnImCUqXJc.png"></p>
<ul>
<li>case</li>
</ul>
<pre><code class="shell">#!/bin/bash
case $1 in
&quot;1&quot;)
echo &quot;Yes&quot;;;
&quot;2&quot;)#位置参数1的值为2时执行
echo &quot;No&quot;;;
*)#以上所有条件都不满足则执行
echo &quot;All&quot;;;
esac#case反写作结尾                                                                                    
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/6OljZLWC3aex4tc.png"></p>
<ul>
<li><p>for</p>
<ol>
<li><p>for in</p>
<pre><code class="shell">#!/bin/bash

for i in &quot;$@&quot;
do
echo &quot;对单个进行处理=$i&quot;
done
echo &quot;&quot;
for i in &quot;$*&quot;
do
echo &quot;作为整体对待=$i&quot;
done#表示循环结束
~           
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/zZ9bsm1BAxUaDpg.png"></p>
</li>
<li><p>for常规</p>
<pre><code class="shell">#!/bin/bash

SUM=0#赋值运算符前后不能有空格
for((i=1;i&lt;=10000;i++))#for循环（（））中运算符的空格可有可无
do
SUM=$[$SUM+$i]#像这样两个变量与运算符直接有无空格均可
done
echo &quot;sum=$SUM&quot;
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/V9IDSofWYpbBCx4.png"></p>
</li>
</ol>
</li>
<li><p>while</p>
</li>
</ul>
<pre><code class="shell">#!/bin/bash

SUM=0
i=0
while [ $i -lt $1 ]#[]内外两边均有空格，需要注意。
do
SUM=$[$SUM+$i]
i=$[$i+1]
done
echo &quot;sum=$SUM&quot;                      
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/2aT39NuVMWvfQsw.png"></p>
<h2 id="从控制台读入"><a href="#从控制台读入" class="headerlink" title="从控制台读入"></a>从控制台读入</h2><pre><code class="shell">#!/bin/bash
read -p &quot;你是一个哈皮（Yes/No）?&quot; WHY#-p即附带提示，WHY保存输入值
echo &quot;$WHY&quot;

read -t 10 -p &quot;你是一个哈皮（Yes/No）?&quot; WHY#-t计时，超过定义的10s即停止输入
echo &quot;$WHY&quot;
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/aBqlR1KXzOfinP2.png"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>系统函数</p>
<ol>
<li><p>basename [string] [suffix]<br>删掉所有的前缀包括最后一个(‘/’)字符,然后将余下的字符串显示出来。<br>指定了suffix,basename命令会将指定的后缀也去掉</p>
</li>
<li><p>dirname<br>返回完整路径最后 / 的前面的部分</p>
</li>
</ol>
</li>
</ul>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/dieGZhJHgxpIqoW.png"></p>
<ul>
<li>自定义函数</li>
</ul>
<pre><code>#!/bin/bash
function getSum()&#123;#不用写参数
SUM=$[$2 + $1]
echo &quot;sum=$SUM&quot;
&#125;
getSum $1 $2#方法名后面是传入的参数
~                  
</code></pre>
<p>运行结果：<img src="https://i.loli.net/2020/07/30/i6Vl2WEH9ro31qS.png"></p>
<h2 id="GitHub自动提交远程库实例"><a href="#GitHub自动提交远程库实例" class="headerlink" title="GitHub自动提交远程库实例"></a>GitHub自动提交远程库实例</h2><p>shell的内容：</p>
<pre><code class="shell">#!/bin/bash

GITPATH=/home/garfield/文档 #本地仓库路径
ADD=$(git add .) #添加所有文件到暂存区
DATE=$(date +%y%m%d)
GITPUSH=$(git push blog master)#推送到远程库
GITPULL=$(git pull blog master)#同步远程库到本地（防止冲突）
cd $GITPATH
$ADD
git commit -m &quot;$DATE&quot;#提交到版本库并备注时间
$GITPULL
$GITPUSH
~         
~                
</code></pre>
<p>运行结果<img src="https://i.loli.net/2020/07/30/v6ble3USd8YIgpk.png"></p>
<p>定时任务内容：</p>
<pre><code>*20*** /home/garfield/文档/git_push.sh
</code></pre>
<p><img src="https://i.loli.net/2020/07/30/4okIgw3ZSYuJ7s8.png"> </p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/shell" style=color:#016a99>
                shell
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/shell-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/sql-01/">
        <h2>
            SQL基础
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/SQL">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                SQL
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="常见注释"><a href="#常见注释" class="headerlink" title="常见注释"></a>常见注释</h1><ul>
<li>– 很少支持</li>
<li>#行内注释</li>
<li>/**/段落注释</li>
</ul>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">作用</th>
<th align="center">例子</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">查找列，并返回行</td>
<td align="center">select prod_name from products；<br/>#可使用,分隔列名来查找多个列。</td>
<td>查找prod_name列，并返回其下的所有行，在products表中。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">通配符</td>
<td align="center">select * from products；</td>
<td>查找所有列并返回所有行，在products表中。</td>
</tr>
<tr>
<td align="center">distinct</td>
<td align="center">返回不重复的值</td>
<td align="center">select  distinct vend_id from products；<br/>#不可配合通配符使用除非所有列完全相同</td>
<td>查找vend_id列并返回其下所有行中不重复的值，在products表中。</td>
</tr>
<tr>
<td align="center">limit</td>
<td align="center">限制</td>
<td align="center">select prod_name from products limit 5,5;</td>
<td>查找prod_name列并返回其下第5行起5行的值，在products表中。</td>
</tr>
</tbody></table>
<h3 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h3><table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
<th>例子</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>order by</td>
<td>排序</td>
<td>select prod_id,prod_price,prod_name<br/>from Products<br/>order by 2;<br/>#默认升序（ASC）排列<br/>#指定按多个列排列时：仅当指定的第一列中有重复元素时，才对其（存在重复值的）按指定的下一列进行排序。</td>
<td>即按照查找的第二个列进行排序，也可指定列名（prod_price）</td>
</tr>
<tr>
<td>desc</td>
<td>降序</td>
<td>select prod_id,prod_price,prod_name<br/>from Products<br/>order by 2 DESC,3 desc;</td>
<td>即按照查找的第二个列进行降序排序，desc仅对其前的列有效；</td>
</tr>
</tbody></table>
<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
<th>例子</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>where</td>
<td>在客户端过滤数据</td>
<td>select *<br/>from Products<br/>where prod_price &gt;= 5.99<br/>order by prod_price desc;<br/>#同排序操作一同使用时，不得位于排序操作之前#支持&lt;&gt;=!=等操作，其中&lt;&gt;操作等同于!=<br/>例：<br/>select *<br/>from Products<br/>where prod_id &lt;&gt;’fc’<br/>order by prod_price desc;<br/>#过滤字符串不区分大小写</td>
<td>1.查找所有列，在Products表中，并返回prod_price &gt;=5.99的所有行<br/>2.查找所有列，在Products表中，并返回除prod_id = “fc”之外的所有行</td>
</tr>
<tr>
<td>between</td>
<td>值的范围过滤</td>
<td>select  prod_name,prod_price<br/>from Products<br/>where prod_price between 4 and 10</td>
<td>查找prod_name,prod_price两列在Products表中，并返回prod_price值为4-10范围内的的的所有行</td>
</tr>
<tr>
<td>is</td>
<td>可用来检查null（空值）</td>
<td>select  prod_name,prod_price<br/>from Products<br/>where prod_price is null</td>
<td>返回所有没有价格的商品</td>
</tr>
<tr>
<td>and,or</td>
<td>逻辑操作符<br/>and且<br/>or与，这里是短路的</td>
<td>select  *<br/>from Products<br/>where vend_vend_id =’1001’ and prod_price &lt;=4;<br/>#and的优先级比or要高，and，or共同使用时为避免错误应用（）明确分组，<br/>#也可使用in代替or，例：<br/>select prod_name,prod_price from products where vend_id in(‘1001’,’1002’)<br/>order by prod_name<br/>等同于：<br/>select prod_name,prod_price from products where vend_id = ‘1001’ or vend_id = ‘1002’<br/>order by prod_name</td>
<td>返回所有vend_vend_id =’1001’ 且 prod_price &lt;=4;的行</td>
</tr>
<tr>
<td>not</td>
<td>否定其后的条件</td>
<td>select prod_name,prod_price from products where not vend_id in(‘1001’,’1002’)<br/>order by prod_name</td>
<td>可与in连用，返回vend_id=1001 vend_id=1002外的所有行</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="通配符搜索"><a href="#通配符搜索" class="headerlink" title="通配符搜索"></a>通配符搜索</h3><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">匹配0、1或多个字符包含空格。不会匹配到null</td>
<td>select prod_name<br/>from products<br/>where prod_name like ‘f%%’</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">匹配单个字符，包含空格</td>
<td>select prod_name<br/>from products<br/>where prod_name like ‘fuse_’</td>
</tr>
<tr>
<td align="center">rtrim（）ltrim（）</td>
<td align="center">去除右边、左边空格</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<h4 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h4></blockquote>
<pre><code class="mysql">select prod_id ,quantity,item_price,quantity*item_price as expanded_price
from orderitems
where order_num = 20008;
#如上创建了一个expanded_price字段（quantity*item_price的结果的别名），其仅在此时有效而不会存放到表中。
</code></pre>
<blockquote>
<h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4></blockquote>
<pre><code class="mysql">select vend_name, upper(vend_name) as vend_name_upcase
from vendors
#将vend_name列下的所有行以大写形式返回
select avg(prod_price) as avg_peice from products where vend_id =&#39;1001&#39;
#返回平均值
select count(*) as num_cust from customers
#返回长度（数目），也可对列表中特定值进行计数
</code></pre>
<blockquote>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4></blockquote>
<pre><code class="mysql">select  vend_id,count(*) as num_prods from  products #对vend_id每行进行计数
group by vend_id;#按照vend_id排序并分组

select cust_id,count(*) as orders
from orders 
group by cust_id 
having count(*)&gt;=2#过滤分组中&gt;=2的，having支持where的所有操作

select order_num,count(*) as items
from orderitems group by order_num
having count(*) &gt;=3
order by items,order_num desc#对分组依照选定的列进行排序
</code></pre>
<blockquote>
<h4 id="子句查询"><a href="#子句查询" class="headerlink" title="子句查询"></a>子句查询</h4></blockquote>
<pre><code class="mysql">
select cust_name,cust_contact from customers where cust_id =(select cust_id 
from orders
where order_num = (select order_num from orderitems where prod_id = &#39;jp2000&#39;));
#由内而外，哈哈
等效于：
select order_num 
from orderitems
where prod_id = &#39;jp2000&#39;；
select cust_id 
from orders
where order_num =20006
select cust_name,cust_contact from customers where cust_id =10003
</code></pre>
<h3 id="联结（返回不在同一个表中的行）"><a href="#联结（返回不在同一个表中的行）" class="headerlink" title="联结（返回不在同一个表中的行）"></a>联结（返回不在同一个表中的行）</h3><pre><code class="mysql">/*等值语法*/
select vend_name, prod_name,prod_price
from vendors,products
where vendors.vend_id=products.vend_id;#此处过滤联结条件。
#如没有联结条件过滤，将检索出“笛卡尔积”：表1行数*表2行数
/*规范语法*/
select vend_name, prod_name,prod_price
from vendors inner join products
on vendors.vend_id=products.vend_id
</code></pre>
<h3 id="自联结（比子查询更快）"><a href="#自联结（比子查询更快）" class="headerlink" title="自联结（比子查询更快）"></a>自联结（比子查询更快）</h3><pre><code class="mysql">/*子查询*/
select cust_id, cust_name, cust_contact
from customers
where cust_name = (select cust_name from customers where cust_contact =&#39;jim jones&#39;);
/*自联结*/
select c1.cust_id, c1.cust_name,c1.cust_contact
from customers as c1,customers as c2#不以别名进行会引发错误
where c1.cust_name=c2.cust_name and c2.cust_contact=&#39;jim jones&#39;#联结cust_name与c2.cust_name ，并过滤cust_contact=&#39;jim jones&#39;的行
/*（c1的cust_name同c2相同，找到了c2的cust_contact=&#39;jim jones&#39;也就相当于找到了c1cust_contact=&#39;jim jones&#39;，知道了cust_contact=&#39;jim jones&#39;就可知道cust_id）*/
</code></pre>
<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><pre><code class="mysql">select cust_name,cust_contact,cust_email,cust_state
from customers
where cust_state in(&#39;il&#39;,&#39;in&#39;,&#39;mi&#39;)
union  #组合上下select多个select之间需要多个union分隔，union默认排除重复，union all则不排除
select cust_name,cust_contact,cust_email,cust_state#union中每个查询必须包含相同的列、表达式、或聚集函数
from customers
where cust_name =&#39;wascals&#39;
order by cust_name;#不能分别对每条union指定不同的排序
</code></pre>
<h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><h3 id="依赖于次序的插入"><a href="#依赖于次序的插入" class="headerlink" title="依赖于次序的插入"></a>依赖于次序的插入</h3><pre><code class="mysql">/*在得知列的次序后才可使用此方式添加，若发生了列的次序变动此添加方式将不安全*/
insert into customers
values(&#39;1000000006&#39;,&#39;toy land&#39;,&#39;123 any street&#39;,&#39;new york&#39;,&#39;ny&#39;, &#39;11111&#39;,&#39;usa&#39;,null, null);
#依赖于次序的插入，必须为每一列提供一个值，如某列无添加则应写上null
</code></pre>
<h3 id="提供列名的插入"><a href="#提供列名的插入" class="headerlink" title="提供列名的插入"></a>提供列名的插入</h3><pre><code class="mysql">insert into customers(cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip)
#必须为提供了列名的列给出一个值
values(null, null,&#39;1000000006&#39;,&#39;toy land&#39;,&#39;123 any street&#39;,&#39;new york&#39;,&#39;ny&#39;, &#39;11111&#39;);
</code></pre>
<h3 id="从另一个表插入"><a href="#从另一个表插入" class="headerlink" title="从另一个表插入"></a>从另一个表插入</h3><pre><code class="mysql">insert into 表名（列名）
select 列名
from 表名
where 过滤
</code></pre>
<blockquote>
<h4 id="复制一个表"><a href="#复制一个表" class="headerlink" title="复制一个表"></a>复制一个表</h4></blockquote>
<pre><code class="mysql">/*sql*/
select * 
into custcopy 
from customers;
/* mysql*/
create table custcopy as
select * 
from customers;
</code></pre>
<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><pre><code class="mysql">update customers
set cust_email = &#39;kim@@thetoystore.com&#39;
where cust_id = &#39;100000000005&#39;#如不指定，将更新customers表cust_email列下的所有行
</code></pre>
<h3 id="更新多个列"><a href="#更新多个列" class="headerlink" title="更新多个列"></a>更新多个列</h3><pre><code class="mysql">update customers
set cust_email = &#39;kim@@thetoystore.com&#39;,cust_contact=&#39;sam roberts&#39;
where cust_id = &#39;100000000006&#39;
</code></pre>
<h2 id="DELLETE"><a href="#DELLETE" class="headerlink" title="DELLETE"></a>DELLETE</h2><pre><code class="mysql">delete from customers
where cust_id = &#39;1000000006&#39;#删除此行，不过滤则删除所有行
#update删除列
#truncate删除表
</code></pre>
<h2 id="添加删除列-amp-amp-表"><a href="#添加删除列-amp-amp-表" class="headerlink" title="添加删除列&amp;&amp;表"></a>添加删除列&amp;&amp;表</h2><pre><code class="mysql">/*添加表时为防止覆盖，应删除表后再进行添加*/
create table orderitems
(order_num integer not null,
order_item integer not null,
prod_id char(10) not null,
quantity integer not null default 1,#设置quantity列下的行默认值为1
item_price decimal(8,2) not null);#not null即不允许填入null，默认可填入null，只有为 not null的列方可为主键及唯一标识
</code></pre>
<pre><code class="mysql">/*add列*/
alter table vendors
add vend_phone char (20);
/*del列*/
alter table vendors
drop column vend_phone;#此操作不可逆
/*删除表*/
drop table custcopy;#此操作不可逆
</code></pre>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><pre><code class="mysql">create view#创建视图
drop view 视图名#删除视图
/*以视图简化联结，创建视图*/
create view productcustomers as
select cust_name , cust_contact,prod_id
from customers,orders,orderitems
where customers.cust_id=orders.cust_id
and orderitems.order_num=orders.order_num;
/*可对视图采取与表相同的查询操作*/
select *
from productcustomers;
/*一个视图过滤查询例子*/
create view customeremaillist as
select cust_id, cust_name,cust_email
from customers
where cust_email is not null;#返回查询中所有cust_email不为空的，并将其添加到视图中
/*视图计算字段例子*/
create view orderitemsexpanded as 
select order_num,prod_id,quantity,item_price,quantity*item_price,quantity*item_price as
expanded_price
from orderitems
</code></pre>
<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><pre><code>/*撤销整体*/
start transaction ;
-- 标识事务处理块,块中内容未执行完则整体撤销
/*撤销部分操作*/
savepoint delete1;#标识
rollback to delete1;返回标识delete1
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SQL入门" style=color:#016a99>
                SQL入门
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/sql-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/thread-01/">
        <h2>
            线程方法
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>实现多线程必须继承<strong>Thread</strong>类，已有父类的类可通过实现<strong>Runnable</strong>实现多线程</p>
<p><strong>Thread</strong>也实现了<strong>Runnable</strong>接口，<strong>Runnable</strong>接口实现的多线程步骤比<strong>Thread</strong>更为繁琐</p>
</blockquote>
<h1 id="线程安全共享变量"><a href="#线程安全共享变量" class="headerlink" title="线程安全共享变量"></a>线程安全共享变量</h1><ul>
<li>这是一个不共享变量的线程：</li>
</ul>
<pre><code class="java">package cn.day.b2;

public class MyThread extends Thread &#123;
    private int count = 5;
    public MyThread(String name)&#123;
        super();
        this.setName(name);
    &#125;
    @Override
    public void run()&#123;
        super.run();
        while (count &gt; 0)&#123;
            count--;
            System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot;计算， count =&quot; + count);
        &#125;
    &#125;
    
    public static void main(String[] args) &#123;
        MyThread a = new MyThread(&quot;A&quot;);
        MyThread b = new MyThread(&quot;B&quot;);
        MyThread c = new MyThread(&quot;C&quot;);
        a.start();
        b.start();
        c.start();
    &#125;
&#125;
</code></pre>
<ul>
<li>可能出现多个线程同时修改变量（不安全）的情况</li>
</ul>
<pre><code class="java">package cn.day.b2;

public class MyThread extends Thread &#123;
    private int count = 5;
    @Override
    public void run()&#123;
        super.run();
            count--;
            System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot;计算， count =&quot; + count);
    &#125;

    public static void main(String[] args) &#123;
        var mythread = new MyThread();
        var a = new Thread(mythread,&quot;A&quot;);
        var b = new Thread(mythread,&quot;B&quot;);
        var c = new Thread(mythread,&quot;C&quot;);
        var d = new Thread(mythread,&quot;D&quot;);
        var e = new Thread(mythread,&quot;E&quot;);//分配新的 Thread 对象，以便将 mythread 作为其运行对象，将指定的 E 作为其名称
        a.start();
        b.start();
        c.start();
        d.start();
        e.start();
    &#125;
&#125;
</code></pre>
<ul>
<li>安全的共享变量（添加互斥区）</li>
</ul>
<pre><code class="java">package cn.day.b2;

public class MyThread extends Thread &#123;
    private int count = 5;
    @Override
    synchronized public void run()&#123;//加入锁，只有等一个线程停止后另一个线程才能调用run（）方法
        super.run();
            count--;
            System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot;计算， count =&quot; + count);
    &#125;

    public static void main(String[] args) &#123;
        var mythread = new MyThread();
        var a = new Thread(mythread,&quot;A&quot;);
        var b = new Thread(mythread,&quot;B&quot;);
        var c = new Thread(mythread,&quot;C&quot;);
        var d = new Thread(mythread,&quot;D&quot;);
        var e = new Thread(mythread,&quot;E&quot;);
        a.start();
        b.start();
        c.start();
        d.start();
        e.start();
    &#125;
&#125;
</code></pre>
<h1 id="run-与start"><a href="#run-与start" class="headerlink" title="run( )与start( )"></a>run( )与start( )</h1><ul>
<li>**run( )**立即执行，不创建新的线程。</li>
<li><strong>start( )</strong>,创建新线程并用其执行。</li>
<li><strong>run( )**的执行顺序与</strong>start( )**顺序无关</li>
</ul>
<h1 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h1><ul>
<li>返回对当前正在执行的线程对象的引用</li>
</ul>
<pre><code class="java">package cn.day.b2.currentThreadExt;

public class CountOperate extends Thread &#123;
    public CountOperate()&#123;
        System.out.println(&quot;CountOperate---begin&quot;);
        System.out.println(&quot;Thread.currentThread().getName()=&quot; + Thread.currentThread().getName());//返回对当前正在执行的线程对象的引用

        System.out.println(&quot;this.getName()= &quot; +  this.getName());//this指代带CountOperate对象，CountOperate对象的名字并未发生改变，故默认线程名为Thread-0
        System.out.println(&quot;CountOperate---end&quot;);
    &#125;
    @Override
    public void run()&#123;
        System.out.println(&quot;run---begin&quot;);
        System.out.println(&quot;Thread.currentThread.getName()=&quot;+ Thread.currentThread().getName());
        System.out.println(&quot;this.getName() =&quot; + this.getName());//此时线程名为“B”
        System.out.println(&quot;run---end&quot;);
    &#125;
&#125;


package cn.day.b2.currentThreadExt;

public class Run &#123;
    public static void main(String[] args) &#123;
        var c = new CountOperate();
        c.setName(&quot;B&quot;);//调用构造器之前并未指定线程名称
        var t1 = new Thread(c);
        t1.setName(&quot;A&quot;);
        t1.start();
    &#125;
&#125;

/*运行结果*
CountOperate---begin
Thread.currentThread().getName()=main
this.getName()= Thread-0
CountOperate---end
run---begin
Thread.currentThread.getName()=A
this.getName() =B
run---end
*/
</code></pre>
<h1 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive( )"></a>isAlive( )</h1><ul>
<li>判断线程是否存活</li>
</ul>
<pre><code class="java">package cn.day.b3;

public class CountOperate extends Thread &#123;
    public CountOperate()&#123;//构造函数时主线程main确认存活
        System.out.println(&quot;CountOperate---begin&quot;);
        System.out.println(&quot;Thread.currentThread().getName()= &quot; + Thread.currentThread().getName());
        System.out.println(&quot;Thread.currentThread().isAlive()= &quot; + Thread.currentThread().isAlive());
        System.out.println(&quot;this.getName() =&quot; + this.getName());
        System.out.println(&quot;this.isAlive() =&quot; + this.isAlive());
        System.out.println(&quot;CountOpreate---end&quot;);
    &#125;
    @Override
    public void run()&#123;
        System.out.println(&quot;run---begin&quot;);
        System.out.println(&quot;Thread.currentThread().getName() =&quot; + Thread.currentThread().getName());
        System.out.println(&quot;Thread.currentThread().isAlive() =&quot; + Thread.currentThread().isAlive());
        System.out.println(&quot;this.getName() =&quot; + this.getName());
        System.out.println(&quot;this.isAlive() =&quot; + this.isAlive());//为false，而重命名的A线程存活
        System.out.println(&quot;run---end&quot;);
    &#125;

    public static void main(String[] args) &#123;
        var c = new CountOperate();//构造完对象后，main线程失活为false
        var t1 = new Thread(c);//main线程又存活了
        System.out.println(&quot;main begin t1 isAlive=&quot; + t1.isAlive());//isAlive()判断该线程是否存活
        t1.setName(&quot;A&quot;);
        t1.start();
        System.out.println(&quot;main end t1 isAlive=&quot; + t1.isAlive());
    &#125;
&#125;
</code></pre>
<h1 id="sleep（）"><a href="#sleep（）" class="headerlink" title="sleep（）"></a>sleep（）</h1><ul>
<li>使线程休眠</li>
</ul>
<pre><code class="java">package cn.day.b3;


public class MyThread2 extends Thread &#123;
    @Override
    public void run()&#123;
        try &#123;
            System.out.println(&quot;run threadName=&quot; + this.currentThread().getName() + &quot;begin =&quot; + System.currentTimeMillis());
            //currentTimeMillis()返回以毫秒为单位的当前时间
            Thread.sleep(2000);//线程休眠2s
            System.out.println(&quot;run threadName=&quot; + this.currentThread().getName() + &quot;end =&quot; + System.currentTimeMillis() );
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        var mythread = new MyThread2();
        System.out.println(&quot;begin =&quot; + System.currentTimeMillis());
        mythread.start();
        System.out.println(&quot;end =&quot; + System.currentTimeMillis());
        /*begin =1594439524699  main线程执行100多毫秒
            end =1594439524710
            run threadName=Thread-0begin =1594439524710 Thread线程执行2s多
            run threadName=Thread-0end =1594439526721*/
    &#125;
&#125;
</code></pre>
<h1 id="线程堆栈方法"><a href="#线程堆栈方法" class="headerlink" title="线程堆栈方法"></a>线程堆栈方法</h1><h2 id="StackTraceElement-getStackTrace"><a href="#StackTraceElement-getStackTrace" class="headerlink" title="StackTraceElement[] getStackTrace( )"></a>StackTraceElement[] getStackTrace( )</h2><ul>
<li>返回一个表示该线程堆栈跟踪元素的数组。（线程未启动或终止则返回length为0的数组即null）</li>
</ul>
<pre><code class="java">package cn.day.b3;

public class Test &#123;
    public void a()&#123;
        b();
    &#125;
    public void b()&#123;
        c();
    &#125;public void c()&#123;
        d();
    &#125;public void d()&#123;
        e();
    &#125;
    public void e()&#123;
        StackTraceElement[] array = Thread.currentThread().getStackTrace();
        if (array != null)&#123;
            for (int i = 0; i &lt; array.length; i++)&#123;
                var eachElement = array[i];
                System.out.println(&quot;className=&quot; + eachElement.getClassName() + &quot; methodName=&quot; + eachElement.getMethodName() + &quot; fileName=&quot;
                + eachElement.getFileName() + &quot; lineNumber=&quot;+eachElement.getLineNumber());
                //eachElement.getClassName()返回包含由该堆栈跟踪元素表示的执行点的类的全限定名。
                //eachElement.getMethodName()返回包含由该堆栈跟踪元素所表示的执行点的方法的名称
                //eachElement.getLineNumber()返回包含由该堆栈跟踪元素表示的执行点源极线的行号
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        var test = new Test();
        test.a();
    &#125;
&#125;
/*结果：
className=java.lang.Thread methodName=getStackTrace fileName=Thread.java lineNumber=1598
className=cn.day.b3.Test methodName=e fileName=Test.java lineNumber=15 
// 最后（最新）调用的为栈顶
className=cn.day.b3.Test methodName=d fileName=Test.java lineNumber=12
className=cn.day.b3.Test methodName=c fileName=Test.java lineNumber=10
className=cn.day.b3.Test methodName=b fileName=Test.java lineNumber=8
className=cn.day.b3.Test methodName=a fileName=Test.java lineNumber=5
//最先的调用为栈底
className=cn.day.b3.Test methodName=main fileName=Test.java lineNumber=27
*/
</code></pre>
<h2 id="dumpStack"><a href="#dumpStack" class="headerlink" title="dumpStack( )"></a>dumpStack( )</h2><ul>
<li>将当前线程堆栈跟踪信息输出至标准错误流</li>
</ul>
<pre><code class="java">package cn.day.b3;

public class Test &#123;
    public void a()&#123;
        b();
    &#125;
    public void b()&#123;
        c();
    &#125;public void c()&#123;
        d();
    &#125;public void d()&#123;
        e();
    &#125;
    public void e()&#123;
       int age = 0;
       age = 100;
       if (age == 100)&#123;
           Thread.dumpStack();//将当前线程堆栈跟踪信息输出至标准错误流
       &#125;
    &#125;

    public static void main(String[] args) &#123;
        var test = new Test();
        test.a();
    &#125;
&#125;
/*结果
java.lang.Exception: Stack trace
    at java.base/java.lang.Thread.dumpStack(Thread.java:1379)
    at cn.day.b3.Test.e(Test.java:18)
    at cn.day.b3.Test.d(Test.java:12)
    at cn.day.b3.Test.c(Test.java:10)
    at cn.day.b3.Test.b(Test.java:8)
    at cn.day.b3.Test.a(Test.java:5)
    at cn.day.b3.Test.main(Test.java:24)
    */
</code></pre>
<h2 id="staric-Map-lt-Thread-StackTraceElement-gt-getAllStackTraces"><a href="#staric-Map-lt-Thread-StackTraceElement-gt-getAllStackTraces" class="headerlink" title="staric Map&lt;Thread,StackTraceElement[]&gt; getAllStackTraces( )"></a>staric Map&lt;Thread,StackTraceElement[]&gt; getAllStackTraces( )</h2><ul>
<li>返回所有活动线程的堆栈跟踪（映射）信息</li>
<li>映射的键即线程，而每个值都是一个StackTraceElement数组</li>
</ul>
<pre><code class="java">package cn.day.b3;

import java.util.Iterator;
import java.util.Map;

public class Test &#123;
    public void a()&#123;
        b();
    &#125;
    public void b()&#123;
        c();
    &#125;public void c()&#123;
        d();
    &#125;public void d()&#123;
        e();
    &#125;
    
    public void e()&#123;
       Map&lt;Thread,StackTraceElement[]&gt; map = Thread.currentThread().getAllStackTraces();
       if (map != null &amp;&amp; map.size() != 0)&#123;
           Iterator keyIterator = map.keySet().iterator();
           while (keyIterator.hasNext())&#123;
               Thread eachThread = (Thread) keyIterator.next();//键即线程
               StackTraceElement[] array = map.get(eachThread);//返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。
               System.out.println(&quot;------每个线程的基本信息&quot;);
               System.out.println(&quot;  线程名称：&quot; + eachThread.getName());
               System.out.println(&quot;StackTraceElement[].length=&quot; + array.length);
               System.out.println(&quot;  线程状态：&quot; + eachThread.getState());
               if (array.length != 0)&#123;
                   System.out.println(&quot;输出stackTraceElement[] 数组具体信息：&quot;);
                   for (int i = 0; i &lt; array.length; i++) &#123;
                       StackTraceElement eachElement = array[i];
                       System.out.println(&quot; &quot;+ eachElement.getClassName() + &quot; &quot; +eachElement.getMethodName() +
                               &quot; &quot; + eachElement.getFileName() + &quot; &quot; + eachElement.getLineNumber());
                   &#125;
               &#125;
               else &#123;
                   System.out.println(&quot;没有StackTraceElement[]信息，因为线程&quot; + eachThread.getName() + &quot;中的StackTraceElement[].length==0&quot;);
               &#125;
               System.out.println();
               System.out.println();
           &#125;

       &#125;
    &#125;

    public static void main(String[] args) &#123;
        var test = new Test();
        test.a();
    &#125;
&#125;
</code></pre>
<h1 id="getId"><a href="#getId" class="headerlink" title="getId( )"></a>getId( )</h1><ul>
<li>获取线程Id</li>
</ul>
<h1 id="interrupted-、isinterrupted"><a href="#interrupted-、isinterrupted" class="headerlink" title="interrupted( )、isinterrupted( )"></a>interrupted( )、isinterrupted( )</h1><ul>
<li>**interrupted( )**测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。 </li>
<li><strong>isinterrupted( )</strong> 测试线程对象是否为中断状态且不清除状态标志。</li>
</ul>
<h1 id="interrupt-、中断处理"><a href="#interrupt-、中断处理" class="headerlink" title="interrupt( )、中断处理"></a>interrupt( )、中断处理</h1><ul>
<li><p>在线程中做一个停止标记，配合异常或<strong>return</strong>终止线程</p>
</li>
<li><p><strong>return</strong>中断法</p>
<pre><code class="java">package cn.day.b4;


public class MyThread1 extends Thread &#123;
    @Override
    public void run( ) &#123;
        System.out.println(&quot;线程开始&quot;);
        super.run();

        if (Thread.interrupted()) &#123;//检测线程状态
            System.out.println(&quot;已经停止状态了！&quot;);
            return;
        &#125;
    &#125;

    public static void main(String[] args) &#123;

            var thread = new MyThread1();
            thread.start();
            thread.interrupt();//中断该线程
    &#125;
&#125;
</code></pre>
</li>
<li><p>异常中断法（一般采用）：可在<strong>catch</strong>块中对异常信息进行统一处理。</p>
<pre><code class="java">package cn.day.b4;

public class MyThread extends Thread &#123;
    @Override
    public void run( )&#123;
        super.run();
        try&#123;
            for (int i = 0; i &lt; 50000000; i++) &#123;//此循环数值要足够大，否则在main中方法标记中断线程之前循环就结束了
//                 if (this.interrupted())&#123;//检测线程状态
                 if (Thread.interrupted())&#123;//检测线程状态
//                 if (this.isInterrupted())&#123;//检测线程状态
                     System.out.println(&quot;已经停止状态了！&quot;);
                     throw new InterruptedException();
                 &#125;
                System.out.println(&quot;i=&quot;+(i + 1));
            &#125;
        &#125;catch (InterruptedException e)&#123;
            System.out.println(&quot;进MyThread.java类run方法中的catch了&quot;);
            e.printStackTrace();//打印此throwable及其追踪到标准错误流,错误的栈轨迹等
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            var thread = new MyThread();
            thread.start();
            Thread.sleep(2000);
            thread.interrupt();//中断该线程
        &#125;catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;end&quot;);
        System.out.println(Thread.interrupted());
    &#125;
&#125;
</code></pre>
<p><strong>interrupt方法遇到sleep方法（wait也一样）同样会发生异常(中断线程)</strong></p>
<pre><code class="java">package cn.day.b4;

public class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        super.run();
        try &#123;
            for (int i = 0; i &lt; 50000; i++) &#123;
                System.out.println(&quot;i=&quot; + (i + 1));
            &#125;
            System.out.println(&quot;run begin&quot;);
            Thread.sleep(200000);
            System.out.println(&quot;run end&quot;);
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;进MyThread.java类run方法中的catch了&quot;);
            e.printStackTrace();//打印此throwable及其追踪到标准错误流,错误的栈轨迹等
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        var thread = new MyThread();
        thread.start();
        thread.interrupt();//中断该线程
        System.out.println(&quot;end&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="其它中断线程的方法（已废弃）"><a href="#其它中断线程的方法（已废弃）" class="headerlink" title="其它中断线程的方法（已废弃）"></a>其它中断线程的方法（已废弃）</h1><p><strong>stop（）</strong></p>
<ul>
<li><strong>Stop（）</strong>对线程的停止具有不确定性，如线程在添加元素而不知道添加到哪里就被中断了</li>
<li>此方法抛出的<strong>ThreadDeath</strong>异常不需要显式捕捉</li>
<li>此方法用于销毁线程对象，如想重启线程，需使用<strong>Start（）</strong>方法</li>
</ul>
<p><strong>suspend( )、resume（）</strong></p>
<ul>
<li>**suspend( )**暂停线程，</li>
<li><strong>resume（）</strong>恢复线程</li>
<li>易独占公共同步对象，导致其它线程无法访问公共同步对象</li>
<li>易导致数据不完整</li>
</ul>
<p><strong>yield（）</strong></p>
<ul>
<li>放弃产品CPU资源，让与其它任务（线程）</li>
<li>时间不确定：如刚放弃又拾起</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java多线程编程" style=color:#016a99>
                Java多线程编程
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/thread-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/thread-02/">
        <h2>
            线程安全与通信
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul>
<li><p>线程优先级具有可继承性</p>
</li>
<li><p>cpu将资源让与优先级更高的线程（运行更快）</p>
</li>
<li><p>随机性：并不是执行完高优先级线程再执行低优先级线程，只是说首先执行高优先级线程的概率更大一点</p>
</li>
<li><p>可使用**setPriority( )**设置优先级（范围：0-10）</p>
</li>
<li><p>Jdk预设了3个优先级值： </p>
<pre><code>MIN_PRIORITY = 1
NORM_PRIORITY = 5
MAX_PRIORITY = 10
</code></pre>
</li>
</ul>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><ul>
<li>Java中存在<strong>用户线程</strong>、<strong>守护线程</strong>两种线程</li>
<li>守护线程为其它线程运行提供便利，如GC</li>
<li>最后一个用户线程、守护线程退出，进程也就结束了（只要有一个用户进程在运行，那么这个进程就不会结束）               </li>
</ul>
<pre><code class="java">package cn.day.b4;

public class MyThread2 extends Thread &#123;
    private int i = 1;
    @Override
    public void run()&#123;
        try &#123;
            while (true)&#123;//死循环
                System.out.println(&quot;i&quot; + (i));
                Thread.sleep(1000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            var thread = new MyThread2();
            thread.setDaemon(false);//这是个用户线程，此进程将不停的执行下去
//            thread.setDaemon(false);这是个守护线程，它将随着用户进程（main）的结束而结束
            //setDaemon() 将线程标记为守护线程(true)或用户线程(false)。
            thread.start();
            Thread.sleep(5000);
            System.out.println(&quot;end&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>对象、变量的并发访问：A线程获得了X对象的锁，此时B线程只能调用X对象中没有synchronized标记的方法</li>
</ul>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><ul>
<li><p>方法中的变量不受线程安全影响，而实例字段（变量）将受到非线程安全的影响</p>
</li>
<li><p>当多个线程执行同一个业务对象中的方法时，线程与业务属于多对以一的关系，会产生非线程<strong>安全问题</strong></p>
<ol>
<li>可使用synchronized关键词实现同步执行。</li>
<li>可分别创建两个对象实例（线程与对象方法就是一对一啦），实现异步执行。</li>
</ol>
</li>
<li><p>在方法声明处添加synchronized是锁对象而非锁方法（Java没有锁方法一说）</p>
</li>
<li><p>Java中，<strong>锁</strong> 就是<strong>对象</strong>， <strong>对象</strong>可以<strong>映射</strong>为<strong>锁</strong>。线程拿到锁就可以执行对象中的synchronized同步方法</p>
</li>
<li><p>线程发生异常时将释放对象锁</p>
</li>
</ul>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><ul>
<li>比如：在main主线程中，一个其它线程正在执行( 原想在结束后main线程再调用某个方法（属性）)，结果main在未结束的线程前调用了（属性）方法，产生了不理想的结果，这就是导致脏读。</li>
<li>解决方法：对该（属性）方法使用synchronized上锁。</li>
</ul>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><ul>
<li><p>已知线程获取了某个对象锁，则其在线程未结束（对象锁未释放）前仍可获取该对象锁（）</p>
<pre><code class="java">package cn.day.b5;

public class Service &#123;
    synchronized public void service1()&#123;
        System.out.println(&quot;service1&quot;);
        service2();
    &#125;
    synchronized public void service2()&#123;
        System.out.println(&quot;service2&quot;);
        service3();
    &#125;
    synchronized public void service3()&#123;
        System.out.println(&quot;service3&quot;);
    &#125;

    public static void main(String[] args) &#123;
        var t = new MyThread();
        t.start();//在此线程运行时：service1可调用上锁的service2，service2可调用上锁的service3，而不会被线程t2干扰
        var t2 = new MyThread1();
        t2.start();
    &#125;
&#125;
class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        Service service = new Service();
        service.service1();
    &#125;
&#125;
class MyThread1 extends Thread&#123;
    @Override
    public void run()&#123;
        Service service = new Service();
        service.service2();
    &#125;
&#125;
</code></pre>
</li>
<li><p>继承状态下，线程还可重入调用父类的（同步）方法</p>
</li>
</ul>
<h2 id="holdsLock（）"><a href="#holdsLock（）" class="headerlink" title="holdsLock（）"></a>holdsLock（）</h2><ul>
<li>对象持有锁时返回True</li>
</ul>
<pre><code class="java">package cn.day.b5;

public class Test &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;A &quot;+Thread.currentThread().holdsLock(Test.class));
        synchronized (Test.class)&#123;//synchronized块
            System.out.println(&quot;B &quot;+Thread.currentThread().holdsLock(Test.class));
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><ul>
<li><p>当某个对象的<strong>synchronized</strong>代码块（this）被某个线程访问时，其它线程将被阻塞，并且不能访问该对象的其它同步代码块</p>
</li>
<li><p><strong>synchronized</strong>代码块（）内写入一个类的Class对象，那么这个锁对所有该类实例有效</p>
</li>
<li><p>使用同步代码块时：一般不使用String作为对象锁如，而使用Object。</p>
<pre><code class="java">package cn.day.b5;

public class String1 &#123;
    public static void print(String t)&#123;
        try &#123;
            synchronized (t)&#123;//锁的是变量T的值
                while (true)&#123;
                    System.out.println(Thread.currentThread().getName());
                    Thread.sleep(1000);//两个线程传入相同的String值会导致一个线程休眠时另一个线程仍无法执行

                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        var string1 = new String1();
        var a = new Thread1(string1);
        a.setName(&quot;A&quot;);
        a.start();
        var b = new Thread2(string1);
        b.setName(&quot;B&quot;);
        b.start();
    &#125;
&#125;
class Thread1 extends Thread&#123;
    private String1 string1;
    public Thread1(String1 string1)&#123;
        super();
        this.string1 =string1;

    &#125;
    @Override
    public void run()&#123;
        string1.print(&quot;AA&quot;);
    &#125;
&#125;
class Thread2 extends Thread&#123;
    private String1 string2;
    public Thread2(String1 string1)&#123;
        super();
        this.string2 =string1;

    &#125;
    @Override
    public void run()&#123;
        string2.print(&quot;AA&quot;);//两个线程传入相同的String值会导致一个线程休眠时另一个线程仍无法执行
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h2><ul>
<li><p>锁对象改变则异步执行，否则依旧同步执行(只要锁对象相同就同步执行 )</p>
<pre><code class="java">package cn.day.b5;

public class String2 &#123;
    private String lock = &quot;123&quot;;
    public void testMethod()&#123;
        try &#123;
            synchronized (lock)&#123;
                System.out.println(Thread.currentThread().getName()+&quot;begin &quot;+System.currentTimeMillis());
                lock =&quot;456&quot;;//改变锁对象
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + &quot;end &quot;+ System.currentTimeMillis());
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        var string2 = new String2();
        Thread1 a = new Thread1(string2);
        a.setName(&quot;A&quot;);
        Thread2 b = new Thread2(string2);
        a.setName(&quot;B&quot;);
        a.start();
        Thread.sleep(50);
        b.start();
    &#125;
&#125;
class Thread1 extends Thread&#123;
    private String2 string1;
    public Thread1(String2 string1)&#123;
        super();
        this.string1 =string1;

    &#125;
    @Override
    public void run()&#123;
        string1.testMethod();
    &#125;
&#125;
class Thread2 extends Thread&#123;
    private String2 string2;
    public Thread2(String2 string1)&#123;
        super();
        this.string2 =string1;

    &#125;
    @Override
    public void run()&#123;
        string2.testMethod();
    &#125;&#125;
</code></pre>
</li>
</ul>
<h2 id="静态方法的锁"><a href="#静态方法的锁" class="headerlink" title="静态方法的锁"></a>静态方法的锁</h2><ul>
<li><strong>synchronized</strong>加到<strong>静态方法</strong>是将<strong>Class类</strong>对象作为锁（而<strong>synchronized</strong>加到<strong>非静态</strong>是将方法所在类的对象作为锁）</li>
<li>如果A类中方法都是静态方法且加锁，那么即使创建两个A类实例对象仍无法实现异步。（静态方法可直接导入类再调用:A.方法名;实现异步）</li>
</ul>
<h2 id="volatile（synchronized也可）"><a href="#volatile（synchronized也可）" class="headerlink" title="volatile（synchronized也可）"></a>volatile（<strong>synchronized</strong>也可）</h2><ul>
<li>让B线程立刻看见A线程更改的数据</li>
<li>禁止代码重排序</li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><ul>
<li>解决资源浪费</li>
</ul>
<pre><code class="java">package cn.day.b6;

import java.util.ArrayList;
import java.util.List;
/**线程 Thread2 （B）一直监视list.size造成了资源浪费*/
public class MyList &#123;
    volatile private List list = new ArrayList();//实现多线程之间的可视性，不然线程B将一直执行
    public void add()&#123;
        list.add(&quot;1&quot;);
    &#125;
    public int size()&#123;
        return list.size();
    &#125;

    public static void main(String[] args) &#123;
        var service = new MyList();
        var a = new Thread1(service);
        a.setName(&quot;A&quot;);
        a.start();
        var b = new Thread2(service);
        b.setName(&quot;B&quot;);
        b.start();
    &#125;
&#125;
class Thread1 extends Thread&#123;
    private MyList list;
    public Thread1 (MyList list)&#123;
        super();
        this.list = list;
    &#125;
    @Override
    public void run()&#123;
        try&#123;
            for (int i = 0; i &lt; 10; i++)&#123;
                list.add();
                System.out.println(&quot;添加了&quot;+(i + 1)+&quot;个元素&quot;);
                Thread.sleep(1000);
            &#125;
            &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;class Thread2 extends Thread&#123;
    private MyList list;
    public Thread2 (MyList list)&#123;
        super();
        this.list = list;
    &#125;
    @Override
    public void run()&#123;
        try&#123;
            while (true)&#123;
                //Thread.sleep(2000);//B线程将因错过list.size==5而不会终止。
                if (list.size()==5)&#123;
                    System.out.println(&quot;==5了，b线程退出&quot;);
                    throw new InterruptedException();
                &#125;
            &#125;
            &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait( )"></a>wait( )</h2><ul>
<li><p>暂停当前线程并等待被唤醒</p>
</li>
<li><p><strong>wait(1000 )</strong> ,在1s后如无**notify( )**唤醒，则自动唤醒（持有锁后继续执行）</p>
<pre><code class="java">package cn.day.b6;

public class Thread_A extends Thread &#123;
    private Object lock;
    public Thread_A(Object lock)&#123;
        super();
        this.lock = lock;
    &#125;
    @Override
    public void run()&#123;
        try &#123;
            synchronized (lock)&#123;
                System.out.println(&quot;我跳出来了&quot;);
                lock.wait(1000);
                System.out.println(&quot;打我啊笨蛋&quot;);

            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class Thread_B extends Thread &#123;
    private Object lock;
    public Thread_B(Object lock)&#123;
        super();
        this.lock = lock;
    &#125;
    @Override
    public void run()&#123;
            synchronized (lock)&#123;
               while (true)&#123;//B线程执行完毕后，A线程自动唤醒
                   System.out.println(&quot;停不下来&quot;);
                   try &#123;
                       Thread.sleep(1000);
                   &#125; catch (InterruptedException e) &#123;
                       e.printStackTrace();
                   &#125;
               &#125;

            &#125;
        &#125;
    &#125;
class TestRun&#123;
    public static void main(String[] args) &#123;
            Object lock = new Object();
            var t1 = new Thread_A(lock);
            var t2 = new Thread_B(lock);
            t1.start();
            t2.start();

        &#125;
    &#125;

</code></pre>
</li>
</ul>
<h2 id="notify"><a href="#notify" class="headerlink" title="notify( )"></a><strong>notify( )</strong></h2><ul>
<li>执行完当前同步代码块内代码后，选择同一个（唤醒多个需要多次调用）锁的等待线程**wait( )**将其唤醒（按照执行wait的顺序）</li>
</ul>
<h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll( )"></a>notifyAll( )</h2><ul>
<li>（倒序）唤醒全部等待线程<strong>wait( )</strong></li>
</ul>
<pre><code class="java">package cn.day.b6;

public class Thread_A extends Thread &#123;
    private Object lock;
    public Thread_A(Object lock)&#123;
        super();
        this.lock = lock;
    &#125;
    @Override
    public void run()&#123;
        try &#123;
            synchronized (lock)&#123;
                System.out.println(&quot;Start wait time= &quot;+System.currentTimeMillis());
                lock.wait();//暂停并等待被唤醒
                System.out.println(&quot;End wait time= &quot;+System.currentTimeMillis());

            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class Thread_B extends Thread &#123;
    private Object lock;
    public Thread_B(Object lock)&#123;
        super();
        this.lock = lock;
    &#125;
    @Override
    public void run()&#123;
            synchronized (lock)&#123;
                System.out.println(&quot;Start notify time= &quot;+System.currentTimeMillis());
               // lock.notify();//选择同一个锁的等待线程将其唤醒（按照执行wait的顺序，依次唤醒）
                lock.notifyAll()//同notify()，但按相反的顺序唤醒
                System.out.println(&quot;End notify time= &quot;+System.currentTimeMillis());

            &#125;
        &#125;
    &#125;
class TestRun&#123;
    public static void main(String[] args) &#123;
        try &#123;
            Object lock = new Object();//同一个对象同一个梦想，哈哈
            var t1 = new Thread_A(lock);
            t1.start();
            Thread.sleep(3000);
            var t2 = new Thread_B(lock);
            t2.start();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h1><ul>
<li><p>共享变量+<strong>notifyAll( )</strong>+while+<strong>synchronized</strong>+volatile实现交叉执行</p>
<pre><code class="java">package cn.day.b6;

public class MyThread &#123;
    volatile private boolean prevIsA = false;//volatile，修改值时其它线程均可知晓
    synchronized public void backupA()&#123;
        try&#123;
            while (prevIsA == true)&#123;//全场依据PrevIsA的值判断该线程是否该休息（释放锁）
                wait();
            &#125;
            for (int i = 0;i &lt; 5;i++)&#123;
                System.out.println(&quot;++++++&quot;);
            &#125;
            prevIsA = true;//此线程主要步骤执行完后再修改prevIsA值
            notifyAll();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    synchronized public void backupB()&#123;
        try&#123;
            while (prevIsA == false) &#123;////全场依据PrevIsA的值判断该线程是否该休息（释放锁）
                wait();
            &#125;
                for (int i = 0;i &lt; 5; i++)&#123;
                    System.out.println(&quot;------&quot;);
                &#125;
                prevIsA = false;////全场依据PrevIsA的值判断该线程是否该休息（释放锁）
                notifyAll();

        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class Thread1 extends Thread&#123;
    private MyThread dbTools;
    public Thread1(MyThread dbTools)&#123;
        super();
        this.dbTools = dbTools;
    &#125;
    @Override
    public void run()&#123;
        dbTools.backupA();
    &#125;
&#125;
class Thread2 extends Thread&#123;
    private MyThread dbTools;
    public Thread2(MyThread dbTools)&#123;
        super();
        this.dbTools = dbTools;
    &#125;
    @Override
    public void run()&#123;
        dbTools.backupB();
    &#125;
&#125;
class MyRun&#123;
    public static void main(String[] args) &#123;
        var dbtools = new MyThread();
        for (int i = 0; i &lt; 20; i++)&#123;//循环20波，100行
            var output = new Thread2(dbtools);
            output.start();
            var input = new Thread1(dbtools);
            input.start();
        &#125;

    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="join"><a href="#join" class="headerlink" title="join( )"></a>join( )</h2><ul>
<li>当前线程释放锁并进入无休止的等待状态，等其它线程结束再执行</li>
<li>join( 2000)，当前线程释放锁，2s后如获得锁，继续执行（无法获得锁，则一直尝试获得锁）</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li>将数据放于map中<ol>
<li>Map中的key存储ThreadLocal对象，value存储值</li>
<li>每个线程的value仅对此线程可见</li>
<li>当线程销毁时，map也随之销毁，如map的数据没有被引用则随时未GC回收</li>
</ol>
</li>
</ul>
<pre><code class="java">package cn.day.b7;

public class Tools &#123;
    public static ThreadLocal t1 = new ThreadLocal();
&#125;
class MyThreadA extends Thread&#123;
    @Override
    public void run()&#123;
        try &#123;
            for (int i = 0; i &lt; 10; i++)&#123;
                Tools.t1.set(&quot;A&quot;+(i++));
                System.out.println(&quot;A get &quot;+ Tools.t1.get());
                int sleepValue = (int)(Math.random()*1000);
                Thread.sleep(sleepValue);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class MyThreadB extends Thread&#123;
    @Override
    public void run()&#123;
        try &#123;
            for (int i = 0; i &lt; 10; i++)&#123;
                Tools.t1.set(&quot;B&quot;+(i++));
                System.out.println(&quot;B get &quot;+ Tools.t1.get());
                int sleepValue = (int)(Math.random()*1000);
                Thread.sleep(sleepValue);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class Test&#123;
    public static void main(String[] args) throws InterruptedException &#123;
        var a = new MyThreadA();
        var b = new MyThreadB();
        a.start();
        b.start();
        for (int i = 0; i &lt; 10; i++)&#123;
            Tools.t1.set(&quot;main&quot;+(i+1));
            System.out.println(&quot;main get &quot;+ Tools.t1.get());
            int sleepValue = (int)(Math.random()*1000);
            try &#123;
                Thread.sleep(sleepValue);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>可通过重写initialValue( )方法，改变map中无值时get（）返回的数据（null）</li>
</ul>
<pre><code class="java">package cn.day.b7;

public class ThreadLocalExt extends ThreadLocal &#123;
    @Override
    protected Object initialValue()&#123;
        return &quot;改变&quot;;
    &#125;
&#125;
class Run&#123;
    public static  ThreadLocalExt t1= new ThreadLocalExt();

    public static void main(String[] args) &#123;
        System.out.println(t1.get());
    &#125;
&#125;
</code></pre>
<h2 id="inheritableThreadLocal"><a href="#inheritableThreadLocal" class="headerlink" title="inheritableThreadLocal"></a>inheritableThreadLocal</h2><ul>
<li>从创建这个线程对象的线程继承map值(继承后并不随着map值的更新而更新)</li>
</ul>
<pre><code class="java">package cn.day.b7;

public class TestInheritableThreadLocal extends Thread&#123;
    public void run()&#123;
        try &#123;
            for (int i = 0; i&lt;10; i++)&#123;
                System.out.println(&quot;在ThreadA线程中取值=&quot;+Tools1.t1.get());
                Thread.sleep(100);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            for (int i = 0; i &lt;10; i++)&#123;
                if (Tools1.t1.get() == null)&#123;
                    Tools1.t1.set(&quot;此值是main&quot;);
                &#125;
                System.out.println(&quot;在main线程中取值=&quot; + Tools1.t1.get());
                Thread.sleep(100);
            &#125;
            Thread.sleep(5000);
            var a = new TestInheritableThreadLocal();
            a.start();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;    &#125;
&#125;
class Tools1&#123;
    public static InheritableThreadLocal t1 = new InheritableThreadLocal();
&#125;
</code></pre>
<p>重写childValue( )方法可对继承的值进行“加工”。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java多线程编程" style=color:#016a99>
                Java多线程编程
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/thread-02/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/thread-03/">
        <h2>
            Lock对象
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="ReentrantLockTest"><a href="#ReentrantLockTest" class="headerlink" title="ReentrantLockTest"></a>ReentrantLockTest</h1><p>jdk5加入的，<strong>synchronized</strong>增强版</p>
<h2 id="lock-unlock-condition-await-condition-signal-等"><a href="#lock-unlock-condition-await-condition-signal-等" class="headerlink" title="lock( ) unlock( )  condition.await( ) **condition.signal( )**等"></a>lock( ) unlock( )  condition.await( ) **condition.signal( )**等</h2><ul>
<li><strong>lock( )**获取锁，</strong>unlock**释放锁（同步代码处在lock、unlock之间）</li>
<li><strong>condition.await( )**效果同</strong>wait( )**,调用此方法前，该线程必须获得锁</li>
<li><strong>condition.signal( )</strong>,唤醒线程，效果同<strong>notify（）</strong>。</li>
<li><strong>condition.signalAll( )**，唤醒所有线程（倒序）效果同</strong>notifyAll（）**</li>
</ul>
<pre><code class="java">package cn.day.b7;

import cn.day.b6.MyThread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
/*3个线程同步知晓，均不打印B*/
public class MyService &#123;
    private ReentrantLock lock = new ReentrantLock();//创建此对象用于获取锁、释放锁等操作
    //new ReentrantLock(true);当设置为 true 时，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。//未定时的 tryLock 方法并没有使用公平设置。
    private Condition condition = lock.newCondition();//用以使线程等待、唤醒等操作
    public void waitMethod()&#123;
        try &#123;
            lock.lock();
            System.out.println(&quot;A&quot;);
            condition.await();//等待唤醒
            System.out.println(&quot;B&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
            System.out.println(&quot;释放锁&quot;);
        &#125;
    &#125;
&#125;
class MyThreadA extends Thread&#123;
    private MyService myService;
    public MyThreadA(MyService myService)&#123;
        super();
        this.myService =  myService;
    &#125;
    @Override
    public void run()&#123;
        myService.waitMethod();
    &#125;
&#125;
class TestMyService &#123;
    public static void main(String[] args) &#123;
        MyService myService = new MyService();
        MyThreadA a1 = new MyThreadA(myService);
        a1.start();
        MyThreadA a2 = new MyThreadA(myService);
        a2.start();
        MyThreadA a3 = new MyThreadA(myService);
        a3.start();

    &#125;

&#125;
</code></pre>
<h2 id="唤醒部分线程"><a href="#唤醒部分线程" class="headerlink" title="唤醒部分线程"></a>唤醒部分线程</h2><pre><code class="java">package cn.day.b7;

import cn.day.b6.MyThread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class MyService &#123;
    private ReentrantLock lock = new ReentrantLock();
    /*创建两个Condition对象，分别用来唤醒A、B线程*/
    private Condition conditionA = lock.newCondition();
    private Condition conditionB = lock.newCondition();
    
    public void awaitA()&#123;
        try &#123;
            lock.lock();
            System.out.println(&quot;A&quot;);
            conditionA.await();//等待唤醒
            System.out.println(&quot;A被唤醒&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
            System.out.println(&quot;释放锁&quot;);
        &#125;
    &#125;
    public void awaitB()&#123;
        try &#123;
            lock.lock();
            System.out.println(&quot;B&quot;);
            conditionB.await();//等待唤醒
            System.out.println(&quot;B被唤醒&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
            System.out.println(&quot;释放锁&quot;);
        &#125;
    &#125;
    
    
    public void signalAll_B()&#123;
        lock.lock();
        System.out.println(&quot;唤醒B线程&quot;);
        conditionB.signalAll();//仅唤醒全部B种线程（相同锁）
        lock.unlock();
    &#125;
    public void signalAll_A()&#123;
        lock.lock();
        System.out.println(&quot;唤醒A线程&quot;);////仅唤醒全部A种线程（相同锁）
        conditionA.signalAll();
        lock.unlock();
    &#125;
&#125;


class MyThreadA extends Thread&#123;
    private MyService myService;
    public MyThreadA(MyService myService)&#123;
        super();
        this.myService =  myService;
    &#125;
    @Override
    public void run()&#123;
        myService.awaitA();
    &#125;
&#125;
class MyThreadB extends Thread&#123;
    private MyService myService;
    public MyThreadB(MyService myService)&#123;
        super();
        this.myService =  myService;
    &#125;
    @Override
    public void run()&#123;
        myService.awaitB();
    &#125;
&#125;
class TestMyService &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        MyService myService = new MyService();
        MyThreadA a1 = new MyThreadA(myService);
        MyThreadA a2 = new MyThreadA(myService);
        MyThreadB b1 = new MyThreadB(myService);
        a1.setName(&quot;A1&quot;);
        a2.setName(&quot;A2&quot;);
        b1.setName(&quot;B&quot;);
        a1.start();
        a2.start();
        b1.start();
        System.out.println(&quot;等待3s&quot;);
        Thread.sleep(3000);
        myService.signalAll_A();//仅唤醒A种线程
    &#125;

&#125;
</code></pre>
<h1 id="生产者、消费者"><a href="#生产者、消费者" class="headerlink" title="生产者、消费者"></a>生产者、消费者</h1><p>1V1(生产、消费一对一)、多对多5V5</p>
<pre><code class="java">package cn.day.b7.ConditionTest;

import cn.day.b6.MyThread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class MyService &#123;
    private ReentrantLock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    private boolean hasValue = false;
    public void set()&#123;
        try &#123;
            lock.lock();
            if (hasValue == true) &#123;
                condition.await();
            &#125;
            System.out.println(&quot;生产者&quot;);
            hasValue = true;
            condition.signalAll();
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
    public void get()&#123;
        try &#123;
            lock.lock();
            if (hasValue == false) &#123;
                condition.await();
            &#125;
            System.out.println(&quot;消费者&quot;);
            hasValue = false;
            condition.signalAll();
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
class MyThreadA extends Thread&#123;
    private MyService myService;
    public MyThreadA(MyService myService)&#123;
        super();
        this.myService = myService;
    &#125;
    @Override
    public void run()&#123;
        for (int i =0; i &lt; Integer.MAX_VALUE;i++)&#123;
            myService.set();
        &#125;
    &#125;
&#125;
class MyThreadB extends Thread&#123;
    private MyService myService;
    public MyThreadB(MyService myService)&#123;
        super();
        this.myService = myService;
    &#125;
    @Override
    public void run()&#123;
        for (int i =0; i &lt; Integer.MAX_VALUE;i++)&#123;//Integer.MAX_VALUE常量的最大值
            myService.get();
        &#125;
    &#125;
&#125;
class Run&#123;
    public static void main(String[] args) &#123;
        MyService myService = new MyService();
        MyThreadA a = new MyThreadA(myService);
        a.start();
        MyThreadB b = new MyThreadB(myService);
        b.start();
    &#125;
&#125;
/*多对多*/
class Run1&#123;
    public static void main(String[] args) &#123;
        MyService Service = new MyService();
        MyThreadA[] threadA = new MyThreadA[5];
        MyThreadB[] threadB = new MyThreadB[5];
        for (int i = 0; i &lt; 5; i++)&#123;
            threadA[i] = new MyThreadA(Service);
            threadB[i] = new MyThreadB(Service);
            threadA[i].start();
            threadB[i].start();

        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><ul>
<li><p>共享锁（只读）</p>
<p>共享锁使只读的线程可异步执行；与写操作的线程同步执行</p>
</li>
</ul>
<pre><code class="java">public class MyService &#123;
    private ReentrantLock lock = new ReentrantReadWriteLock();//共享、排他锁
    private String name = &quot;张三&quot;
    public void get()&#123;
        try &#123;
            lock.readlock();//共享锁（异步，只读）
            System.out.println(name);
            Thread.sleep(4000);
            lock.readLock().unlock();//释放共享锁
          
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<ul>
<li><p>排他锁（写）</p>
<p>与其它锁同步执行</p>
</li>
</ul>
<pre><code class="java">public class MyService &#123;
    private ReentrantLock lock = new ReentrantReadWriteLock();//共享、排他锁
    private String name = &quot;张三&quot;
    public void set(String name)&#123;
        try &#123;
            lock.writelock();//排他锁（同步，只写）
            System.out.println(name);
            this.name = name;
            Thread.sleep(4000);
            lock.writeLock().unlock();//释放排他锁
          
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="一个定时任务实例"><a href="#一个定时任务实例" class="headerlink" title="一个定时任务实例"></a>一个定时任务实例</h2><pre><code class="java">package cn.day.b8;

import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class MyTask extends TimerTask &#123;//注意其父类哦
    @Override
    public void run() &#123;
        System.out.println(&quot;start Time：&quot; + System.currentTimeMillis());
    &#125;
&#125;
class Test&#123;
    public static void main(String[] args) throws InterruptedException &#123;
        long nowTime = System.currentTimeMillis();
        System.out.println(&quot;当前时间为： &quot;+ nowTime );
        long scheduleTime = (nowTime +10000);
        System.out.println(&quot;计划时间为： &quot;+ scheduleTime);
        MyTask task = new MyTask();
        Timer timer = new Timer();//创建一个新计时器
        Thread.sleep(1000);
        timer.schedule(task,new Date(scheduleTime));
        //在指定的时间执行任务，如指定时间早于当前时间则立即执行任务
        Thread.sleep(Integer.MAX_VALUE);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>创建一个Timer对象时，内部就创建了一个新线程（TimerTread）</p>
</li>
<li><p>TimerTread线程管理一个队列，队列按顺序执行Task任务</p>
</li>
<li><p>定时任务可由于当前任务的复杂度而导致下个任务延期执行</p>
</li>
</ul>
<h2 id="执行多个定时任务实例"><a href="#执行多个定时任务实例" class="headerlink" title="执行多个定时任务实例"></a>执行多个定时任务实例</h2><ul>
<li>任务执行算法每次将最后一个任务放入队头（第一次仍保持原序列）</li>
</ul>
<pre><code class="java">/*省略代码同上*/
class DoubleTest&#123;
    public static void main(String[] args) throws InterruptedException &#123;
        long nowTime = System.currentTimeMillis();
        System.out.println(&quot;当前时间为： &quot;+ nowTime );
        long scheduleTime1 = (nowTime +5000);
        long scheduleTime2 = (nowTime +6000);
        System.out.println(&quot;A计划时间为： &quot;+ scheduleTime1);
        System.out.println(&quot;B计划时间为： &quot;+ scheduleTime2);
        MyTask task1 = new MyTask();
        MyTask task2 = new MyTask();
        Timer timer = new Timer();//只用一个新计时器
        timer.schedule(task1,new Date(scheduleTime1));
        timer.schedule(task2,new Date(scheduleTime2));
    &#125;
&#125;
</code></pre>
<h2 id="定时间隔执行任务"><a href="#定时间隔执行任务" class="headerlink" title="定时间隔执行任务"></a>定时间隔执行任务</h2><ul>
<li>任务间隔也会因当前任务的复杂度而延期执行，也会因为任务中的Thread.sleep( 50000)而改变任务执行的间隔时间</li>
</ul>
<pre><code class="java">class Test&#123;
    public static void main(String[] args) throws InterruptedException &#123;
        long nowTime = System.currentTimeMillis();
        System.out.println(&quot;当前时间为： &quot;+ nowTime );
        long scheduleTime = (nowTime +10000);
        System.out.println(&quot;计划时间为： &quot;+ scheduleTime);
        MyTask task = new MyTask();
        Timer timer = new Timer();
        timer.schedule(task,new Date(scheduleTime),4000);
        //在指定时间执行任务（计划时间早于当前时间则立刻执行），且每间隔4s再次执行任务
        //timer.schedule(task,4000)则是延迟4s执行
        //timer.schedule(task,4000，2000)则是延迟4s执行并间隔2s无限执行此任务
        
    &#125;
&#125;
</code></pre>
<h2 id="移除TimerTread线程队列任务"><a href="#移除TimerTread线程队列任务" class="headerlink" title="移除TimerTread线程队列任务"></a>移除TimerTread线程队列任务</h2><ul>
<li><p>定时任务执行完毕后，进程也不会被销毁</p>
</li>
<li><p>TimerTask.cancel 移除当前任务</p>
</li>
<li><p>Timer.cancel 移除全部任务</p>
</li>
</ul>
<pre><code class="java">package cn.day.b8;

import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class MyTask1 extends TimerTask &#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;A run Timer &quot;+ System.currentTimeMillis());
        this.cancel();//将此任务移除TimerTread线程队列（不会中断本次任务）
        System.out.println(&quot;A任务移除&quot;);
    &#125;
&#125;
class MyTask2 extends TimerTask &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;B run Timer &quot;+ System.currentTimeMillis());
    &#125;
&#125;
class Test&#123;
    public static void main(String[] args) throws InterruptedException &#123;
        long nowTime = System.currentTimeMillis();
        System.out.println(&quot;当前时间为： &quot;+ nowTime );
        MyTask1 task1 = new MyTask1();
        MyTask2 task2 = new MyTask2();
        Timer timer = new Timer();
        timer.schedule(task1,new Date(nowTime),2000);
        timer.schedule(task2,new Date(nowTime),2000);
        Thread.sleep(5000);
        /*如 timer.cancel();前有死循环，则无法执行到 timer.cancel();这行； 
        timer.cancel()将无法获得队列锁，更无法移除队列中任务
        while(true)&#123;
            int i ++;
        &#125;*/
        timer.cancel();//移除TimerTread线程队列中所有任务
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java多线程编程" style=color:#607d8b>
                Java多线程编程
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/thread-03/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/thread-04/">
        <h2>
            线程加载与线程组
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="饿汉模式-立即加载"><a href="#饿汉模式-立即加载" class="headerlink" title="饿汉模式(立即加载)"></a>饿汉模式(立即加载)</h1><ul>
<li>使用类时已创建对象</li>
</ul>
<pre><code class="java">package cn.day.b8;

public class MyObject &#123;
    private static MyObject myObject = new MyObject();//使用类时已创建对象
    public static MyObject getInstance()&#123;
        return myObject;
    &#125;
&#125;
class Thread1 extends Thread &#123;
    @Override
    public void run()&#123;
        System.out.println(MyObject.getInstance().hashCode());
    &#125;
&#125;
class Run&#123;
    public static void main(String[] args) &#123;
        var t1 = new Thread1();
        var t2 = new Thread1();
        var t3 = new Thread1();
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<h1 id="懒汉模式（延迟加载）"><a href="#懒汉模式（延迟加载）" class="headerlink" title="懒汉模式（延迟加载）"></a>懒汉模式（延迟加载）</h1><ul>
<li>在属性方法（get方法）中实例化对象</li>
<li>双检查锁实现懒汉单例模式</li>
</ul>
<pre><code class="java">package cn.day.b8;
public class MyObject &#123;
    private  volatile static MyObject myObject ;// volatile增加了可见性，阻止了创建MyObject时的代码重排
    public static MyObject getInstance()&#123;
        try &#123;
            if (myObject != null)&#123;
            &#125;else &#123;
                Thread.sleep(3000);
                synchronized (MyObject.class)&#123;
                    if (myObject == null)&#123;
                        myObject = new MyObject();
                    &#125;
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return myObject;
    &#125;
&#125;
class Thread1 extends Thread &#123;
    @Override
    public void run()&#123;
        System.out.println(MyObject.getInstance().hashCode());
    &#125;
&#125;
class Run&#123;
    public static void main(String[] args) &#123;
        var t1 = new Thread1();
        var t2 = new Thread1();
        var t3 = new Thread1();
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<ul>
<li>静态内部类实现懒汉模式</li>
</ul>
<pre><code class="java">package cn.day.b8;

public class MyObject &#123;
    /*静态代码块实现懒汉模式
        private static MyObject myObject = null;
        static&#123;
            myObject = new MyObject();
        &#125;
    */
    private static class MyObjectHandler &#123;
        private volatile static MyObject myObject = new MyObject();
    &#125;
    public static MyObject getInstance() &#123;
        return MyObjectHandler.myObject;
    &#125;
&#125;
class Thread1 extends Thread &#123;
    @Override
    public void run()&#123;
        System.out.println(MyObject.getInstance().hashCode());
    &#125;
&#125;
class Run&#123;
    public static void main(String[] args) &#123;
        var t1 = new Thread1();
        var t2 = new Thread1();
        var t3 = new Thread1();
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><ul>
<li>一级关联：组中有线程而无线程下的线程</li>
</ul>
<pre><code class="java">package cn.day.b8;

public class MyThread &#123;
    public static void main(String[] args) &#123;
        ThreadA aRunnable = new ThreadA();
        ThreadB bRunnable = new ThreadB();
        ThreadGroup group = new ThreadGroup(&quot;一级关联组&quot;);//构造一个新线程组。
        Thread aThread = new Thread(group,aRunnable);//加入线程组
        Thread bThread = new Thread(group,bRunnable);
        aThread.start();
        bThread.start();
        System.out.println(&quot;线组中线程程数 &quot;+ group.activeCount());//返回该线程组及其子组的数量的估计值
        System.out.println(&quot;线程组名 &quot;+ group.getName());//返回该线程组的名称
        Thread.sleep(3000);
        group.interrupt();//停止此线程组中所有线程
        Thread.enumerate(group);//将当前线程的线程组整体复制到指定线程组
    &#125;
&#125;
class ThreadA extends Thread&#123;
    @Override
    public void run()&#123;
        try &#123;
            while (!Thread.currentThread().isInterrupted())&#123;
                System.out.println(&quot;ThreadName &quot;+ Thread.currentThread().getName());
                Thread.sleep(3000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class ThreadB extends Thread&#123;
    @Override
    public void run()&#123;
        try &#123;
            while (!Thread.currentThread().isInterrupted())&#123;
                System.out.println(&quot;ThreadName &quot;+ Thread.currentThread().getName());
                Thread.sleep(3000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java多线程编程" style=color:#6484be>
                Java多线程编程
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/thread-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/thread-05/">
        <h2>
            Thread与Runable
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <pre><code class="java">import java.io.*;
import java.lang.Thread;
/**
 * 多个线程加载同一个Runnable可实现共享数据*/

class MyThread extends Thread&#123;
    public int x = 0;

    public void run()&#123;
        System.out.println(++x);
    &#125;
&#125;
class RThread implements Runnable&#123;
    private int x = 0;
    public void run()&#123;
        System.out.println(++x);
    &#125;
&#125;

public class Java_3 &#123;
    public static void main(String[] args) throws Exception&#123;
        for(int i=0;i&lt;5;i++)&#123;
            Thread t = new MyThread();
            t.start();
        &#125;
        Thread.sleep(1000);
        System.out.println();
        RThread r = new RThread();
        for(int i=0;i&lt;5;i++)&#123;
            Thread t = new Thread(r);//多个线程同时加载一个Runnable
            t.start();
        &#125;
    &#125;
&#125;
/**运行结果：
1
1
1
1
1

1
2
3
4
5

*/
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java多线程编程" style=color:#006674>
                Java多线程编程
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/thread-05/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/│⌡╩╢Spring/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h1><h2 id="IOC反转"><a href="#IOC反转" class="headerlink" title="IOC反转"></a>IOC反转</h2><p>由容器管理对象，将对象之间的依赖解耦</p>
<h3 id="基于XML的注入"><a href="#基于XML的注入" class="headerlink" title="基于XML的注入"></a>基于XML的注入</h3><p>####Set注入</p>
<p>spring调用类的set方法进行属性操作</p>
<p>两个实例类：</p>
<ul>
<li>User.java</li>
</ul>
<pre><code class="java">public class User &#123;
    private String name;
    private int age;
    private Company company;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Company getCompany() &#123;
        return company;
    &#125;

    public void setCompany(Company company) &#123;
        this.company = company;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, company=&quot; + company +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<ul>
<li>Company.java</li>
</ul>
<pre><code class="java">public class Company &#123;
    private String name;
    private String address;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAddress(String address) &#123;
        this.address = address;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Company&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;myUser&quot; class=&quot;cn.itthree.spring.bean2.User&quot;&gt;
        &lt;!--    set注入，即调用set方法对属性进行设置--&gt;
        &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
            &lt;!--当指定 bean 的某属性值为另一 bean 的实例时，通过 ref 指定它们间的引用关系。ref
的值必须为某 bean 的 id 值。
--&gt;
        &lt;property name=&quot;company&quot; ref=&quot;myCompany&quot;&gt;&lt;/property&gt;

    &lt;/bean&gt;
&lt;!--    在加载配置文件applicationContext.xml时spring会此xml将所有bean标签中的类均加载一遍，
所以不用在意bean标签的书写顺序--&gt;
    &lt;bean id=&quot;myCompany&quot; class=&quot;cn.itthree.spring.bean2.Company&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Alibaba&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>####构造器注入</p>
<p>spring调用有参构造器构造实例并为属性赋值</p>
<ul>
<li>User</li>
</ul>
<pre><code class="java">//为User类添加一个有参构造器
    public User(String name, int age, Company company) &#123;
        this.name = name;
        this.age = age;
        this.company = company;
    &#125;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;myUser&quot; class=&quot;cn.itthree.spring.bean3.User&quot;&gt;
        &lt;!--构造器注入spring调用有参构造器为属性赋值--&gt;
&lt;!--        name属性构造(可以乱序即不用在意属性的位置)--&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;company&quot; ref=&quot;myCompany&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;
&lt;!--        index索引构造(0-1-2分别对应着该类构造器的参数位置)--&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg index=&quot;2&quot; ref=&quot;myCompany&quot;&gt;&lt;/constructor-arg&gt;
&lt;!--  省略index（不能乱序，必须按构造器的参数顺序进行传值）      --&gt;
        &lt;constructor-arg value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;21&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg ref=&quot;myCompany&quot;&gt;&lt;/constructor-arg&gt;

    &lt;/bean&gt;
    &lt;!--    在加载配置文件applicationContext.xml时spring会此xml将所有bean标签中的类均加载一遍，
    所以不用在意bean标签的书写顺序--&gt;
    &lt;bean id=&quot;myCompany&quot; class=&quot;cn.itthree.spring.bean3.Company&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Alibaba&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="模块化管理xml"><a href="#模块化管理xml" class="headerlink" title="模块化管理xml"></a>模块化管理xml</h4><p>将原applicationContext.xml按功能及其所需，划分为若个xml每个xml指代一个功能或模块</p>
<ul>
<li>spring-company.xml（公司模块）</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;company&quot; class=&quot;cn.itthree.spring.bean5.Company&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Alibaba&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>spring-user.xml(用户模块)</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--   引用类型自动注入
      1.byName(按名称注入) ： 根据类的引用类型的属性名在bean中寻找有相同的bean id且类型相同的bean实现自动注入--&gt;
    &lt;bean id=&quot;myUser&quot; class=&quot;cn.itthree.spring.bean5.User&quot; autowire=&quot;byName&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>total.xml(指定所有功能模块的spring.xml的位置)</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;!--    在spring的配置文件中要指定其他文件的位置， 需要使用classpath，告诉spring到哪去加载读取文件。--&gt;
&lt;!-- 使用通配符加载bean6下所有文件名为spring-开头的xml--&gt;
&lt;import resource=&quot;classpath:bean5/spring-*.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>一个测试类</li>
</ul>
<pre><code class="java">package itthree.spring.bean5;

import cn.itthree.spring.bean5.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest 
&#123;
    @Test
    public void TestMyUser()&#123;
        //1.加载配置文件(注意applicationContext.xml的路径)
        String config = &quot;bean5/total.xml&quot;;
        //spring会在加载配置文件时生成对象
        ApplicationContext ac = new ClassPathXmlApplicationContext(config);
        User user = (User) ac.getBean(&quot;myUser&quot;);
        System.out.println(&quot; &quot;+user);
    &#125;
&#125;
</code></pre>
<h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><p>首先需要在spring配置文件中配置扫描器，写明注解所在包的基本信息</p>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--    base-package：指定注解在项目中的包名。
        spring会扫描遍历base-package指定的包，将包中和子包中的所有类中的注解，按照注解的功能创建对象，或给属性赋值。
--&gt;
&lt;context:component-scan base-package=&quot;cn.itthree.spring.ba01&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>注解分类</strong>：</p>
<ul>
<li>对象注解</li>
</ul>
<p>@Component: 等同于spring配置文件中的<bean></p>
<p><code>@Component(value = &quot;myStudent&quot;)</code>等同于</p>
<p><code>&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.ba01.Student&quot; /&gt; </code></p>
<ul>
<li>分层注解</li>
</ul>
<p>@Repository，@Service，@Controller是给项目的对象分层的,使用语法和@Component相同。</p>
<p>1.@Repository（用在持久层类的上面） : 放在dao的实现类上面，表示创建dao对象，dao对象是能访问数据库的。</p>
<p>2.@Service(用在业务层类的上面)：放在service的实现类上面，创建service对象，service对象是做业务处理，可以有事务等功能的。</p>
<p>3.@Controller(用在控制器的上面)：放在控制器（处理器）类的上面，创建控制器对象的，控制器对象，能够接受用户提交的参数，显示请求的处理结果。</p>
<ul>
<li>属性注解</li>
</ul>
<p>以下注解均可以在不包含set方法的类中使用，如果写在set方法上，那么就调用set方法进行属性设置</p>
<p> <strong>简单类型的属性赋值注解</strong>：</p>
<p> @Value:，在属性定义的上面，无需set方法。</p>
<p><strong>引用类型注解</strong>：</p>
<ol>
<li><p>@Autowired: 实现引用类型的赋值，持byName, byType，默认使用的是byType自动注入，此注解由spring框架提供。</p>
<p>如果要使用byName方式，需要在属性上面加入@Autowired再将@Qualifier(value=”bean的id”) 写到属性上面：表示使用指定名称的bean完成赋值。</p>
</li>
</ol>
<p>2.@Resource: 来自jdk中的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值，使用的也是自动注入原理，支持byName， byType .默认是byName（当byName失败时使用byType）</p>
<ul>
<li>User.java</li>
</ul>
<pre><code class="java">package cn.itthree.spring.ba01;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;



//实例化一个名为myUser的对象
@Component(&quot;myUser&quot;)

public class User &#123;
    @Value(&quot;王魏振&quot;)
    private String name;
    @Value(&quot;32&quot;)
    private Integer age;

    //byName自动注入
    //@Autowired(required = false)时如找不到指定bean id则不报错，默认为@Autowired(required = true)
    @Autowired
    @Qualifier(&quot;company&quot;)
    private Company company;

    //默认是byName： 先使用byName自动注入，如果byName赋值失败，再使用byType
    @Resource
    private Car car;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, company=&quot; + company +
                &quot;, car=&quot; + car +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<ul>
<li>Company.java</li>
</ul>
<pre><code class="java">package cn.itthree.spring.ba01;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
//不指定对象名称，由spring提供默认名称: 类名的首字母小写,即此类对象名称为company
@Component
public class Company &#123;
    public Company() &#123;

    &#125;
    @Value(&quot;Alibaba&quot;)
    private String name;
    @Value(&quot;北京&quot;)
    private String address;

    @Override
    public String toString() &#123;
        return &quot;Company&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">package org.example;

import static org.junit.Assert.assertTrue;

import cn.itthree.spring.ba01.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Unit test for simple App.
 */
public class AppTest 
&#123;
    /**
     * Rigorous Test :-)
     */
    @Test
    public void testDiA()&#123;
        String config = &quot;applicationContext.xml&quot;;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        User user = (User) ctx.getBean(&quot;myUser&quot;);
        System.out.println(&quot; &quot;+ user);


    &#125;
&#125;
</code></pre>
<p>Car.java</p>
<pre><code class="java">package cn.itthree.spring.ba01;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Car &#123;

    private String name;
    @Value(&quot;五菱宏光&quot;)
    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Car&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><h3 id="AspectJ-面向切面编程的实现"><a href="#AspectJ-面向切面编程的实现" class="headerlink" title="AspectJ 面向切面编程的实现"></a>AspectJ 面向切面编程的实现</h3><p>AspectJ 中常用的通知有五种类型： （1）<strong>前置通知</strong> （2）<strong>后置通知 **（3）</strong>环绕通知 **（4）异常通知 （5）最终通知</p>
<p>AspectJ切入点表达式：</p>
<p>表达式的原型是：<code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</code></p>
<p>其中：modifiers-pattern] 访问权限类型；</p>
<p> ret-type-pattern 返回值类型 ；</p>
<p>declaring-type-pattern 包名类名；</p>
<p> name-pattern(param-pattern) 方法名(参数类型和参数个数)；</p>
<p> throws-pattern 抛出异常类型 ；</p>
<p>带？的表示可选部分</p>
<p>表达式中可使用以下字符：</p>
<p><img src="C:\Users\17630\AppData\Roaming\Typora\typora-user-images\image-20201219212752592.png" alt="image-20201219212752592"></p>
<p>目标类</p>
<pre><code class="java">package cn.itthree.aop.ba01;

public class SomeServiceImpl implements SomeService&#123;
    @Override
    public void doSome(String name, Integer age) &#123;
        System.out.println(&quot;目标方法doSome&quot;+name+age);
    &#125;

    @Override
    public String doOther(String name, int age) &#123;
        System.out.println(&quot;doOther已执行&quot;);
        return &quot;123&quot;;
    &#125;
    @Override
    public String doFirst(String name, Integer age) &#123;
        System.out.println(&quot;====业务方法doFirst()====&quot;);

        return &quot;doFirst&quot;;
    &#125;
&#125;
</code></pre>
<p>目标类实现接口</p>
<pre><code class="java">package cn.itthree.aop.ba01;

public interface SomeService &#123;
    void doSome(String name,Integer age);
    String doOther(String name, int age);
    String doFirst(String name,Integer age);
&#125;
</code></pre>
<p><strong>JoinPoint</strong>类型参数可获取切入点表达式、方法签名、目标对象等，所有通知方法均可使用，<strong>JoinPoint</strong>类型参数必须写在方法内第一个参数的位置。</p>
<h3 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h3><p>@Before</p>
<p>在目标方法之前执行</p>
<h3 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h3><p> @AfterReturning</p>
<p>在目标方法执行之后执行，可以获取到目标方法的返回 值。</p>
<h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><ol>
<li>在目标方法的前后进行功能增强。</li>
<li>控制目标方法是否被调用执行</li>
<li>修改原来的目标方法的执行结果。 影响最后的调用结果     </li>
</ol>
<pre><code class="java">package cn.itthree.aop.ba01;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.beans.factory.annotation.Qualifier;

import java.util.Date;

@Aspect
public class MyAspect &#123;

//    @Before(value = &quot;execution(void *..SomeServiceImpl.doSome(String,Integer))&quot;)
//    public void myBefore()&#123;
//        System.out.println(&quot;Start&quot;+new Date());
//    &#125;
    
    //@Before: 前置通知注解,value 是切入点表达式，指定切面的功能执行的位置
    @Before(value = &quot;execution(* do*(..))&quot;)

    public void myBefore(JoinPoint jp)&#123;
    //JoinPoint参数，可获取切入点表达式、方法签名、目标对象等。
    //所有通知方法均可使用JoinPoint 类型参数，
        System.out.println(&quot;Start Time \n&quot;+new Date());
        for (Object arg:jp.getArgs()) &#123;
            System.out.println(&quot;前置参数= &quot;+arg);
        &#125;
        System.out.println();
    &#125;
    
    
    
    //后置通知
    @AfterReturning(value = &quot;execution(* doSome(..))&quot;)
    public void myAfter()&#123;
        System.out.println(&quot;End Time \n&quot;+new Date());
    &#125;

    // 注解的 returning 属性就是用于指定接收方法返回值的变量名的
    @AfterReturning(value = &quot;execution(* doOther(..))&quot;,returning = &quot;result&quot;)
    public Object myAfterR(Object result)&#123;
        Object return1 =  &quot;&quot;;
        if (result != null)&#123;
            String s = (String)result;
            result = s.indexOf(1);
            return1 =  result;
        &#125;
        System.out.println(&quot;后置通知时改变返回值为： &quot;+result);
        return return1;
    &#125;
    


//环绕通知必须有一个返回值，一般使用Object
//环绕通知的参数类型固定为 ProceedingJoinPoint，用于接收（调用.proceed方法后）执行目标类方法的返回值
 @Around(value = &quot;myPt()&quot;)
    public Object myAround(ProceedingJoinPoint pjp) throws Throwable &#123;
        String name = &quot;&quot;;
        //目标方法前从参数中取值
        Object args[] =pjp.getArgs();
        if (args!=null &amp;&amp; args.length &gt;1)&#123;
            Object arg = args[0];
            name = (String)arg;
        &#125;
        Object result = null;
        System.out.println(&quot;已获取目标方法参数，在目标方法前\n&quot;+new Date());
        //调用目标方法
        if (&quot;李四&quot;.equals(name))&#123;
            //proceed方法执行返回的值就是result的值
            result = pjp.proceed();
        &#125;
        System.out.println(&quot;在目标方法后，添加功能\n&quot;+new Date());
        if (result!=null)&#123;
            result = &quot;editTime: &quot;+new Date();
        &#125;
        return result;


    &#125;


    //指定SomeServiceImpl.doFirst方法的别名为myPt,可在其他切面方法的切面表达式中使用别名代替原目标方法名
    @Pointcut(value = &quot;execution(* *..SomeServiceImpl.doFirst(..))&quot;)
    private void myPt()&#123;

    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">package org.example;

import static org.junit.Assert.assertTrue;

import cn.itthree.aop.ba01.SomeService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Unit test for simple App.
 */
public class AppTest 
&#123;

    @Test
    public void shouldAnswerWithTrue()
    &#123;
        String config=&quot;applicationContext.xml&quot;;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取目标对象,此处用到了JDK动态代理
        SomeService proxy = (SomeService) ctx.getBean(&quot;someService&quot;);
        System.out.println(&quot;proxy&quot;+proxy.getClass().getName());

//        proxy.doSome(&quot;李四&quot;,3);
//        String return1 = proxy.doOther(&quot;李四&quot;,3);
        String return2 = proxy.doFirst(&quot;李四&quot;,9);
        System.out.println(return2);

        //此时值仍为123
    &#125;
&#125;
</code></pre>
<p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
&lt;!--    目标类--&gt;
    &lt;bean id=&quot;someService&quot; class=&quot;cn.itthree.aop.ba01.SomeServiceImpl&quot;/&gt;
&lt;!--    切面类--&gt;
    &lt;bean id=&quot;myAspect&quot; class=&quot;cn.itthree.aop.ba01.MyAspect&quot;/&gt;
    &lt;!--    使用cglib动态代理--&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/util&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util
       https://www.springframework.org/schema/util/spring-util.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!--1、声明数据源DataSource, 作用是连接数据库的--&gt;
    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;
          init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;&lt;!--setUrl()--&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;
    &lt;/bean&gt;


    &lt;!--2、声明的是mybatis中提供的SqlSessionFactoryBean类--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
        &lt;!--mybatis主配置文件的位置
           configLocation属性是Resource类型，读取配置文件
           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置
        --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--3、创建dao对象，使用SqlSession的getMapper（StudentDao.class）
        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。
    --&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--指定SqlSessionFactory对象的id--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;
        &lt;!--指定包名， 包名是dao接口所在的包名。
            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行
            一次getMapper()方法，得到每个接口的dao对象。
            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写
        --&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;cn.itthree.spring.dao&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--声明service--&gt;
    &lt;bean id=&quot;buyService&quot; class=&quot;cn.itthree.spring.service.Impl.BuyGoodsServiceImpl&quot;&gt;
        &lt;property name=&quot;goodsDao&quot; ref=&quot;goodsDao&quot; /&gt;
        &lt;property name=&quot;saleDao&quot; ref=&quot;saleDao&quot; /&gt;
    &lt;/bean&gt;
    &lt;!--使用spring的事务处理--&gt;
    &lt;!--1. 声明事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--连接的数据库， 指定数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--2. 开启事务注解驱动，告诉spring使用注解管理事务，创建代理对象
           transaction-manager:事务管理器对象的id
    --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--name:实体类所在的包名
        --&gt;
        &lt;package name=&quot;cn.itthree.spring.domain&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!-- sql mapper(sql映射文件)的位置--&gt;
    &lt;mappers&gt;
        &lt;!--
       name：是包名， 这个包中的所有mapper.xml一次都能加载
        --&gt;
        &lt;package name=&quot;cn.itthree.spring.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/│⌡╩╢Spring/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/┤«╞Ñ┼Σ/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="串匹配"><a href="#串匹配" class="headerlink" title="串匹配"></a>串匹配</h1><h2 id="串的链式存储与朴素-简单-匹配"><a href="#串的链式存储与朴素-简单-匹配" class="headerlink" title="串的链式存储与朴素(简单)匹配"></a>串的链式存储与朴素(简单)匹配</h2><pre><code class="c">/*
 * @Author: itThree
 * @Date: 2021-09-17 16:46:14
 * @LastEditTime: 2021-09-19 15:59:37
 * @Description: 
 * @FilePath: \cpp\datas\myString.cpp
 * 光阴之逆旅，百代之过客，而已
 */
#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
//定长的串
#define MAXSIZE 255
typedef struct 
&#123;
   char ch[MAXSIZE];
   int length;
&#125;limString;

//动态分配的串
typedef struct
&#123;
    char* ch;
    int lenght;
&#125;dyString;

//简单匹配
int simple(limString* n, limString* m);

//创建一个串
void createString(limString* &amp;S,int type)&#123;
    S = (limString*)malloc(sizeof(limString));
    char inputC[255];
    scanf(&quot;%s&quot;,inputC);
    //记录输入串的长度
    int i = 0;
    while (inputC[i]!=0)
    &#123;
        S-&gt;ch[i] = inputC[i];
        i++;
    &#125;
    S-&gt;length = i;
&#125;

//此实现，当T中包含多个P时，仅返回最后一个
int simple(limString* T, limString* P)&#123;
    
    int n = T-&gt;length;
    int m = P-&gt;length;
    //p记录结果的索引
    int p = 0;
    //s为偏移量
    for (int s=0; s&lt;n-m+1; s++)
    &#123;
        for (int i = 0; i &lt; m; i++)
        &#123;
            if(P-&gt;ch[i] == T-&gt;ch[s+i])&#123;
                //当文本T与模式P相同则记录索引
               p = s+i;
            &#125;else&#123;
                break;
            &#125;
        &#125;
    &#125;

    //如果最终记录的索引p,同P中最后一个元素相同，我们认为匹配到了
    if (T-&gt;ch[p] == P-&gt;ch[m-1])
    &#123;//返回P对应于T的首索引
       return p-m+1;
    &#125;
    
    return 0;
&#125;

int main()&#123;

    limString* T,*P;
    createString(T,1);
    createString(P,1);
    // printf(&quot;%s\t%d&quot;,S,S-&gt;length);
    int p = simple(T,P);
    printf(&quot;%d&quot;,p);
    return 0;
  
&#125;
</code></pre>
<h2 id="RKM匹配"><a href="#RKM匹配" class="headerlink" title="RKM匹配"></a>RKM匹配</h2><p>使用函数：</p>
<pre><code class="c">//判断P是否为T的子串
int ifTP(TYPE* T, TYPE* P, int m, int s, int pHash);
int simpleComparsion(TYPE* T, TYPE* P, int m);
//主程序，计算偏移地址，控制程序整体迭代
int intRKM(TYPE* T, TYPE* P, int m, int n, int q);
//返回串的Hash
int countHash(TYPE* P, int m);
</code></pre>
<p>主体实现：</p>
<pre><code class="c">/*
 * @Author: itThree
 * @Date: 2021-09-28 17:38:05
 * @LastEditTime: 2021-09-29 23:08:34
 * @Description: 实现基于RKM的字符串匹配。
 * 注意关于char转换到int,直接使用了强制类型转换；
 * 所得的int将对应于ascll表，对于不在表中的元素，那么将无法匹配（异常终止），由于使用c语言，故不作过多处理。
 * @FilePath: \cpp\sort\RKM_char.cpp
 * 光阴之逆旅，百代之过客，而已
 */
#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define TYPE char
#define M 3
#define N 10




//传入任意串计算hash
int countHash(TYPE* P, int m)&#123;
    int p = 0;
    //计算hash的基准值
    int datum = 127;
    //首地址下元素乘以基准值
    p = ((int)*(P))*datum;
    TYPE * I = P;
    for (int i = 1; i &lt; m; i++)
    &#123;   
        I = I+i*sizeof(TYPE);
        p += ((int)*(I));
    // printf(&quot;%d\t%d\n&quot;,p,t);
    &#125;
    // printf(&quot;p=%d\n&quot;,p);
    return p;

&#125;

int ifTP(TYPE* T, TYPE* P, int m, int s, int pHash)&#123;
    //为T加上偏移
    
    T = T+s*sizeof(TYPE);
    
    int tHash = countHash(T,m);
    printf(&quot;%d\t%d\n&quot;,pHash,tHash);
    printf(&quot;------------------------------------\n&quot;);
    //再次判断
    if(tHash == pHash)&#123;
        //此时的T处理过偏移，故无需传入偏移
        return simpleComparsion(T,P,m);
    &#125;
    return 0;
&#125;

//对hash值相等的串，进行二次检查。
//这将逐个检查每个元素。
int simpleComparsion(TYPE* T, TYPE* P, int m)&#123;
    for (int i = 0; i &lt; m; i++)
    &#123;  //直接T+i也是可以的
        T = T + (i)*sizeof(TYPE);
        P = P + (i)*sizeof(TYPE);
        if(*(P) != *(T))&#123;
            return 0;
        &#125;
    &#125;
    
    return 1;
&#125;


int intRKM(TYPE* T, TYPE* P, int m, int n)&#123;
    //先计算P的Hash
    int pHash = countHash(P,m);
    int z = 0;
    //循环计算所有可能的T子串的Hash,并分别与pHash进行比较
    for (int i = 0; i &lt; n-m+1; i++)
    &#123;   //每次迭代的i即为T的最新偏移地址
        //偏移地址即每次循环中最新的T子串的首地址。
        //因为数组下标从0而不是1开始，故判断条件为n-m+1
        z++;
        printf(&quot;第%d次执行\n&quot;,z);
       if(ifTP(T,P,m,i,pHash))&#123;
           return 1;
       &#125;
    &#125;
    
    return 0;
&#125;
int main()&#123;
    //P存放匹配串即模式，T存放文本串即被匹配串，从T中找p
    TYPE P[M],T[N];
    printf(&quot;请输入文本T:\n&quot;);
    scanf(&quot;%s&quot;,T);
    printf(&quot;请输入匹配P:\n&quot;);
    scanf(&quot;%s&quot;,P);
    //aBool为1时：T包含P,反之不然
    int aBool = intRKM(T,P,M,N);
    printf(&quot;%d&quot;,aBool);
   
&#125;
</code></pre>
<p>测试结果：</p>
<p><img src="http://img.lbkzw.cn/img/image-20210929231606933.png" alt="image-20210929231606933"></p>
<p>附初代版本：</p>
<pre><code class="c">/*
 * @Author: itThree
 * @Date: 2021-09-28 17:38:05
 * @LastEditTime: 2021-09-29 20:48:02
 * @Description: 判断int类型串T中是否包含串P
 * @FilePath: \cpp\sort\RKM.cpp
 * 光阴之逆旅，百代之过客，而已
 */
#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include&lt;math.h&gt;

#define TYPE int

int ifTP(TYPE* T, TYPE* P, int m, int q, int s);
int simpleComparsion(TYPE* T, TYPE* P, int m, int s);
int intRKM(TYPE* T, TYPE* P, int m, int n, int q);

//判断每次偏移后的T于P是否匹配
int ifTP(TYPE* T, TYPE* P, int m, int q, int s)&#123;
    int h = 10;
    int p = 0;
    int t = 0;
    for (int i = 0; i &lt; m; i++)
    &#123;   
        int n = pow(h,(m-i-1));
        p += *(P+i)*n;
        t += *(T+i+s)*n;
    // printf(&quot;%d\t%d\n&quot;,p,t);

    &#125;
    printf(&quot;%d\t%d\n&quot;,p,t);
    printf(&quot;------------------------------------\n&quot;);
    //再次判断
    if((p%q) == (t%q))&#123;
        return simpleComparsion(T,P,m,s);
    &#125;
    return 0;
&#125;

//对hash值相等的串，进行二次检查。
//这将逐个检查每个元素。
int simpleComparsion(TYPE* T, TYPE* P, int m, int s)&#123;
    for (int i = 0; i &lt; m; i++)
    &#123;
        if(*(P+i) != *(T+i+s))&#123;
            return 0;
        &#125;
    &#125;
    
    return 1;
&#125;


/**
 * @description: 
 * @param &#123;TYPE*&#125; T
 * @param &#123;TYPE*&#125; P
 * @param &#123;int&#125; m为P的长度
 * @param &#123;int&#125; n为T的长度
 * @param &#123;int&#125; q为mod
 * @return &#123;
 *  1:T中包含P;
 *  0:T中不包含P
 * &#125;
 */
int intRKM(TYPE* T, TYPE* P, int m, int n, int q)&#123;
    //改变基准地址,进行T/P匹配
    //因为数组下标从0而不是1开始，故判断条件为n-m+1
    for (int i = 0; i &lt; n-m+1; i++)
    &#123;   
       if(ifTP(T,P,m,q,i))&#123;
           //如一个T中包含多个P,可在此处改进记录位置
           return 1;
       &#125;
    &#125;
    
    return 0;
&#125;
int main()&#123;
    int P[3] = &#123;1,2,3&#125;;
    int T[10] = &#123;4,5,6,3,2,1,3&#125;;
    int a = intRKM(T,P,3,10,3);
    printf(&quot;%d&quot;,a);
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/┤«╞Ñ┼Σ/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/╧í╩Φ╩²╫Θ/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><pre><code class="c">/*
 * @Author: itThree
 * @Date: 2021-09-10 15:48:10
 * @LastEditTime: 2021-09-15 15:58:50
 * @Description: 
 * @FilePath: \cpp\datas\sparseArr.cpp
 * 光阴之逆旅，百代之过客，而已
 */

#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

void printArr(int *arr, int row, int col);

/**
 * 稀疏数组：将二维数组进行“压缩”；
 * 使用n+1行3列，其中n为原数组中有效（非零）元素个数，稀疏数组第0行用于存放行、列、元素总数信息故需n+1行
*/

//统计数组中元素的个数，用于确定稀疏数组的行数
int countElement(int* &amp;p, int row, int col)&#123;
    int sum;
    int n = row*col;
    for(int i=0; i&lt;n; i++)&#123;
        if(*(p+i) != 0)&#123;
            sum++;
        &#125;
    &#125;
    printf(&quot;sum:\t%d\n&quot;,sum);
    return sum;

&#125;

//以指针形式接收矩阵（二维数组）
void createSparseArr2(int* arr, int row, int col ,int n)&#123;
    int sparse[n+1][3];
    sparse[0][0] = row;
    sparse[0][1] = col;
    sparse[0][2] = n;
    int sparseRow = 0;
    for(int i=0;i&lt;row;i++)&#123;
        for(int j=0;j&lt;col;j++)&#123;
            if(*(arr+i*col+j)!=0)&#123;
               sparseRow++;
               sparse[sparseRow][0] = i;
               sparse[sparseRow][1] = j;
               sparse[sparseRow][2] = *(arr+i*col+j);
           &#125;
        &#125;            
    &#125;
    printArr((int*)sparse,n+1,3);
&#125;
//这个稀疏数组的存储算法为n^2，还可用指针实现一个n。


//打印二维数组
void printArr(int *arr, int row, int col)
&#123;//指针指向二维数组首地址，依靠row,col判别边界条件
    //遍历行
    for(int i=0;i&lt;row;i++)&#123;
        //遍历列
        for(int j=0;j&lt;col;j++)printf(&quot;%d \t&quot;,*(arr+i*col+j));
        printf(&quot;\n&quot;);
    &#125;

&#125;

int main()&#123;
    int source[4][8]&#123;
        &#123;1,7,6,5,2,8,2,8&#125;,
        &#123;2,7,6,5,2,8,2,8&#125;,
        &#123;3,7,6,5,2,8,2,8&#125;,
        &#123;4,7,6,5,2,8,2,8&#125;
    &#125;;
    int* p;
    p = source[0];
    int n = countElement(p,4,8);
    printf(&quot;-------------------------------------------\n&quot;);
    
    createSparseArr2((int*)source,4,8,n);
    //int* i[4];
    //指针i指向二维数组的一行
    //i[0] = source[0];
    //i[1] = source [1];
    //i[2] = source [2];
    //i[3] = source [3];
    // createSparseArr1(i,4,8,n);
    return 0;
&#125;
</code></pre>
<h2 id="使用指针数组方式创建稀疏数组"><a href="#使用指针数组方式创建稀疏数组" class="headerlink" title="使用指针数组方式创建稀疏数组"></a>使用指针数组方式创建稀疏数组</h2><pre><code class="c">//使用指针数组传值
void createSparseArr1(int* p1[], int row, int col, int n)&#123;
    //需要多一行来存储原数组大小信息
    int sparse[n+1][3];
    sparse[0][0] = row;
    sparse[0][1] = col;
    sparse[0][2] = n;
    //控制稀疏数组的行号
    int sparseRow = 0;
    for (int i = 0; i &lt; row; i++)
   &#123;
       for (int j = 0; j &lt; col; j++)
       &#123;    //原数数组索引处有无元素为判断条件，有则放入稀疏数组，无则进行下一次循环
           if(p1[i][j]!=0)&#123;
               //第0行已存放数据，故先行++
               sparseRow++;
               sparse[sparseRow][0] = i;
               sparse[sparseRow][1] = j;
               sparse[sparseRow][2] = p1[i][j];
           &#125;
       &#125;
       
   &#125;
    printArr((int*)sparse,n+1,3);
&#125;
</code></pre>
<h1 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h1><h2 id="强制转换数组首地址为指针返回不可行"><a href="#强制转换数组首地址为指针返回不可行" class="headerlink" title="强制转换数组首地址为指针返回不可行"></a>强制转换数组首地址为指针返回不可行</h2><p><img src="http://img.lbkzw.cn/img/image-20210915152000718.png" alt="image-20210915152000718"></p>
<p>报错的地方：</p>
<pre><code class="c">int sparse[n+1][3];
return (int*) sparse;
</code></pre>
<p><strong>解答</strong>：在函数执行完毕并return后sparse数组将被销毁，故无法将其强制转换为指针类型并返回；</p>
<p>不过，指定一个指针指向sparse并返回倒不成问题。</p>
<h2 id="指针与数组地址"><a href="#指针与数组地址" class="headerlink" title="指针与数组地址"></a>指针与数组地址</h2><pre><code class="c">int source[4][8]&#123;
        &#123;1,7,6,5,2,8,2,8&#125;,
        &#123;2,7,6,5,2,8,2,8&#125;,
        &#123;3,7,6,5,2,8,2,8&#125;,
        &#123;4,7,6,5,2,8,2,8&#125;
    &#125;;
    int* p;
    p = source[0];
    int* i[4];
    //指针i指向二维数组的一行
    i[0] = source[0];
    i[1] = source [1];
    i[2] = source [2];
    i[3] = source [3];
//得出结果
    // source[0]，source[0][0]在同一地址下
     printf(&quot;p:\t%d\n&quot;, p);
    printf(&quot;source[0]:\t%d\n&quot;, source[0]);
    printf(&quot;&amp;source[0][0]:\t%d\n&quot;, &amp;source[0][0]);
    printf(&quot;source[0][0]:\t%d\n&quot;, source[0][0]);
    printf(&quot;*p:\t%d\n&quot;, *p);
    //使用指针数组指向二维数组每行首地址可行
    printf(&quot;i[1][i]:\t%d\n&quot;, i[1][2]);
    
    printf(&quot;*(p+31)\t%d\n&quot;, *(p+31));
    //下标溢出了哦！
    printf(&quot;*(p+32)\t%d\n&quot;, *(p+32));
</code></pre>
<p>运行结果：<img src="http://img.lbkzw.cn/img/image-20210915153230219.png" alt="image-20210915153230219"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/╧í╩Φ╩²╫Θ/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/6">
                <span class="page-num">
                    6
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>