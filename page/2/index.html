
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2020/10/16/Java-07/">
        <h2>
            异常
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><img src="http://img.lbkzw.cn/img/20200821102446.png" alt="img"></p>
<ul>
<li><p>RuntimeException(运行时异常)会自动被 java 虚拟机抛出，所以不必在异常说明中把它们列出来,也不需要在异常说明中声明方法将抛出 RuntimeException 类型的异常</p>
</li>
<li><p>RuntimeException 也被称为“不受检查异常”，将被自动捕获,如果 没有被捕获而直达 main()，那么在程序退出前将调用异常的 printStackTrace() 方法。(返回栈轨迹信息)</p>
</li>
<li><p>要么<strong>声明</strong>异常要么<strong>处理</strong>异常(只有在你知道如何处理的情况下才捕获异常)。</p>
<pre><code class="java">package cn.day.a2;

// exceptions/LostMessage.java
// How an exception can be lost
class VeryImportantException extends Exception &amp;#123;
    @Override
    public String toString() &amp;#123;
        return &quot;A very important exception!&quot;;
    &amp;#125;
&amp;#125;
class HoHumException extends Exception &amp;#123;
    @Override
    public String toString() &amp;#123;
        return &quot;A trivial exception&quot;;
    &amp;#125;
&amp;#125;
public class LostMessage &amp;#123;
    void f() throws VeryImportantException &amp;#123;
        throw new VeryImportantException();
    &amp;#125;
    void dispose() throws HoHumException &amp;#123;
        throw new HoHumException();
    &amp;#125;
    /*声明异常，而不做处理（交给调用的人处理）*/
    public static void main(String[] args) throws VeryImportantException &amp;#123;//仅仅声明异常

            LostMessage lm = new LostMessage();
                lm.f();

            &amp;#125;

    &amp;#125;
    /*捕获并处理异常*/
//    public static void main(String[] args)  &amp;#123;
//        try &amp;#123;
//            LostMessage lm = new LostMessage();
//            try &amp;#123;
//                lm.f();
//            &amp;#125; finally &amp;#123;
//                lm.dispose();
//            &amp;#125;
//        &amp;#125; catch(VeryImportantException | HoHumException e) &amp;#123;
//            System.out.println(e);
//        &amp;#125;
//        
//    &amp;#125;
//
//&amp;#125;

</code></pre>
</li>
</ul>
<pre><code>


* 可以通过**继承**异常基类来**自定义异常**

```java
class SimpleException extends Exception &amp;#123;&amp;#125;

public class InheritingExceptions &amp;#123;
    public void f() throws SimpleException &amp;#123;
        System.out.println(
                &quot;Throw SimpleException from f()&quot;);
        throw new SimpleException();
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        InheritingExceptions sed =
                new InheritingExceptions();
        try &amp;#123;
            sed.f();
        &amp;#125; catch(SimpleException e) &amp;#123;
            System.out.println(&quot;Caught it!&quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h1><h2 id="声明多个异常"><a href="#声明多个异常" class="headerlink" title="声明多个异常"></a>声明多个异常</h2><pre><code class="java">void f() throws TooBig, TooSmall, DivZero &amp;#123; // 方法体...&amp;#125;</code></pre>
<h2 id="声明所有异常"><a href="#声明所有异常" class="headerlink" title="声明所有异常"></a>声明所有异常</h2><pre><code class="java">catch(Exception e) &amp;#123;
    System.out.println(&quot;Caught an exception&quot;);
&amp;#125;</code></pre>
<h2 id="声明子异常捕获父异常"><a href="#声明子异常捕获父异常" class="headerlink" title="声明子异常捕获父异常"></a>声明子异常捕获父异常</h2><blockquote>
<p>java7之后就可以通过编译了</p>
</blockquote>
<pre><code class="java">class BaseException extends Exception &amp;#123;&amp;#125;
class DerivedException extends BaseException &amp;#123;&amp;#125;

public class PreciseRethrow &amp;#123;
    void catcher() throws DerivedException &amp;#123;//声明子异常
        try &amp;#123;
            throw new DerivedException();
        &amp;#125; catch(BaseException e) &amp;#123;//捕获父异常
            throw e;
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><h2 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h2><pre><code class="java">// exceptions/SameHandler.java
class EBase1 extends Exception &amp;#123;&amp;#125;
class Except1 extends EBase1 &amp;#123;&amp;#125;
class EBase2 extends Exception &amp;#123;&amp;#125;
class Except2 extends EBase2 &amp;#123;&amp;#125;
class EBase3 extends Exception &amp;#123;&amp;#125;
class Except3 extends EBase3 &amp;#123;&amp;#125;
class EBase4 extends Exception &amp;#123;&amp;#125;
class Except4 extends EBase4 &amp;#123;&amp;#125;

public class SameHandler &amp;#123;
    void x() throws Except1, Except2, Except3, Except4 &amp;#123;&amp;#125;
    void process() &amp;#123;&amp;#125;
    void f() &amp;#123;
        try &amp;#123;
            x();
            /*以下是分别捕获并处理异常*/
        &amp;#125; catch(Except1 e) &amp;#123;
            process();
        &amp;#125; catch(Except2 e) &amp;#123;
            process();
        &amp;#125; catch(Except3 e) &amp;#123;
            process();
        &amp;#125; catch(Except4 e) &amp;#123;
            process();
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h3 id="多重捕获"><a href="#多重捕获" class="headerlink" title="多重捕获"></a>多重捕获</h3><ul>
<li>java7之后即使不同类型的异常也可通过**|**来连接捕获，进行异常处理</li>
</ul>
<pre><code>// exceptions/MultiCatch.java
public class MultiCatch &amp;#123;
    void x() throws Except1, Except2, Except3, Except4 &amp;#123;&amp;#125;
    void process() &amp;#123;&amp;#125;
    void f() &amp;#123;
        try &amp;#123;
            x();

        &amp;#125; catch(Except1 | Except2 | Except3 | Except4 e) &amp;#123;
            process();
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h2><ul>
<li>重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略。此外，异常对象的所有信息都得以保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。</li>
</ul>
<pre><code class="java">catch(Exception e) &amp;#123;
    System.out.println(&quot;An exception was thrown&quot;);
    throw e;
&amp;#125;</code></pre>
<ul>
<li>当再次抛出异常时,printStackTrace() 方法显示的将是原来异常抛出点调用栈的信息，而并非重新抛出点的信息。可以调用 filInStackTrace() 方法更新异常抛出点调用栈的信息（这将返回一个 Throwable 对象）。</li>
</ul>
<pre><code class="java">package cn.day.a1;

public class Rethrowing &amp;#123;
    public static void f() throws Exception &amp;#123;
        System.out.println(
                &quot;originating the exception in f()&quot;);
        throw new Exception(&quot;thrown from f()&quot;);
    &amp;#125;
    public static void g() throws Exception &amp;#123;
        try &amp;#123;
            f();
        &amp;#125; catch(Exception e) &amp;#123;
            System.out.println(
                    &quot;Inside g(), e.printStackTrace()&quot;);
            e.printStackTrace(System.out);
            throw e;//再次抛出后没有更新
        &amp;#125;
    &amp;#125;
    public static void h() throws Exception &amp;#123;
        try &amp;#123;
            f();
        &amp;#125; catch(Exception e) &amp;#123;
            System.out.println(
                    &quot;Inside h(), e.printStackTrace()&quot;);
            e.printStackTrace(System.out);
            throw (Exception)e.fillInStackTrace();//抛出并更新
        &amp;#125;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            g();//抛出点的调用栈信息一致
        &amp;#125; catch(Exception e) &amp;#123;
            System.out.println(&quot;main: printStackTrace()&quot;);
            e.printStackTrace(System.out);

        &amp;#125;
        try &amp;#123;
            h();//抛出点的调用栈信息是更新前后的
        &amp;#125; catch(Exception e) &amp;#123;
            System.out.println(&quot;main: printStackTrace()&quot;);
            e.printStackTrace(System.out);
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<ul>
<li>在捕获异常之后抛出另一种异常,效果类似于使用 filInStackTrace()，有关原异常抛出点调用栈会丢失</li>
</ul>
<pre><code class="java">// exceptions/RethrowNew.java
// Rethrow a different object from the one you caught
class OneException extends Exception &amp;#123;
    OneException(String s) &amp;#123; super(s); &amp;#125;
&amp;#125;
class TwoException extends Exception &amp;#123;
    TwoException(String s) &amp;#123; super(s); &amp;#125;
&amp;#125;
public class RethrowNew &amp;#123;
    public static void f() throws OneException &amp;#123;
        System.out.println(
                &quot;originating the exception in f()&quot;);
        throw new OneException(&quot;thrown from f()&quot;);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            try &amp;#123;
                f();
            &amp;#125; catch(OneException e) &amp;#123;
                System.out.println(
                        &quot;Caught in inner try, e.printStackTrace()&quot;);
                e.printStackTrace(System.out);
                throw new TwoException(&quot;from inner try&quot;);//抛出不同异常
            &amp;#125;
        &amp;#125; catch(TwoException e) &amp;#123;
            System.out.println(
                    &quot;Caught in outer try, e.printStackTrace()&quot;);
            e.printStackTrace(System.out);//此异常仅知道自己来自 main()，而对 f() 一无所知。
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><p>捕获一个异常并抛出另一个异常，同时想保持已捕获异常的信息。</p>
<h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><ul>
<li><p>异常有无发生，均执行的操作（抛出异常时紧跟异常处理语句后执行）</p>
<pre><code class="java">// exceptions/MultipleReturns.java
public class MultipleReturns &amp;#123;
    public static void f(int i) &amp;#123;
        System.out.println(
                &quot;Initialization that requires cleanup&quot;);
        try &amp;#123;
            System.out.println(&quot;Point 1&quot;);
            if(i == 1) return;//返回，中断下面操作，但finally语句仍会执行。
            System.out.println(&quot;Point 2&quot;);
            if(i == 2) return;
            System.out.println(&quot;Point 3&quot;);
            if(i == 3) return;
            System.out.println(&quot;End&quot;);
            return;
        &amp;#125; finally &amp;#123;
            System.out.println(&quot;Performing cleanup&quot;);
        &amp;#125;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        for(int i = 1; i &lt;= 4; i++)
            f(i);
    &amp;#125;
&amp;#125;</code></pre>
</li>
<li><p>在任何finally语句中使用return，发生(抛出)的异常将静默。</p>
<pre><code class="javascript">public class ExceptionSilencer &amp;#123;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            throw new RuntimeException();
        &amp;#125; finally &amp;#123;
            // Using &#39;return&#39; inside the finally block
            // will silence any thrown exception.
            return;
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
</li>
<li><p>try中与finally中发生同时（抛出）异常，try中的异常将不被显示(设计缺陷)</p>
<pre><code class="java">package cn.day.a2;

// exceptions/LostMessage.java
// How an exception can be lost
class VeryImportantException extends Exception &amp;#123;
    @Override
    public String toString() &amp;#123;
        return &quot;A very important exception!&quot;;
    &amp;#125;
&amp;#125;
class HoHumException extends Exception &amp;#123;
    @Override
    public String toString() &amp;#123;
        return &quot;A trivial exception&quot;;
    &amp;#125;
&amp;#125;
public class LostMessage &amp;#123;
    void f() throws VeryImportantException &amp;#123;
        throw new VeryImportantException();
    &amp;#125;
    void dispose() throws HoHumException &amp;#123;
        throw new HoHumException();
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            LostMessage lm = new LostMessage();
            try &amp;#123;
                lm.f();//由于finally也抛出异常，故此异常不被显示
            &amp;#125; finally &amp;#123;
                lm.dispose();
            &amp;#125;
        &amp;#125; catch(VeryImportantException | HoHumException e) &amp;#123;
            System.out.println(e);
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
</li>
</ul>
<h1 id="异常限制"><a href="#异常限制" class="headerlink" title="异常限制"></a>异常限制</h1><ul>
<li>一个类可不声明其超类或实现接口中的异常</li>
<li>一个类不能声明与其超类中声明的异常无直接继承关系的异常</li>
<li>异常限制对构造器不起作用。</li>
</ul>
<pre><code class="java">package cn.day.a2;

/**重写的方法只能抛出在其基类版本中指定的异常，或从基类异常派生的异常**/
/*定义异常*/
class BaseballException extends Exception &amp;#123;&amp;#125;
class Foul extends BaseballException &amp;#123;&amp;#125;
class Strike extends BaseballException &amp;#123;&amp;#125;

/*声明异常*/
abstract class Inning &amp;#123;
    Inning() throws BaseballException &amp;#123;&amp;#125;
    public void event() throws BaseballException &amp;#123;
    &amp;#125;
    public abstract void atBat() throws Strike, Foul;
    public void walk() &amp;#123;&amp;#125; 
&amp;#125;
/*定义异常*/
class StormException extends Exception &amp;#123;&amp;#125;
class RainedOut extends StormException &amp;#123;&amp;#125;
class PopFoul extends Foul &amp;#123;&amp;#125;

/*一个接口中声明两个异常*/
interface Storm &amp;#123;
    void event() throws RainedOut;
    void rainHard() throws RainedOut;
&amp;#125;

/*继承上面含有声明异常的类并实现含有声明异常的接口*/
public class StormyInning extends Inning implements Storm &amp;#123;

    public StormyInning()
            throws RainedOut, BaseballException &amp;#123;&amp;#125;//声明这个构造器可能发生的异常（来自接口与父类）
    public StormyInning(String s)
  throws BaseballException &amp;#123;&amp;#125;

    @Override
    public void rainHard() throws RainedOut &amp;#123;&amp;#125;
//声明了实现的接口异常
    @Override
    public void event() &amp;#123;&amp;#125;
    // 没有声明异常哦
    @Override
    public void atBat() throws PopFoul &amp;#123;&amp;#125;//覆盖方法可以声明继承了其超类所声明的异常的子异常
//    public void atBat() throws RainedOut &amp;#123;&amp;#125;//其接口有，但其超类未声明此异常，故不可这样做
//    public void atBat() throws BaseballException &amp;#123;&amp;#125;覆盖方法不能声明其超类中未声明且与其超类中声明的异常无直接继承关系的异常
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            StormyInning si = new StormyInning();
            si.atBat();
        &amp;#125; catch(PopFoul e) &amp;#123;
            System.out.println(&quot;Pop foul&quot;);
        &amp;#125; catch(RainedOut e) &amp;#123;
            System.out.println(&quot;Rained out&quot;);
        &amp;#125; catch(BaseballException e) &amp;#123;
            System.out.println(&quot;Generic baseball exception&quot;);
        &amp;#125;
        try &amp;#123;
            Inning i = new StormyInning();
            i.atBat();
        &amp;#125; catch(Strike e) &amp;#123;
            System.out.println(&quot;Strike&quot;);
        &amp;#125; catch(Foul e) &amp;#123;
            System.out.println(&quot;Foul&quot;);
        &amp;#125; catch(RainedOut e) &amp;#123;
            System.out.println(&quot;Rained out&quot;);
        &amp;#125; catch(BaseballException e) &amp;#123;
            System.out.println(&quot;Generic baseball exception&quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h1><ul>
<li><p>异常处理，采用“就近原则”：异常子类可作为捕获参数用于捕获其父类类型的异常。</p>
<pre><code class="java">// exceptions/Human.java
// Catching exception hierarchies
class Annoyance extends Exception &amp;#123;&amp;#125;
class Sneeze extends Annoyance &amp;#123;&amp;#125;
public class Human &amp;#123;
    public static void main(String[] args) &amp;#123;
        // Catch the exact type:
        try &amp;#123;
            throw new Sneeze();
        &amp;#125; catch(Sneeze s) &amp;#123;
            System.out.println(&quot;Caught Sneeze&quot;);
        &amp;#125; catch(Annoyance a) &amp;#123;
            System.out.println(&quot;Caught Annoyance&quot;);
        &amp;#125;

        try &amp;#123;
            throw new Sneeze();
        &amp;#125; catch(Annoyance a) &amp;#123;//可捕获Annoyance父类Sneeze的异常
            System.out.println(&quot;Caught Annoyance&quot;);
        &amp;#125;
         catch(Sneeze a) &amp;#123;//将永远无法捕获并处理异常，所以会报错。
            System.out.println(&quot;Caught Annoyance&quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
</li>
</ul>
<h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><ul>
<li>确保有无异常时打开的文件在结束之后均关闭</li>
</ul>
<pre><code class="java">static String readFirstLineFromFile(String path) throws IOException &amp;#123;
      try (BufferedReader br = new BufferedReader(new FileReader(path))) &amp;#123;//即使发生异常（）内的资源也会关闭
        return br.readLine();
      &amp;#125;
    &amp;#125;

/*try finally*/
static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException &amp;#123;
      BufferedReader br = new BufferedReader(new FileReader(path));
      try &amp;#123;
        return br.readLine();
      &amp;#125; finally &amp;#123;
        if (br != null) br.close();//如果close出现异常，则文件无法正常关闭
      &amp;#125;
    &amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-07/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-06/">
        <h2>
            终端操作(收集)
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>以下操作将会获取流的最终结果。至此我们无法再继续往后传递流。</p>
<p>终端操作（Terminal Operations）总是我们在流管道中所做的最后一件事。</p>
</blockquote>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li><code>toArray()</code>：将流转换成适当类型的数组。</li>
<li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组。</li>
</ul>
<pre><code class="java">// streams/RandInts.java
package streams;
import java.util.*;
import java.util.stream.*;
public class RandInts &amp;#123;
    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
    public static IntStream rands() &amp;#123;
        return Arrays.stream(rints);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><ul>
<li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li>
<li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。]</li>
<li><code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。</li>
</ul>
<pre><code class="java">package com.test.day16;

// streams/ForEach.java
import java.util.*;
import java.util.stream.*;

public class ForEach &amp;#123;
    static final int SZ = 14;
    public static void main(String[] args) &amp;#123;
        RandInts.rands().limit(SZ)//截取14个
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        RandInts.rands().limit(SZ)
                .parallel()
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
         /*在第一个流中，未使用 parallel() ，所以 rands() 按照元素迭代出现的顺序显示结果；
        在第二个流中，引入parallel() ，即便流很小，输出的结果顺序也和前面不一样。这是由于多处理器并行操作的原因。
        多次运行测试，结果均不同。多处理器并行操作带来的非确定性因素造成了这样的结果。*/
        System.out.println();
        RandInts.rands().limit(SZ)
                .parallel()//parallel()：实现多处理器并行操作。
                // 实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。
                .forEachOrdered(n -&gt; System.out.format(&quot;%d &quot;, n));//强制保持原始流顺序

    &amp;#125;
&amp;#125;

package com.test.day16;

// streams/RandInts.java
import java.util.*;
import java.util.stream.*;
public class RandInts &amp;#123;
    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
    public static IntStream rands() &amp;#123;
        return Arrays.stream(rints);//返回此数组流
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li>
<li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</li>
<li><strong>Collectors</strong> 里面没有特定的 <code>toTreeSet()</code>，但是我们可以通过将集合的构造函数引用传递给 <code>Collectors.toCollection()</code>，从而构建任何类型的集合。<strong>如下</strong>：</li>
</ul>
<pre><code class="java">// streams/TreeSetOfWords.java
import java.util.*;
import java.nio.file.*;
import java.util.stream.*;
public class TreeSetOfWords &amp;#123;
    public static void
    main(String[] args) throws Exception &amp;#123;
        Set&lt;String&gt; words2 =
                Files.lines(Paths.get(&quot;TreeSetOfWords.java&quot;))//Paths.get读取全文，Files.lines打开 Path 并将其转换成为行流。
                        .flatMap(s -&gt; Arrays.stream(s.split(&quot;\\W+&quot;)))// Arrays.stream() 将其转化成为流；并将结果展平映射成为单词流。
                        .filter(s -&gt; !s.matches(&quot;\\d+&quot;)) // No numbersmatches(\\d+) 查找并移除全数字字符串
                        .map(String::trim)//String.trim() 去除单词两边的空白，
                        .filter(s -&gt; s.length() &gt; 2) filter() //过滤所有长度小于3的单词，，最后将
                        .limit(100)//获取100个单词
                        .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(words2);//将元素收集至Tree集合构造器
    &amp;#125;
&amp;#125;

//1.将数据收集进一个列表(Stream 转换为 List，允许重复值，有顺序)
//创建流
Stream&lt;String&gt; language = Stream.of(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);
List&lt;String&gt; listResult = language.collect(Collectors.toList());
result.forEach(System.out::println);
//2.将数据收集进一个集合(Stream 转换为 Set，不允许重复值，没有顺序)
Stream&lt;String&gt; language = Stream.of(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);
Set&lt;String&gt; setResult = language.collect(Collectors.toSet());
setResult.forEach(System.out::println);
      List&lt;String&gt; list = Arrays.asList(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);  

</code></pre>
<h2 id="自定义收集"><a href="#自定义收集" class="headerlink" title="自定义收集"></a>自定义收集</h2><pre><code class="java">//用LinkedList收集
      List&lt;String&gt; linkedListResult = list.stream().collect(Collectors.toCollection(LinkedList::new));
      linkedListResult.forEach(System.out::println);
      System.out.println(&quot;--------------&quot;);

      //用CopyOnWriteArrayList收集
      List&lt;String&gt; copyOnWriteArrayListResult = list.stream().collect(Collectors.toCollection(CopyOnWriteArrayList::new));
      copyOnWriteArrayListResult.forEach(System.out::println);
      System.out.println(&quot;--------------&quot;);

      //用TreeSet收集
      TreeSet&lt;String&gt; treeSetResult = list.stream().collect(Collectors.toCollection(TreeSet::new));
      treeSetResult.forEach(System.out::println);</code></pre>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><ul>
<li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li>
<li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li>
<li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li>
</ul>
<pre><code class="java">package com.test.day16;

// streams/Reduce.java
import java.util.*;
import java.util.stream.*;
class Frobnitz &amp;#123;
    int size;
    Frobnitz(int sz) &amp;#123; size = sz; &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &quot;Frobnitz(&quot; + size + &quot;)&quot;;
    &amp;#125;
    // Generator:
    static Random rand = new Random(47);
    static final int BOUND = 100;
    static Frobnitz supply() &amp;#123;/*个方法对于 Supplier&lt;Frobnitz&gt; 是签名兼容的，
    我们可以将其方法引用传递给 Stream.generate()（这种签名兼容性被称作结构一致性）*/
        return new Frobnitz(rand.nextInt(BOUND));//随机返回0-100之间的数
    &amp;#125;
&amp;#125;
public class Reduce &amp;#123;
    public static void main(String[] args) &amp;#123;
        Stream.generate(Frobnitz::supply)//Stream.iterate和Stream.generate。这两个操作可以创建无限流：不像从固定集合创建的流那样有固定大小的流。
                .limit(10)
                .peek(System.out::println)//peek接收的参数类型为Consumer，而map接收的参数类型为Function
        //println 方法可以被调用是因为 Frobnitz 可以通过 toString() 方法转换成 String
                .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)/*reduce() 中的 Lambda 表达式使用了三元表达式来获取结果，
                当其长度小于 50 的时候获取 fr0 否则获取序列中的下一个值 fr1。当取得第一个长度小于 50 的 Frobnitz，只要得到结果就会忽略其他。*/
                .ifPresent(System.out::println);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>count()</code>：流中的元素个数;</p>
<p><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素;</p>
<p><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</p>
<h2 id="数字流信息"><a href="#数字流信息" class="headerlink" title="数字流信息"></a>数字流信息</h2><p><code>average()</code> ：求取流元素平均值;</p>
<p><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>;</p>
<p><code>sum()</code>：对所有流元素进行求和;</p>
<p><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul>
<li><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
<li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
</ul>
<pre><code class="java">package com.test.day16;
// streams/SelectElement.java
import java.util.*;
import java.util.stream.*;

public class SelectElement &amp;#123;
    public static void main(String[] args) &amp;#123;
        System.out.println(RandInts.rands().findFirst().getAsInt());//获取随机流中生成的头一个元素，并返回
        System.out.println(
                RandInts.rands().parallel().findFirst().getAsInt());
        System.out.println(RandInts.rands().findAny().getAsInt());//对于非并行流，findAny()会选择流中的第一个元素（即使从定义上来看是选择任意元素）。
        System.out.println(
                RandInts.rands().parallel().findAny().getAsInt());//parallel()并行化，findAny选择并行化后的第一个元素
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><ul>
<li><code>allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。</li>
<li><code>anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。</li>
<li><code>noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li>
</ul>
<pre><code class="java">package com.test.day16;

// streams/Matching.java
// Demonstrates short-circuiting of *Match() operations
import java.util.stream.*;
import java.util.function.*;

interface Matcher extends BiPredicate&lt;Stream&lt;Integer&gt;, Predicate&lt;Integer&gt;&gt; &amp;#123;&amp;#125;

public class Matching &amp;#123;
    static void show(Matcher match, int val) &amp;#123;
        System.out.println(
                match.test(
                        IntStream.rangeClosed(1, 9)//生成1-9
                                .boxed()//将流元素装入包装器Integer
                                .peek(n -&gt; System.out.format(&quot;%d &quot;, n)),//返回由该流的元素，作为元素从所得流消耗的每个元件上附加地执行所述提供动作的流。
                        n -&gt; n &lt; val));//执行peek中操作
    &amp;#125;/*    allMatch(Predicate) ：返回flase时停止计算
           anyMatch(Predicate)：在获得true时停止执行，如结尾仍未获得true。返回flase
    noneMatch(Predicate)：如果流的每个元素根据提供的 Predicate 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。*/
    public static void main(String[] args) &amp;#123;
        show(Stream::allMatch, 10);
        show(Stream::allMatch, 4);//第5个值5，大于4，故停止计算（短路时直接结束此操作）
        show(Stream::anyMatch, 3);//在获得true时停止执行
        show(Stream::anyMatch, 0);
        show(Stream::noneMatch, 5);//在第一个 true 时停止执行计算，故返回flase
        show(Stream::noneMatch, 0);
    &amp;#125;
&amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-06/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-05/">
        <h2>
            Optional类
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>用于，查看的流中元素返回提示而不是发生异常。</p>
</blockquote>
<p><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong>;</p>
<p><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty;</strong></p>
<p><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong>;</p>
<p><code>reduce()</code> 不再以 <code>identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code>identity</code> 对象成为其他形式的 <code>reduce()</code> 的默认结果，因此不存在空结果的风险）;</p>
<p>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code>average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</p>
<h1 id="解包-Optional"><a href="#解包-Optional" class="headerlink" title="解包 Optional"></a>解包 <strong>Optional</strong></h1><ul>
<li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li>
<li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>（括号中可定义）。</li>
<li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li>
<li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li>
</ul>
<h1 id="创建-Optional"><a href="#创建-Optional" class="headerlink" title="创建 Optional"></a>创建 Optional</h1><ul>
<li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li>
<li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li>
<li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li>
</ul>
<pre><code class="java">package com.test.day15;

import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class CreatingOptionals &amp;#123;
    static void test(String testName, Optional&lt;String&gt; opt) &amp;#123;
        System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
        System.out.println(opt.orElse(&quot;Null&quot;));//定义若不存在值则生成otherObject为null，并打印；若有值返回并打印值。
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        test(&quot;empty&quot;, Optional.empty());////empty()：生成一个空 Optional。
        test(&quot;of&quot;, Optional.of(&quot;Howdy&quot;));//of(value)：将一个非空值包装到 Optional 里。
        try &amp;#123;
            test(&quot;of&quot;, Optional.of(null));
        &amp;#125; catch(Exception e) &amp;#123;
            System.out.println(e);
        &amp;#125;
        test(&quot;ofNullable&quot;, Optional.ofNullable(&quot;Hi&quot;));
        //ofNullable(value)：针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中

        test(&quot;ofNullable&quot;, Optional.ofNullable(null));
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="Optional-对象操作"><a href="#Optional-对象操作" class="headerlink" title="Optional 对象操作"></a>Optional 对象操作</h1><ul>
<li><p><code>filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。而流的 <code>filter()</code> 则会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。</p>
</li>
<li><p><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong>  于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。（与中间操作map类似）</p>
</li>
<li><p><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。（与中间操作flatmap类似）<code>Optional.flatMap()</code> 是为那些自己已经生成 <strong>Optional</strong> 的函数而设计的。可用来组合流中的方法（实现方式是将元素扁平化再实现流）例：</p>
<pre><code class="java">Optional&lt;Double&gt; a=Optional.of(-4.0).flatMap(Demo:invers).flatMap(Demo:squareRoot)</code></pre>
</li>
</ul>
<p>以上方法都不适用于数值型 <strong>Optional</strong>。</p>
<pre><code class="java">// streams/OptionalFilter.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class OptionalFilter &amp;#123;
    static String[] elements = &amp;#123;
            &quot;Foo&quot;, &quot;&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Bingo&quot;
    &amp;#125;;
    static Stream&lt;String&gt; testStream() &amp;#123;
        return Arrays.stream(elements);
    &amp;#125;
    static void test(String descr, Predicate&lt;String&gt; pred) &amp;#123;
        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
        for(int i = 0; i &lt;= elements.length; i++) &amp;#123;/
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst()
                            .filter(pred));
        &amp;#125;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        test(&quot;true&quot;, str -&gt; true);//返回所有元素包括空
        test(&quot;false&quot;, str -&gt; false);//返回空（Optional.empty）
        test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);
        test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);
        test(&quot;startsWith(\&quot;B\&quot;)&quot;,
                str -&gt; str.startsWith(&quot;B&quot;));
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="Optional-流"><a href="#Optional-流" class="headerlink" title="Optional 流"></a>Optional 流</h1><pre><code class="java">package com.test.day16;

// streams/Signal.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
public class Signal &amp;#123;
    private final String msg;
    public Signal(String msg) &amp;#123; this.msg = msg; &amp;#125;
    public String getMsg() &amp;#123; return msg; &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &quot;Signal(&quot; + msg + &quot;)&quot;;
    &amp;#125;
    static Random rand = new Random(47);//随机数
    public static Signal morse() &amp;#123;
        switch(rand.nextInt(4)) &amp;#123;//nextInt(4)，返回0-4之间的数
            case 1: return new Signal(&quot;dot&quot;);
            case 2: return new Signal(&quot;dash&quot;);
            default: return null;
        &amp;#125;
    &amp;#125;
    public static Stream&lt;Optional&lt;Signal&gt;&gt; stream() &amp;#123;
        return Stream.generate(Signal::morse)//通过所提供的产生的每个元件的无限连续的无序流Supplier
                .map(signal -&gt; Optional.ofNullable(signal));//为空返回Optional.empty，不为空将值包包装在 Optional 中。
    &amp;#125;
&amp;#125;


package com.test.day16;

// streams/StreamOfOptionals.java
import java.util.*;
import java.util.stream.*;
public class StreamOfOptionals &amp;#123;
    public static void main(String[] args) &amp;#123;
        Signal.stream()
                .limit(10)
                .forEach(System.out::println);
        System.out.println(&quot; ---&quot;);
        Signal.stream()
                .limit(10)
                .filter(Optional::isPresent)//返回非空的元素，isPresent值存在返回true否返回flase
                .map(Optional::get)//从Optional中提取元素
                .forEach(System.out::println);
    &amp;#125;
&amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#006674>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-05/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-04/">
        <h2>
            流的创建与基础操作
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说;</p>
<p>利用流，我们无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道;</p>
<p>流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体;</p>
</blockquote>
<p>流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）;</p>
<p>在接口中添加被 <code>default</code>（<code>默认</code>）修饰的方法，即可将流式（<em>stream</em>）方法平滑地嵌入到现有类中。</p>
<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h4 id="ints"><a href="#ints" class="headerlink" title=".ints( )"></a>.ints( )</h4><ul>
<li>生成整数流，可设定边界</li>
<li>如设定边界为ints（5，20）则生成5（包括）-20（不包括）之间的数</li>
</ul>
<h4 id="limit"><a href="#limit" class="headerlink" title=".limit()"></a>.limit()</h4><ul>
<li>截断并获取流中元素</li>
<li>如填入7，则获取前7个元素</li>
</ul>
<pre><code class="java">// streams/Randoms.java
import java.util.*;
public class Randoms &amp;#123;
    public static void main(String[] args) &amp;#123;
        new Random(47)
            .ints(5, 20)//生成整数流，设定边界如5-20（不包括20）
            .distinct()//收集不重复的
            .limit(7)//截断，获取7个元素
            .sorted()//排序
            .forEach(System.out::println);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h1><h2 id="Stream-of"><a href="#Stream-of" class="headerlink" title="Stream.of()"></a>Stream.of()</h2><p>将一组元素转化成为流</p>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream()"></a>stream()</h2><p>集合可通过调用此方法产生一个流</p>
<h2 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet()"></a>entrySet()</h2><ul>
<li>产生一个对象流，每个对象都包含一个 <code>key</code> 键以及与其相关联的 <code>value</code> 值。 </li>
<li>可使用getKey()和getValue() 获取对象流的键值</li>
</ul>
<pre><code class="java">// streams/CollectionToStream.java
import java.util.*;
import java.util.stream.*;
public class CollectionToStream &amp;#123;
    public static void main(String[] args) &amp;#123;
        List&lt;Bubble&gt; bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
        System.out.println(bubbles.stream()
            .mapToInt(b -&gt; b.i)
            .sum());

        Set&lt;String&gt; w = new HashSet&lt;&gt;(Arrays.asList(&quot;It&#39;s a wonderful day for pie!&quot;.split(&quot; &quot;)));
        w.stream()
         .map(x -&gt; x + &quot; &quot;)
         .forEach(System.out::print);
        System.out.println();

        Map&lt;String, Double&gt; m = new HashMap&lt;&gt;();
        m.put(&quot;pi&quot;, 3.14159);
        m.put(&quot;e&quot;, 2.718);
        m.put(&quot;phi&quot;, 1.618);
        m.entrySet().stream()//entrySet() 产生一个对象流，每个对象都包含一个 `key` 键以及与其相关联的 `value` 值。 。
                    .map(e -&gt; e.getKey() + &quot;: &quot; + e.getValue())//getKey()和getValue() 获取键值
            //中间操作 `map()` 会获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。
                    .forEach(System.out::println);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="boxed"><a href="#boxed" class="headerlink" title="boxed()"></a>boxed()</h2><ul>
<li>把基本类型包装成为对应的装箱类型</li>
</ul>
<pre><code class="java">public class RandomGenerators &amp;#123;
    public static &lt;T&gt; void show(Stream&lt;T&gt; stream) &amp;#123;
        stream
        .limit(4)
        .forEach(System.out::println);
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        Random rand = new Random(47);
        show(rand.ints().boxed());//boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 show() 能够接受流
        show(rand.longs().boxed());
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h2><p>收集操作，它根据参数来组合所有流中的元素。</p>
<h2 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining()"></a>Collectors.joining()</h2><p>每个元素都根据 <code>joining()</code> 的参数来进行分割。</p>
<p>得到一个 <code>String</code> 类型的结果</p>
<h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate()"></a>Stream.generate()</h2><ul>
<li>把任意  <code>Supplier&lt;T&gt;</code> 用于生成 <code>T</code> 类型的流。</li>
</ul>
<pre><code class="java">// streams/RandomWords.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
import java.io.*;
import java.nio.file.*;
public class RandomWords implements Supplier&lt;String&gt; &amp;#123;
    List&lt;String&gt; words = new ArrayList&lt;&gt;();
    Random rand = new Random(47);
    RandomWords(String fname) throws IOException &amp;#123;
        List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname));
        // 略过第一行
        for (String line : lines.subList(1, lines.size())) &amp;#123;
            for (String word : line.split(&quot;[ .?,]+&quot;))
                words.add(word.toLowerCase());
        &amp;#125;
    &amp;#125;
    public String get() &amp;#123;
        return words.get(rand.nextInt(words.size()));
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return words.stream()
            .collect(Collectors.joining(&quot; &quot;));
    &amp;#125;
    public static void main(String[] args) throws Exception &amp;#123;
        System.out.println(
            Stream.generate(new RandomWords(&quot;Cheese.dat&quot;))
                .limit(10)
                .collect(Collectors.joining(&quot; &quot;)));//以空格分隔流元素并收集
    &amp;#125;
&amp;#125;</code></pre>
<pre><code class="java">package com.test.day15;

// streams/Generator.java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Generator implements Supplier&lt;String&gt; &amp;#123;
    Random rand = new Random(47);
    char[] letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();

    public String get() &amp;#123;
        return &quot;&quot; + letters[rand.nextInt(letters.length)];
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        String word = Stream.generate(new Generator())
                ////Stream.generate() 的用法，它可以把任意 Supplier&lt;T&gt; 用于生成 T 类型的流。
                .limit(30)//获取前30个
                .collect(Collectors.joining(&quot; &quot;));//collect() 收集操作，它根据参数来组合所有流中的元素。
        //使用 Collectors.joining()，你将会得到一个 String 类型的结果，
        // 每个元素都根据 joining() 的参数来进行分割。

        System.out.println(word);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h2><p>将元素装入数组</p>
<h2 id="Arrays的stream"><a href="#Arrays的stream" class="headerlink" title="Arrays的stream()"></a>Arrays的stream()</h2><p>把数组转换成为流;</p>
<p>（）中可加入两个额外的参数。第一个参数告诉 <code>stream()</code> 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止。</p>
<h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate()"></a>Stream.iterate()</h2><p>以种子（第一个参数）开头，并将其传给方法（第二个参数）；</p>
<p>方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code>。</p>
<h2 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h2><ul>
<li>根据参数丢弃指定数量的流元素。</li>
</ul>
<pre><code class="java">package com.test.day15;

// streams/Fibonacci.java
import java.util.stream.*;
public class Fibonacci &amp;#123;
    int x = 1;

    Stream&lt;Integer&gt; numbers() &amp;#123;
        return Stream.iterate(0, i -&gt; &amp;#123;//terate() 以种子（第一个参数）开头，并将其传给方法（第二个参数）。
            // iterate() 只能记忆结果，因此我们需要利用一个变量 x 追踪另外一个元素。
            int result = x + i;
            x = i;
            return result;//返回值赋予i
        &amp;#125;);
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        new Fibonacci().numbers()
                .skip(20) // 过滤前 20 个
                .limit(10) // 然后取 10 个
                .forEach(System.out::println);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h1><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。</p>
<h2 id="mapToInt-ToIntFunction"><a href="#mapToInt-ToIntFunction" class="headerlink" title="mapToInt(ToIntFunction)"></a>mapToInt(ToIntFunction)</h2><p>操作同上，但结果是 <strong>IntStream</strong>;</p>
<p>mapToLong(ToLongFunction)</p>
<p>操作同上，但结果是 <strong>LongStream</strong>;</p>
<p>mapToDouble(ToDoubleFunction)</p>
<p>操作同上，但结果是 <strong>DoubleStream</strong>。</p>
<pre><code class="java">package com.test.day15;

// streams/FunctionMap.java
import java.util.*;
import java.util.stream.*;
import java.util.function.*;
class FunctionMap &amp;#123;
    static String[] elements = &amp;#123; &quot;12&quot;, &quot;&quot;, &quot;23&quot;, &quot;45&quot; &amp;#125;;
    static Stream&lt;String&gt;
    testStream() &amp;#123;
        return Arrays.stream(elements);//把数组转换成为流并返回
    &amp;#125;
    static void test(String descr, Function&lt;String, String&gt; func) &amp;#123;
        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
        testStream()
                .map(func)//将函数操作应用在输入流的元素中，并将返回值传递到输出流中。
                .forEach(System.out::println);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        test(&quot;add brackets&quot;, s -&gt; &quot;[&quot; + s + &quot;]&quot;);
        test(&quot;Increment&quot;, s -&gt; &amp;#123;
                    try &amp;#123;
//                        return s + 1;//错误的拼接了，流中一切元素为字符
                        return Integer.parseInt(s) + 1 + &quot;&quot;;//将字符串参数作为有符号的十进制整数进行解析并还原为字符串
                    &amp;#125;
                    catch(NumberFormatException e) &amp;#123;
                        return s;
                    &amp;#125;
                &amp;#125;
        );
        test(&quot;Replace&quot;, s -&gt; s.replace(&quot;2&quot;, &quot;9&quot;));
        //返回一个新的字符串，将所有字符”2“替换成”9“
        test(&quot;Take last digit&quot;, s -&gt; s.length() &gt; 0 ?
                s.charAt(s.length() - 1) + &quot;&quot; : s);//charAt返回指定索引处的 char 值。
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="流中元素基本类型的转换"><a href="#流中元素基本类型的转换" class="headerlink" title="流中元素基本类型的转换"></a>流中元素基本类型的转换</h2><pre><code class="java">package com.test.day15;

// streams/FunctionMap3.java
// Producing numeric output streams（ 产生数值输出流）
import java.util.*;
import java.util.stream.*;
class FunctionMap3 &amp;#123;

    public static void main(String[] args) &amp;#123;
        Stream.of(&quot;5&quot;, &quot;7&quot;, &quot;9&quot;)
                .mapToInt(Integer::parseInt)//int类型
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        Stream.of(&quot;17&quot;, &quot;19&quot;, &quot;23&quot;)
                .mapToLong(Long::parseLong)//long类型
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        Stream.of(&quot;17&quot;, &quot;1.9&quot;, &quot;.23&quot;)
                .mapToDouble(Double::parseDouble)//double类型
                .forEach(n -&gt; System.out.format(&quot;%f &quot;, n));
    &amp;#125;
&amp;#125;</code></pre>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><ul>
<li><p>获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中（与 <code>map()</code> 所做的相同）</p>
</li>
<li><p>每个结果都是一个流，将其扁平化为单个元素并拼接到一起</p>
</li>
<li><p>可用来组合流中的方法（实现方式是将元素扁平化再实现流）例：</p>
</li>
</ul>
<pre><code class="java">Stream&lt;String&gt; a = words.stream().flatMap(w -&gt; codePoints(w));</code></pre>
<ul>
<li><p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p>
</li>
<li><p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p>
</li>
<li><p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p>
</li>
<li><p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p>
</li>
</ul>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li>以参数顺序组合两个流。 </li>
</ul>
<pre><code class="java">package com.test.day15;

import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;
/*一个整数流开始，然后使用每一个整数去创建更多的随机数。*/
public class StreamOfRandoms &amp;#123;
    static Random rand = new Random(47);
    //一个种子为47的随机数生成，多个相同种子的随机生成实例，生成的结果一致

    public static void main(String[] args) &amp;#123;
        Stream.of(1,2,3,4,5)
        .flatMapToInt(i -&gt; IntStream.concat(
            //concat()，以参数顺序组合两个流，我们在每个随机 `Integer` 流的末尾添加一个 -1 作为标记
                rand.ints(0,100).limit(i)//根据i的值返回i个元素
                ,
                //生成随机数，仅返回0（包含）-100（不包含）之间的数
                IntStream.of(-1)//生成一个整数流包含-1
                )).forEach(n -&gt; System.out.format(&quot;%d\n&quot;,n));
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h3><p>帮助调试。可无修改地查看流中的元素。</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>收集流中不重复的元素</p>
<h3 id="空流-Stream-empty"><a href="#空流-Stream-empty" class="headerlink" title="空流 Stream.empty()"></a>空流 Stream.empty()</h3><ul>
<li><p>如果你在没有任何上下文环境的情况下调用 Stream.empty()，Java 并不知道它的数据类型；</p>
</li>
<li><p>解决这个问题:1、2均可</p>
<pre><code class="java">1. Stream.&lt;String&gt;empty()//限定类型为String
    2.    Stream&lt;String&gt; s = Stream.empty();</code></pre>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-03/">
        <h2>
            函数式编程
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>任何 Lambda 表达式的基本语法是：</p>
<ol>
<li>参数。</li>
<li>接着 <code>-&gt;</code>，可视为“产出”。</li>
<li><code>-&gt;</code> 之后的内容都是方法体。</li>
</ol>
</blockquote>
<p>当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例;</p>
<p> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见;</p>
<p>如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表;</p>
<p>对于多个参数，将参数列表放在括号 <code>()</code> 中;</p>
<p>表达式的结果自动成为<strong>Lambda 表达式</strong>的返回值，在此处使用 <strong>return</strong> 关键字是非法的。</p>
<p><strong>递归</strong>方法必须是实例变量或静态变量，否则会出现编译时错误</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用组成：类名或对象名 <code>::</code> 方法名</p>
<pre><code class="java">package com.test.day6;

// functional/MethodReferences.java

import java.util.*;

interface Callable &amp;#123; // [1]
    void call(String s);
&amp;#125;

class Describe &amp;#123;
    void show(String msg) &amp;#123; // [2]
        System.out.println(msg);
    &amp;#125;
&amp;#125;

public class MethodReferences &amp;#123;
    static void hello(String name) &amp;#123; // [3]
        System.out.println(&quot;Hello, &quot; + name);
    &amp;#125;
    static class Description &amp;#123;
        String about;
        Description(String desc) &amp;#123; about = desc; &amp;#125;
        void help(String msg) &amp;#123; // [4]
            System.out.println(about + &quot; &quot; + msg);
        &amp;#125;
    &amp;#125;
    static class Helper &amp;#123;
        static void assist(String msg) &amp;#123; // [5]
            System.out.println(msg);
        &amp;#125;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        Describe d = new Describe();
        Callable c = d::show;
        //将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。
        c.call(&quot;call()&quot;); //现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show(),因为其签名均是String。

        c = MethodReferences::hello; //这是一个静态方法引用。
        c.call(&quot;Bob&quot;);

        c = new Description(&quot;valuable&quot;)::help; // 对已实例化对象的方法的引用，称为绑定方法引用。
        c.call(&quot;information&quot;);

        c = Helper::assist; // 内部类方法引用
        c.call(&quot;Help!&quot;);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p><strong>Runnable</strong> 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 <code>run()</code> 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong>：</p>
<pre><code class="java">// 方法引用与 Runnable 接口的结合使用

class Go &amp;#123;
  static void go() &amp;#123;
    System.out.println(&quot;Go::go()&quot;);
  &amp;#125;
&amp;#125;

public class RunnableMethodReference &amp;#123;
  public static void main(String[] args) &amp;#123;

    new Thread(new Runnable() &amp;#123;//内部类方法
      public void run() &amp;#123;
        System.out.println(&quot;Anonymous&quot;);
      &amp;#125;
    &amp;#125;).start();

    new Thread(
      () -&gt; System.out.println(&quot;lambda&quot;)//lambda表达式
    ).start();

    new Thread(Go::go).start();//方法引用
  &amp;#125;
&amp;#125;</code></pre>
<h2 id="未绑定的方法引用"><a href="#未绑定的方法引用" class="headerlink" title="未绑定的方法引用"></a>未绑定的方法引用</h2><blockquote>
<p>在目标类没有对象的时候对其采用方法引用，即为未绑定方法引用（静态类除外）</p>
<p>可使用目标类类型的方法参数解决未绑定方法引用问题</p>
</blockquote>
<pre><code class="java">package com.test.day6;

// functional/UnboundMethodReference.java

// 没有方法引用的对象

class X &amp;#123;
    String f() &amp;#123; return &quot;X::f()&quot;; &amp;#125;
&amp;#125;

interface MakeString &amp;#123;
    String make();
&amp;#125;

interface TransformX &amp;#123;
    String transform(X x);
&amp;#125;

public class UnboundMethodReference &amp;#123;
    public static void main(String[] args) &amp;#123;
        // MakeString ms = X::f; // 不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。
        TransformX sp = X::f;//TransformX下的String transform(X x)方法接受一个X类的参数，所以可与完成对象绑定并成功调用方法。
        X x = new X();
        System.out.println(sp.transform(x)); // [2]
        System.out.println(x.f()); // 同等效果
    &amp;#125;
&amp;#125;




package com.test.day6;

// functional/MultiUnbound.java

// 未绑定的方法与多参数的结合运用

class This &amp;#123;
    void two(int i, double d) &amp;#123;&amp;#125;
    void three(int i, double d, String s) &amp;#123;&amp;#125;
    void four(int i, double d, String s, char c) &amp;#123;&amp;#125;
&amp;#125;
/*接口方法中加入对象类型参数 达到绑定对象目的*/
interface TwoArgs &amp;#123;
    void call2(This athis, int i, double d);//参数This athis达到绑定对象目的
&amp;#125;

interface ThreeArgs &amp;#123;
    void call3(This athis, int i, double d, String s);
&amp;#125;

interface FourArgs &amp;#123;
    void call4(
            This athis, int i, double d, String s, char c);
&amp;#125;

public class MultiUnbound &amp;#123;
    public static void main(String[] args) &amp;#123;
        TwoArgs twoargs = This::two;
        ThreeArgs threeargs = This::three;
        FourArgs fourargs = This::four;
        This athis = new This();
        twoargs.call2(athis, 11, 3.14);//相当于woargs.call2(this.athis, 11, 3.14),成功绑定对象并传入参数调用方法
        threeargs.call3(athis, 11, 3.14, &quot;Three&quot;);
        fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, &#39;Z&#39;);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><pre><code class="java">package com.test.day6;

// functional/CtorReference.java

class Dog &amp;#123;
    String name;
    int age = -1; // For &quot;unknown&quot;
    Dog() &amp;#123; name = &quot;stray&quot;; &amp;#125;
    Dog(String nm) &amp;#123; name = nm; &amp;#125;
    Dog(String nm, int yrs) &amp;#123; name = nm; age = yrs; &amp;#125;
&amp;#125;

interface MakeNoArgs &amp;#123;
    Dog make();
&amp;#125;

interface Make1Arg &amp;#123;
    Dog make(String nm);
&amp;#125;

interface Make2Args &amp;#123;
    Dog make(String nm, int age);
&amp;#125;

public class CtorReference &amp;#123;
    public static void main(String[] args) &amp;#123;
        /*[1][2][3]分别引用不同签名的构造器*/
        MakeNoArgs mna = Dog::new; // [1]根据MakeNoArgs接口中方法的签名引用相符的构造器
        Make1Arg m1a = Dog::new;   // [2]根据Make1Arg接口中方法的签名引用相符的构造器
        Make2Args m2a = Dog::new;  // [3]根据MakeNoArgsMake2Args接口中方法的签名引用相符的构造器

        Dog dn = mna.make();//相当于调用引用Dog类的构造器
        Dog d1 = m1a.make(&quot;Comet&quot;);
        Dog d2 = m2a.make(&quot;Ralph&quot;, 4);
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><blockquote>
<p>只包含一个抽象方法的接口（接口中方法默认为抽象的）</p>
<p>如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会自动包装方法引用或 Lambda 表达式到实现目标接口的类的实例中。</p>
</blockquote>
<pre><code class="java">// functional/FunctionalAnnotation.java

@FunctionalInterface
//@FunctionalInterface 的作用：接口中如果有多个方法则会产生编译期错误
interface Functional &amp;#123;
  String goodbye(String arg);
&amp;#125;

interface FunctionalNoAnn &amp;#123;
  String goodbye(String arg);
&amp;#125;


public class FunctionalAnnotation &amp;#123;
  public String goodbye(String arg) &amp;#123;
    return &quot;Goodbye, &quot; + arg;
  &amp;#125;
  public static void main(String[] args) &amp;#123;
    FunctionalAnnotation fa =
      new FunctionalAnnotation();
    Functional f = fa::goodbye;
    FunctionalNoAnn fna = fa::goodbye;
    // Functional fac = fa; // Incompatible
    Functional fl = a -&gt; &quot;Goodbye, &quot; + a;
    FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a;
  &amp;#125;
&amp;#125;</code></pre>
<p><code>java.util.function</code> 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。</p>
<p> 以下是基本命名准则：</p>
<ol>
<li>如果只处理对象而非基本类型，名称则为 <code>Function</code>，<code>Consumer</code>，<code>Predicate</code> 等。参数类型通过泛型添加。</li>
<li>如果接收的参数是基本类型，则由名称的第一部分表示，如 <code>LongConsumer</code>，<code>DoubleFunction</code>，<code>IntPredicate</code> 等，但基本 <code>Supplier</code> 类型例外。</li>
<li>如果返回值为基本类型，则用 <code>To</code> 表示，如 <code>ToLongFunction &lt;T&gt;</code> 和 <code>IntToLongFunction</code>。</li>
<li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 <code>UnaryOperator</code>，两个参数使用 <code>BinaryOperator</code>。</li>
<li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li>
<li>如果接收的两个参数类型不同，则名称中有一个 <code>Bi</code>。</li>
</ol>
<p>下表描述了 <code>java.util.function</code> 中的目标类型（包括例外情况）：</p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>函数式方法名</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>无参数；   无返回值</td>
<td><strong>Runnable</strong>   (java.lang)     <code>run()</code></td>
<td><strong>Runnable</strong></td>
</tr>
<tr>
<td>无参数；   返回类型任意</td>
<td><strong>Supplier</strong>   <code>get()</code>   <code>getAs类型()</code></td>
<td><strong>Supplier<code>&lt;T&gt;</code>    BooleanSupplier    IntSupplier    LongSupplier    DoubleSupplier</strong></td>
</tr>
<tr>
<td>无参数；   返回类型任意</td>
<td><strong>Callable</strong>   (java.util.concurrent)    <code>call()</code></td>
<td><strong>Callable<code>&lt;V&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数；   无返回值</td>
<td><strong>Consumer</strong>   <code>accept()</code></td>
<td><strong><code>Consumer&lt;T&gt;</code>   IntConsumer   LongConsumer   DoubleConsumer</strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong></td>
<td><strong>BiConsumer</strong>   <code>accept()</code></td>
<td><strong><code>BiConsumer&lt;T,U&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong>；   1 引用；   1 基本类型</td>
<td><strong>Obj类型Consumer</strong>   <code>accept()</code></td>
<td><strong><code>ObjIntConsumer&lt;T&gt;</code>   <code>ObjLongConsumer&lt;T&gt;</code>   <code>ObjDoubleConsumer&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数；   返回类型不同</td>
<td><strong>Function</strong>   <code>apply()</code>   <strong>To类型</strong> 和 <strong>类型To类型</strong>   <code>applyAs类型()</code></td>
<td><strong>Function<code>&lt;T,R&gt;</code>   IntFunction<code>&lt;R&gt;</code>   <code>LongFunction&lt;R&gt;</code>   DoubleFunction<code>&lt;R&gt;</code>   ToIntFunction<code>&lt;T&gt;</code>   <code>ToLongFunction&lt;T&gt;</code>   <code>ToDoubleFunction&lt;T&gt;</code>   IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>1 参数；   返回类型相同</td>
<td><strong>UnaryOperator</strong>   <code>apply()</code></td>
<td><strong><code>UnaryOperator&lt;T&gt;</code>   IntUnaryOperator   LongUnaryOperator   DoubleUnaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同；   返回类型相同</td>
<td><strong>BinaryOperator</strong>   <code>apply()</code></td>
<td><strong><code>BinaryOperator&lt;T&gt;</code>   IntBinaryOperator   LongBinaryOperator   DoubleBinaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同;   返回整型</td>
<td>Comparator   (java.util)   <code>compare()</code></td>
<td><strong><code>Comparator&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数；   返回布尔型</td>
<td><strong>Predicate</strong>   <code>test()</code></td>
<td><strong><code>Predicate&lt;T&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   IntPredicate   LongPredicate   DoublePredicate</strong></td>
</tr>
<tr>
<td>参数基本类型；   返回基本类型</td>
<td><strong>类型To类型Function</strong>   <code>applyAs类型()</code></td>
<td><strong>IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>2 参数类型不同</td>
<td><strong>Bi操作</strong>   (不同方法名)</td>
<td><strong><code>BiFunction&lt;T,U,R&gt;</code>   <code>BiConsumer&lt;T,U&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   <code>ToIntBiFunction&lt;T,U&gt;</code>   <code>ToLongBiFunction&lt;T,U&gt;</code>   <code>ToDoubleBiFunction&lt;T&gt;</code></strong></td>
</tr>
</tbody></table>
<p>此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#006674>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-03/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-02/">
        <h2>
            集合
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。</p>
<p>基本的集合： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> </p>
</blockquote>
<ul>
<li>集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li>
<li><strong>Set</strong> （元组）不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
<li><strong>Map</strong> （字典）是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><pre><code class="java">import java.util.*;

class Apple &amp;#123;
  private static long counter;
  private final long id = counter++;
  public long id() &amp;#123; return id; &amp;#125;
&amp;#125;

class Orange &amp;#123;&amp;#125;

public class ApplesAndOrangesWithoutGenerics &amp;#123;
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void main(String[] args) &amp;#123;
    ArrayList apples = new ArrayList();
    for(int i = 0; i &lt; 3; i++)
      apples.add(new Apple());
    /*ArrayList 保存的是 Object ，所以不仅可以通过 ArrayList 的 add() 方法将 Apple 对象放入这个集合，而且可以放入 Orange 对象。*/
    apples.add(new Orange());
    for(Object apple : apples) &amp;#123;
      ((Apple) apple).id();
        /*当使用 ArrayList 的 get() 方法来取出你认为是 Apple 的对象时，得到的只是 Object 引用，必须将其转型为 Apple。然后需要将整个表达式用括号括起来，以便在调用 Apple 的 id() 方法之前，强制执行转型。*/
    &amp;#125;
  &amp;#125;
&amp;#125;
/**通过泛型,限定&lt;Apple&gt;类型防止其它类型对象添加到容器中*/
import java.util.*;

class GrannySmith extends Apple &amp;#123;&amp;#125;
public class ApplesAndOrangesWithGenerics &amp;#123;
  public static void main(String[] args) &amp;#123;
    ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; 3; i++)
      apples.add(new GrannySmith());//向上转型也可以添加到容器哦
      apples.add(new Apple());
    // Compile-time error:
    // apples.add(new Orange());
    for(Apple apple : apples) &amp;#123;
      System.out.println(apple.id());
        //使用泛型，容器知道它被限定为什么类型，因此当调用 get() 时，它会替你执行转型，因此从泛型容器中获取元素不需要强制类型转换。</code></pre>
<h2 id="添加元数组"><a href="#添加元数组" class="headerlink" title="添加元数组"></a>添加元数组</h2><ul>
<li><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。</li>
<li><code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中</li>
</ul>
<pre><code class="java">package com.test.day3;

import java.util.*;

public class AddingGroups &amp;#123;
    public static void main(String[] args) &amp;#123;
        Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));
        Integer[] moreInts = &amp;#123;6,7,8,9,10&amp;#125;;
        collection.addAll(Arrays.asList(moreInts));//Collection.addAll() 方法只能接受另一个 Collection 作为参数
        /*Collection 可以接受另一个 Collection进行初始化，所以使用 Arrays.asList() 可为这个构造器产生输入。
        Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，再调用 Collections.addAll()添加元素 */
        Collections.addAll(collection,11,12,13,14,15);
        Collections.addAll(collection,moreInts);
         /*使用 Arrays.asList() 的输出作为一个 List ，无法调整大小*/
        List&lt;Integer&gt; list = Arrays.&lt;Integer&gt;asList(16,17,18,19,20);
        //告诉编译器 Arrays.asList() 生成的结果 List 类型的实际目标类型是什么。这称为显式类型参数说明

        list.set(1,99);

    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接</li>
<li><strong>Collection</strong> 类型在每个槽中只能保存一个元素。 <strong>Set</strong> 中元素不重复； <strong>Queue</strong> ，只在一端插入对象，并从另一端移除对象； <strong>Map</strong> 在每个槽中存放了两个元素，即<em>键</em>和与之关联的<em>值</em>。</li>
</ul>
<pre><code class="java">import java.util.*;

public class PrintingCollections &amp;#123;
  static Collection
  fill(Collection&lt;String&gt; collection) &amp;#123;
    collection.add(&quot;rat&quot;);
    collection.add(&quot;cat&quot;);
    collection.add(&quot;dog&quot;);
    collection.add(&quot;dog&quot;);
    return collection;
  &amp;#125;
  static Map fill(Map&lt;String, String&gt; map) &amp;#123;
    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);
    map.put(&quot;cat&quot;, &quot;Rags&quot;);
    map.put(&quot;dog&quot;, &quot;Bosco&quot;);
    map.put(&quot;dog&quot;, &quot;Spot&quot;);
    return map;
  &amp;#125;
  public static void main(String[] args) &amp;#123;
    System.out.println(fill(new ArrayList&lt;&gt;()));
      //ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。
    System.out.println(fill(new LinkedList&lt;&gt;()));
      //LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。

    System.out.println(fill(new HashSet&lt;&gt;()));
    System.out.println(fill(new TreeSet&lt;&gt;()));
      //如果存储顺序很重要，则可以使用 TreeSet ，它将按比较结果的升序保存对象
    System.out.println(fill(new LinkedHashSet&lt;&gt;()));
      //LinkedHashSet ，它按照被添加的先后顺序保存对象。

    System.out.println(fill(new HashMap&lt;&gt;()));
      // 键和值保存在 HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非常快速的算法来控制顺序。
    System.out.println(fill(new TreeMap&lt;&gt;()));
      // TreeMap 通过比较结果的升序来保存键
    System.out.println(fill(new LinkedHashMap&lt;&gt;()));
      //LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。
  &amp;#125;
&amp;#125;
/* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[rat, cat, dog]
[cat, dog, rat]
[rat, cat, dog]
&amp;#123;rat=Fuzzy, cat=Rags, dog=Spot&amp;#125;
&amp;#123;cat=Rags, dog=Spot, rat=Fuzzy&amp;#125;
&amp;#123;rat=Fuzzy, cat=Rags, dog=Spot&amp;#125;
*/</code></pre>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>统一集合的移动、删除</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p> <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，设计的很糟糕：如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类。</p>
<p><strong>Java 6 添加了 **ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法:</p>
<pre><code class="java">package com.test.day5;

import java.util.ArrayDeque;
import java.util.Deque;

public class Stack&lt;T&gt; &amp;#123;

    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();
    public void push(T v)&amp;#123;storage.push(v);&amp;#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。
    public T peek() &amp;#123;return storage.peek();&amp;#125;
    public T pop() &amp;#123;return storage.pop();&amp;#125;
    public boolean isEmpty() &amp;#123;return storage.isEmpty();&amp;#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法
    @Override
    public String toString()&amp;#123;
        return storage.toString();
    &amp;#125;

&amp;#125;
</code></pre>
<p>onjava8中利用泛型实现的栈：</p>
<pre><code class="java">package com.test.day5;

import java.util.ArrayDeque;
import java.util.Deque;

public class Stack&lt;T&gt; &amp;#123;

    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();
    public void push(T v)&amp;#123;storage.push(v);&amp;#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。
    public T peek() &amp;#123;return storage.peek();&amp;#125;
    public T pop() &amp;#123;return storage.pop();&amp;#125;
    public boolean isEmpty() &amp;#123;return storage.isEmpty();&amp;#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法
    @Override
    public String toString()&amp;#123;
        return storage.toString();
    &amp;#125;

&amp;#125;
//测试：
public class StackTest2 &amp;#123;
    public static void main(String[] args) &amp;#123;
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();//创建此对象的同时，Stack类也将创建ArrayDeque对象
        for (String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))
            stack.push(s);
        while (!stack.isEmpty())
            System.out.println(stack.pop() + &quot; &quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><ul>
<li><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。  </p>
</li>
<li><p><strong>Set</strong> 最常见的用途是测试归属性。</p>
</li>
</ul>
<p>  **迭代器与集合 **</p>
<pre><code class="java">public class InterfaceVsIterator &amp;#123;
  public static void display(Iterator&lt;Pet&gt; it) &amp;#123;
    while(it.hasNext()) &amp;#123;
      Pet p = it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);//返回越过的值
    &amp;#125;
    System.out.println();
  &amp;#125;
  public static void display(Collection&lt;Pet&gt; pets) &amp;#123;
    for(Pet p : pets)
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    System.out.println();
  &amp;#125;
    /*两个版本的 display() 方法都可以使用 Map 或 Collection 的子类型来工作。 而且Collection 接口和 Iterator 都将 display() 方法与低层集合的特定实现解耦。
     Collection 要更方便一点，因为它是 Iterable 类型，因此在 display(Collection) 的实现中可以使用 for-in 构造，这使得代码更加清晰*/
  public static void main(String[] args) &amp;#123;
    List&lt;Pet&gt; petList = Pets.list(8);
    Set&lt;Pet&gt; petSet = new HashSet&lt;&gt;(petList);
    Map&lt;String, Pet&gt; petMap = new LinkedHashMap&lt;&gt;();
    String[] names = (&quot;Ralph, Eric, Robin, Lacey, &quot; +
      &quot;Britney, Sam, Spot, Fluffy&quot;).split(&quot;, &quot;);
    for(int i = 0; i &lt; names.length; i++)
      petMap.put(names[i], petList.get(i));
    display(petList);
    display(petSet);
    display(petList.iterator());
    display(petSet.iterator());
    System.out.println(petMap);
    System.out.println(petMap.keySet());
    display(petMap.values());
    display(petMap.values().iterator());
  &amp;#125;
&amp;#125;</code></pre>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><code>offer()</code>在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。</li>
<li><code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 </li>
<li><code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</li>
<li>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象</li>
</ul>
<pre><code class="java">package com.test.day4;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

public class QueueDemo &amp;#123;
    public static void printQ(Queue queue)&amp;#123;
        /*删除队列中所有元素*/
        while (queue.peek()!=null)//peek()查询队列第一个元素
            System.out.println(queue.remove()+&quot;&quot;);
        System.out.println();
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        Random rand = new Random(47);//用来生成随机数
        for (int i = 0; i &lt; 10; i++)
            queue.offer(rand.nextInt(i+10));//向队列添加元素
        printQ(queue);
        Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();
        for (char c: &quot;Brontosaurus&quot;.toCharArray())//将字符串分为单个字符加入队列中
            qc.offer(c);
        printQ(qc);

    &amp;#125;</code></pre>
<h3 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h3><ul>
<li>可以通过提供Comparator 来修改队列元素顺序。 </li>
<li><strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素</li>
<li><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</li>
</ul>
<pre><code class="java">import java.util.*;
/*int string 均有默认的大小顺序*/
public class PriorityQueueDemo &amp;#123;
  public static void main(String[] args) &amp;#123;
    PriorityQueue&lt;Integer&gt; priorityQueue =
      new PriorityQueue&lt;&gt;();
    Random rand = new Random();
    for(int i = 0; i &lt; 10; i++)
      priorityQueue.offer(rand.nextInt(i + 10));//将指定的元素插入此优先级队列。
    QueueDemo.printQ(priorityQueue);//删除并打印队列所有元素

    List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20,
      18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);
    priorityQueue = new PriorityQueue&lt;&gt;(ints);
    QueueDemo.printQ(priorityQueue);
    priorityQueue = new PriorityQueue&lt;&gt;(
        ints.size(), Collections.reverseOrder());//反序排列
    priorityQueue.addAll(ints);
    QueueDemo.printQ(priorityQueue);

    String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;
    List&lt;String&gt; strings =
      Arrays.asList(fact.split(&quot;&quot;));//将这个字符串分解为字母（依据空格）填入列表中
    PriorityQueue&lt;String&gt; stringPQ =
      new PriorityQueue&lt;&gt;(strings);
    QueueDemo.printQ(stringPQ);
    stringPQ = new PriorityQueue&lt;&gt;(
      strings.size(), Collections.reverseOrder());//按原stringPQ大小，创建一个新的队列，反并序排列
    stringPQ.addAll(strings);//将strings中的所有元素添加进队列
    QueueDemo.printQ(stringPQ);

    Set&lt;Character&gt; charSet = new HashSet&lt;&gt;();
    for(char c : fact.toCharArray())//toCharArray分割字符。
      charSet.add(c); 
    PriorityQueue&lt;Character&gt; characterPQ =
      new PriorityQueue&lt;&gt;(charSet);//创建队列对象并将集合的元素“安排”到队列中
    QueueDemo.printQ(characterPQ);
  &amp;#125;
&amp;#125;
/* Output:
0 1 1 1 1 1 3 5 8 14
1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25
25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1
      A A B C C C D D E E E F H H I I L N N O O O O S S
S T T U U U W
W U U U T T S S S O O O O N N L I I H H F E E E D D C C
C B A A
  A B C D E F H I L N O S T U W
*/</code></pre>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code class="java">package com.test.day5;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class Statistics &amp;#123;
    public static void main(String[] args) &amp;#123;
        Random rand = new Random(47);
        Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();//创建键值均为int类型的字典对象
        for (int i = 0; i &lt; 1000; i++)&amp;#123;
            int r = rand.nextInt(20);
            Integer freq = m.get(r);//查询有无值r，无则返回null
            m.put(r, freq == null ? 1: freq + 1 );//如字典中有这个值，则为其加一
        &amp;#125;
        System.out.println(m);
    &amp;#125;
&amp;#125;

</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#016a99>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-02/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-01/">
        <h2>
            接口
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p> 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p>
</blockquote>
<p>接口中可添加静态方法与默认方法；</p>
<p>一个类实现一个接口的同时必须实现该接口的所有方法（可以不用实现默认方法即关键词为为 default的方法）；</p>
<p><strong>extends</strong> 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p>
<h1 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h1><p><img src="http://img.lbkzw.cn/img/20200821084956.jpeg"></p>
<blockquote>
<p>把方法抽象封装到接口或抽象类中，在别的类中对其进行实现即，变得是内容，而其框架则始终如一。</p>
<p>就像我与大厨炒西红柿：大家都是加油、加鸡蛋、加西红柿。只是做出来时味道不同罢了。</p>
</blockquote>
<h1 id="接口与抽象类（选择）"><a href="#接口与抽象类（选择）" class="headerlink" title="接口与抽象类（选择）"></a>接口与抽象类（选择）</h1><table>
<thead>
<tr>
<th>特性</th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>组合</td>
<td>新类可以组合多个接口</td>
<td>只能继承单一抽象类</td>
</tr>
<tr>
<td>状态</td>
<td>不能包含属性（除了静态属性，不支持对象状态）</td>
<td>可以包含属性，非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td>默认方法 和 抽象方法</td>
<td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td>
<td>必须在子类中实现抽象方法</td>
</tr>
<tr>
<td>构造器</td>
<td>没有构造器</td>
<td>可以有构造器</td>
</tr>
<tr>
<td>可见性</td>
<td>隐式 <strong>public</strong></td>
<td>可以是 <strong>protected</strong> 或友元</td>
</tr>
</tbody></table>
<h1 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h1><ul>
<li>创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。</li>
</ul>
<pre><code class="java">import java.util.*;

class Processor &amp;#123;
    /*父类*/
    public String name() &amp;#123;
        return getClass().getSimpleName();
    &amp;#125;

    public Object process(Object input) &amp;#123;
        return input;
    &amp;#125;
&amp;#125;

/*子类开始，将所有传入类设置为同一个类的子类*/
class Upcase extends Processor &amp;#123;
    // 返回协变类型
    @Override 
    public String process(Object input) &amp;#123;
        return ((String) input).toUpperCase();
    &amp;#125;
&amp;#125;

class Downcase extends Processor &amp;#123;
    @Override
    public String process(Object input) &amp;#123;
        return ((String) input).toLowerCase();
    &amp;#125;
&amp;#125;

class Splitter extends Processor &amp;#123;
    @Override
    public String process(Object input) &amp;#123;
        // split() divides a String into pieces:
        return Arrays.toString(((String) input).split(&quot; &quot;));
    &amp;#125;
&amp;#125;

/*策略开始*/
public class Applicator &amp;#123;
    public static void apply(Processor p, Object s) &amp;#123;
        //(Processor p。已知：所有传入类设置为同一个类的子类，故其父类的变量可以作为引用
        System.out.println(&quot;Using Processor &quot; + p.name());//获取其类名
        System.out.println(p.process(s));//根据其类名调用其覆盖的相应的process方法
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        String s = &quot;We are such stuff as dreams are made on&quot;;
        //进入策略，以下3类均为Processor子类，故可用Processor p分别引用以下3个不同类型的对象
        apply(new Upcase(), s);
        apply(new Downcase(), s);
        apply(new Splitter(), s);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="常量字段"><a href="#常量字段" class="headerlink" title="常量字段"></a>常量字段</h1><blockquote>
<p>接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong></p>
</blockquote>
<pre><code class="java">public interface Months &amp;#123;
    int 
    JANUARY = 1, FEBRUARY = 2, MARCH = 3,
    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,
    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
    NOVEMBER = 11, DECEMBER = 12;
&amp;#125;</code></pre>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><blockquote>
<p>所有类都必须是公共可用的，唯独内部类不同。——一枝独秀</p>
</blockquote>
<ul>
<li>内部类的变量必须是最终变量。传入参数默认为fianl</li>
<li>创建内部类对象：在拥有外部类对象之前不可创建内部类对象，且必须使用外部类的对象来创建其内部类对象。</li>
<li>典型手法：外部类中的一个方法返回指向内部类的引用。</li>
<li>可以让内部类实现一个接口，再借接口变量对创建的内部类对象进行引用。</li>
<li>当内部类在方法内部时除该方法外，所有类与方法不得访问。</li>
<li>类只能继承一个父类，实现多个内部类继承类，则等同于实现类的多继承。</li>
</ul>
<h2 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h2><blockquote>
<p>利用内部类实现迭代器功能，对其外类元素（方法、字段）进行访问。</p>
</blockquote>
<pre><code class="java">package com.test.day2;

public class Sequence &amp;#123;
    private Object[] items;
    private int next = 0;
    public Sequence(int size)&amp;#123;
        items = new Object[size];
    &amp;#125;
    public void add(Object x)&amp;#123;
        if(next &lt; items.length)
            items[next++] = x;
    &amp;#125;
    private class SequenceSelector implements Selector&amp;#123;
        private  int i = 0;
        @Override
        public boolean end() &amp;#123;return  i == items.length;&amp;#125;
        @Override
        public Object current() &amp;#123;return  items[i];&amp;#125;
        @Override
        public void  next() &amp;#123;if (i &lt; items.length) i++;&amp;#125;//定义一个迭代器，if语句相当于hasNext
    &amp;#125;
    public Selector selector()&amp;#123;
        /*返回指向内部类的引用。*/
        return new SequenceSelector();
        //当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。
        // 然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        Sequence sequence = new Sequence(10);
        for (int i = 0; i &lt; 10; i++)
            sequence.add(Integer.toString(i));//Integer.toString()表示先讲int转换bai成Integer型，然后再将Integer转换成String型。
        Selector selector = sequence.selector();//返回、创建、引用内部类对象操作开始（此处使用接口变量，对内部类对象进行引用）
        //Selector selector = sequence.new SequenceSelector();//外部类方法返回内部类引用、创建内部类对象
        //var selector = sequence.new SequenceSelector();//简写引用、创建内部类对象
       // Sequence.SequenceSelector selector = sequence.new SequenceSelector();//使用外部类.内部类引用、创建内部类对象
        while (!selector.end())&amp;#123;
            System.out.println(selector.current() + &quot; &quot;);
            selector.next();
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<p>这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p>
<h2 id="this、new"><a href="#this、new" class="headerlink" title="this、new"></a>this、new</h2><pre><code class="java">public class DotThis &amp;#123;
    void f() &amp;#123; System.out.println(&quot;DotThis.f()&quot;); &amp;#125;

    public class Inner &amp;#123;
        public DotThis outer() &amp;#123;
            return DotThis.this;//创建对外部类对象的引用
        &amp;#125;
    &amp;#125;

    public Inner inner() &amp;#123; return new Inner(); &amp;#125;

    public static void main(String[] args) &amp;#123;
        DotThis dt = new DotThis();//在拥有外部类对象之前不可创建内部类对象。
        DotThis.Inner dti = dt.inner();//必须使用外部类的对象来创建其内部类对象
        dti.outer().f();
    &amp;#125;
&amp;#125;


public class DotNew &amp;#123;
    public class Inner &amp;#123;&amp;#125;
    public static void main(String[] args) &amp;#123;
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象
       // var dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul>
<li>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <strong>final</strong> 的</li>
</ul>
<blockquote>
<p>匿名内部类的初始化（借助抽象类）</p>
</blockquote>
<pre><code class="java">package com.test.day2;

abstract class Base &amp;#123;//抽象类的构造器
    Base(int i) &amp;#123;
        System.out.println(&quot;Base constructor, i = &quot; + i);
    &amp;#125;
    public abstract void f();
&amp;#125;
public class AnonymousConstructor &amp;#123;
    public static Base getBase(int i) &amp;#123;
        return new Base(i) &amp;#123;//利用抽象类构造器进行字段初始化。
            &amp;#123; System.out.println(
                    &quot;Inside instance initializer&quot;); &amp;#125;
            @Override
            public void f() &amp;#123;
                System.out.println(&quot;In anonymous f()&quot;);
            &amp;#125;
        &amp;#125;;
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        Base base = getBase(47);
        base.f();
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h2><blockquote>
<p>普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p>
</blockquote>
<ul>
<li><p>要创建嵌套类的对象，并不需要先创建其外部类的对象，即直接创建并引用即可。</p>
</li>
<li><p>不能从嵌套类的对象中访问非静态的外围类对象。</p>
</li>
</ul>
<pre><code class="java">public class Parcel11 &amp;#123;
    private static class ParcelContents implements Contents &amp;#123;
        private int i = 11;
        @Override
        public int value() &amp;#123; return i; &amp;#125;
    &amp;#125;
    protected static final class ParcelDestination
            implements Destination &amp;#123;
        private String label;
        private ParcelDestination(String whereTo) &amp;#123;
            label = whereTo;
        &amp;#125;
        @Override
        public String readLabel() &amp;#123; return label; &amp;#125;
        // Nested classes can contain other static elements:
        public static void f() &amp;#123;&amp;#125;
        static int x = 10;
        static class AnotherLevel &amp;#123;
            public static void f() &amp;#123;&amp;#125;
            static int x = 10;
        &amp;#125;
    &amp;#125;
    public static Destination destination(String s) &amp;#123;
        return new ParcelDestination(s);
    &amp;#125;
    public static Contents contents() &amp;#123;
        return new ParcelContents();
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        Contents c = contents();
        //并没有创建外部类的对象，再用外部类对象创建内部类。
        //var i = new Parcel11()
        //var c = i.contents()
        Destination d = destination(&quot;Tasmania&quot;);
    &amp;#125;
&amp;#125;</code></pre>
<pre><code class="java">/**一个接口内部的类（接口内方法、字段默认为final static）*/
public interface ClassInInterface &amp;#123;
    void howdy();
    class Test implements ClassInInterface &amp;#123;
        @Override
        public void howdy() &amp;#123;
            System.out.println(&quot;Howdy!&quot;);
        &amp;#125;
        public static void main(String[] args) &amp;#123;
            new Test().howdy();
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><blockquote>
<p>内部类无法被覆盖，但可通过继承覆盖其方法</p>
</blockquote>
<pre><code class="java">class WithInner &amp;#123;
    class Inner &amp;#123;
        public Yolk() &amp;#123;
            System.out.println(&quot;Egg.Yolk()&quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
public class InheritInner extends WithInner.Inner &amp;#123;//继承须以（外部类.内部）类形式。
    InheritInner(WithInner wi) &amp;#123;
        wi.super();
        @Override
        public Yolk() &amp;#123;
            System.out.println(&quot;BigEgg2.Yolk()&quot;);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    &amp;#125;
&amp;#125;</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code class="java">package cn.day.a5;

// files/PathInfo.java
import java.nio.file.*;
import java.net.URI;
import java.io.File;
import java.io.IOException;

public class PathInfo &amp;#123;
    static void show(String id, Object p) &amp;#123;
        System.out.println(id + &quot;: &quot; + p);
    &amp;#125;

    static void info(Path p) &amp;#123;
        show(&quot;toString&quot;, p);
        show(&quot;Exists&quot;, Files.exists(p));//测试文件是否存在
        show(&quot;RegularFile&quot;, Files.isRegularFile(p));
        show(&quot;Directory&quot;, Files.isDirectory(p));//测试文件是否是一个目录。
        show(&quot;Absolute&quot;, p.isAbsolute());//判断此路径是否为绝对路径
        show(&quot;FileName&quot;, p.getFileName());//返回文件名
        show(&quot;Parent&quot;, p.getParent());//返回此文件的父路径，无返回null
        show(&quot;Root&quot;, p.getRoot());//返回此文件的根路径，无返回null
        System.out.println(&quot;******************&quot;);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        System.out.println(System.getProperty(&quot;os.name&quot;));
        info(Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;));//转化路径（此方法将来可能被弃用）
        Path p = Paths.get(&quot;PathInfo.java&quot;);
        info(p);
        Path ap = p.toAbsolutePath();//获取这个文件的绝对路径
        info(ap);
        info(ap.getParent());
        try &amp;#123;/*传入p引用 文件的父路径，调用info进行处理*/
            info(p.toRealPath());
        &amp;#125; catch(IOException e) &amp;#123;
            System.out.println(e);
        &amp;#125;
        URI u = p.toUri();//返回一个URI来表示该路径
        System.out.println(&quot;URI: &quot; + u);
        Path puri = Paths.get(u);//给定的URI转换为Path对象。
        System.out.println(Files.exists(puri));
        File f = ap.toFile();
    &amp;#125;
&amp;#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#607d8b>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/hexo-01/">
        <h2>
            hexo for github的那些事情
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/hexo">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                hexo
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>首先申明：本篇并非安装hexo的教程，而是本人安装hexo时遇到的一些问题及解决方案。<br><strong>一站式部署hexo教程：</strong><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a><br>本人操作均按hexo<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a>进行。<br>按官方文档来，问题会比按网上的帖子少的多，且你遇到的问题一定有人已经遇到过，百度搜索你遇到的错误就很容易解决</p>
</blockquote>
<h2 id="官方第一坑"><a href="#官方第一坑" class="headerlink" title="官方第一坑"></a>官方第一坑</h2><p>官方文档中用gh-pages分支，可是全程没有提到，仅仅用到的时候才提到，这个会出问题，不如从一开始就在gh-pages分支上进行</p>
<h3 id="创建gh-pages分支"><a href="#创建gh-pages分支" class="headerlink" title="创建gh-pages分支"></a>创建gh-pages分支</h3><p><strong>创建分支时主分支的版本库不能为空</strong></p>
<pre><code class="git">git init //创建本地库
git branch -v //查看分支
vim index.html //创建文件（为win10用户请自行手动创建一个文件，仅仅提交版本库用）
git add .
git branch gh-pages//创建分支
</code></pre>
<h2 id="官方第二坑"><a href="#官方第二坑" class="headerlink" title="官方第二坑"></a>官方第二坑</h2><p>文档没有明明白白的说<code>deploy:</code>的填写<br><code>_config.yml</code>中<code>deploy:</code>一定要填写好：</p>
<pre><code class="hexo">deploy:
  type: &#39;git&#39;
  repo: 你远程库的ssh地址
  branch: gh-pages//分支名</code></pre>
<h2 id="hexo命令易懂叙述："><a href="#hexo命令易懂叙述：" class="headerlink" title="hexo命令易懂叙述："></a>hexo命令易懂叙述：</h2><pre><code class="hexo">hexo g //生成网页
hexo s //本地预览（部署网站到本地，测试用啦）
hexo d //部署网站到远程库
hexo clean //清除缓存（网页缓存）

hexo clean&amp;&amp;hexo g&amp;&amp;hexo s //连招，清除缓存生成网页并开启本地预览
hexo clean&amp;&amp;hexo g&amp;&amp;hexo d //连招，清除缓存生成网页并部署到远程库
</code></pre>
<h2 id="我用到的一些git命令："><a href="#我用到的一些git命令：" class="headerlink" title="我用到的一些git命令："></a>我用到的一些git命令：</h2><pre><code class="git">git add . //添加所有到版本库
git commit -m&quot;1&quot; //提交到本地库
git push blog gh-pages --force //本地库覆盖远程库
git config --global user.email xxx@163.com //本地标识
</code></pre>
<h2 id="我遇到的一些错误："><a href="#我遇到的一些错误：" class="headerlink" title="我遇到的一些错误："></a>我遇到的一些错误：</h2><p><code> 执行 hexo deploy 后,出现 error deployer not found:github 的错误</code><br><strong>解决方案：</strong><br><code>npm install hexo-deployer-git --save</code></p>
<p><strong>忘记遇到的什么问题了：</strong><code>npm install hexo-renderer-pug hexo-renderer-stylus </code></p>
<p>  ps：博客，电脑访问不了的话，可以换手机试试。最经网络老抽风无法访问github.io后缀的域名</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/hexo" style=color:#006674>
                hexo
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/git" style=color:#016a99>
                git
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/github" style=color:#006674>
                github
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/hexo-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Cookie-01/">
        <h2>
            Cookie
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JavaWeb">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JavaWeb
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote>
<p>用户访问一个网站时，服务器响应时返回cookie，当用户再次访问此网站时（请求头）会携带cookie，服务器以cookie识别用户</p>
</blockquote>
<p>作用：在不登录的情况下，完成服务器对客户端的身份识别</p>
<p>常用方法：</p>
<p><code>new Cookie(String name, String value) </code>创建Cookie并初始化数据     <code>response.addCookie(Cookie cookie) </code>发送Cookie到客户端<br><code>Cookie[]  request.getCookies() </code>获取Cookie</p>
<p><code>setMaxAge(int seconds)</code>用于指定cookie存活时间，时间到后，cookie文件自动失效</p>
<pre><code>               1. 正数：将Cookie数据写到硬盘的文件中，以秒为单位计时，到期cookie自动失效
               2. 负数：默认值,关闭浏览器就删除cookie
               3. 零：删除cookie信息</code></pre>
<p>将中文数据存储至cookie事先要进行URL编码操作，在需要的时候进行解码操作</p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code class="java">
/**
是否为首次访问：如是则发出欢迎语句，否则提示上次登录时间*/
@WebServlet(&quot;/CookieTest&quot;)
public class CookieTest extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        response.setContentType(&quot;text/html;charset=utf-8&quot;);//设置响应消息体格式以及编码

        Cookie[] cookies = request.getCookies();//获取Cookie
        boolean flag = false;//是否首次访问的标志，默认为false

        //遍历cookies
        if (cookies !=null &amp;&amp; cookies.length &gt; 0)&amp;#123;
            for (Cookie cookie:cookies) &amp;#123;
                String name = cookie.getName();//获取cookie名称
                System.out.println(&quot;cookie name=&quot;+name);
                //不是第一次访问
                if (&quot;lastTime&quot;.equals(name))&amp;#123;
                    flag = true;//第一次访问后将其设为true
                    Date date = new Date();//获取当前时间
                    //设置日期格式
                    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);
                    String str_date = sdf.format(date);//对日期进行格式化
                    System.out.println(&quot;编码前：&quot;+str_date);
                    //URL编码（对中文进行编码便于存储至cookie）
                    str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);
                    System.out.println(&quot;编码后：&quot;+str_date);
                    cookie.setValue(str_date);//修改cookie的值
                    cookie.setMaxAge(60*60*24*30);//设置cookie有效期一个月
                    response.addCookie(cookie);//发送cookie到客户端

                    //响应操作
                    String value = cookie.getValue();
                    System.out.println(&quot;解码前： &quot;+ value);
                    value = URLDecoder.decode(value,&quot;utf-8&quot;);//解码操作
                    System.out.println(&quot;解码后：&quot; + value);
                    response.getWriter().write(&quot;欢迎回来！您上次访问时间为：&quot; + value);
                    break;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        if (cookies!=null || cookies.length&gt;0 || flag ==false)&amp;#123;
            Date date = new Date();//获取当前时间
            //设置日期格式
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);
            String str_date = sdf.format(date);//对日期进行格式化
            System.out.println(&quot;编码前：&quot;+str_date);
            //URL编码（对中文进行编码便于存储至cookie）
            str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);
            System.out.println(&quot;编码后：&quot;+str_date);
            Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);//创建名为lastTime值为当前时间的cookie
            cookie.setMaxAge(60*60*24*30);//设置cookie有效期一个月
            response.addCookie(cookie);//发送cookie到客户端

            //响应
            response.getWriter().write(&quot;欢迎您首次访问！&quot;);
        &amp;#125;
    &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        this.doPost(request, response);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="共享Cookie"><a href="#共享Cookie" class="headerlink" title="共享Cookie"></a>共享Cookie</h1><p>同一服务器下共享：</p>
<p><code>setPath(String path)</code>设置cookie的获取范围。</p>
<p>默认情况下，设置当前的虚拟目录如果要共享，则可将path设置为”/“</p>
<p>同一域名下共享：</p>
<p><code>setDomain(String path)</code>:如果设置一级域名相同，那么多个服务器之间cookie可以共享</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<p>Session的实现依赖于Cookie</p>
<p><img src="http://img.lbkzw.cn/img/20201012161222.png" alt="image-20201012161222663"></p>
<p>session的特点</p>
<ol>
<li>session用于存储一次会话的多次请求的数据，存在服务器端<ol start="2">
<li>session可以存储任意类型，任意大小的数据</li>
</ol>
</li>
</ol>
<p>session与Cookie的区别：</p>
<ol>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全</li>
</ol>
<p>方法：</p>
<p>获取HttpSession对象</p>
<p><code>HttpSession session = request.getSession();</code> </p>
<p>使用HttpSession对象</p>
<p><code>Object getAttribute(String name)  </code></p>
<p><code>void setAttribute(String name, Object value)</code><br><code>void removeAttribute(String name)  </code></p>
<pre><code class="java">//在一次会话的多次请求间共享数据
@WebServlet(&quot;/SessionDemo1&quot;)
public class SessionDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        HttpSession session = request.getSession();//获取Session对象
        session.setAttribute(&quot;msg&quot;,&quot;Hello Session!&quot;);//设置Session
    &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        this.doPost(request, response);
    &amp;#125;
&amp;#125;


@WebServlet(&quot;/SessionDemo2&quot;)
public class SessionDemo2 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        HttpSession session = request.getSession();//获取Session对象
        Object msg =session.getAttribute(&quot;msg&quot;);//获取键为msg的值
        System.out.println(msg);
    &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        this.doPost(request, response);
    &amp;#125;
&amp;#125;
</code></pre>
<p><strong>当客户端关闭后，服务器不关闭，再次获取得的Session与之前的Session不是同一个</strong></p>
<p>如何在关闭客户端或服务端的前提下，保存Session数据呢？</p>
<p>创建Cookie,键为JSESSIONID，并存入Session id。</p>
<pre><code class="java">@WebServlet(&quot;/SessionDemo2&quot;)
public class SessionDemo2 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        HttpSession session = request.getSession();//获取Session对象

        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,session.getId());
        cookie.setMaxAge(60*60);
        response.addCookie(cookie);
    &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        this.doPost(request, response);
    &amp;#125;
&amp;#125;</code></pre>
<p><strong>客户端不关闭，服务器关闭后，两次获取的session不是同一个，且数据不丢失。</strong></p>
<p>tomcat自动完成以下工作：</p>
<blockquote>
<p>session的钝化：            </p>
<p>在服务器正常关闭之前，将session对象系列化到硬盘上（保存临时文件至Work目录）</p>
<p>session的活化：</p>
<p>在服务器启动后，将session文件转化为内存中的session对象即可。</p>
<p>在idea里的web项目，在重启Tomcat后会删除保存临时文件的Work目录，再新建Work目录从而无法完成活化。</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Cookie" style=color:#016a99>
                Cookie
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#016a99>
                Java
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Session" style=color:#016a99>
                Session
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Cookie-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/TomCat-01/">
        <h2>
            request对象
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p> request对象和response对象的原理:</p>
<ol>
<li>request和response对象是由服务器创建的。我们来使用它们</li>
<li>request对象是来获取请求消息，response对象是来设置响应消息</li>
</ol>
<h1 id="获取请求行信息"><a href="#获取请求行信息" class="headerlink" title="获取请求行信息"></a>获取请求行信息</h1><pre><code class="java">@WebServlet(&quot;/requestDemo&quot;)//注解添加虚拟访问路径
public class requestDemo extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;

    &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        String method = request.getMethod();//获取请求方法
        String contextPath = request.getContextPath();//获取虚拟目录
        String servletPath = request.getServletPath();//获取servlet路径
        String queryString = request.getQueryString();//获取请求参数
        String requestURI = request.getRequestURI();//获取url
        String protocol = request.getProtocol();//获取访问协议信息
        String remoteAddr = request.getRemoteAddr();//获取客户端ip

        System.out.println(method);
        System.out.println(contextPath);
        System.out.println(servletPath);
        System.out.println(queryString);
        System.out.println(requestURI);
        System.out.println(protocol);
        System.out.println(remoteAddr);
    &amp;#125;
    /*运行结果：
        GET
        /demo1
        /requestDemo
        null
        0:0:0:0:0:0:0:1
        /demo1/requestDemo
        HTTP/1.1
        */
&amp;#125;
</code></pre>
<h1 id="获取请求头信息"><a href="#获取请求头信息" class="headerlink" title="获取请求头信息"></a>获取请求头信息</h1><ul>
<li><code>String getHeader(String name)</code>通过请求头的名称获取请求头</li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code>获取所有的请求头名称</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/requestDemo2&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;

        &amp;#125;



    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;

//获取请求头
        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();//获取全部请求头名称
        while (headerNames.hasMoreElements()) &amp;#123;
            String name = headerNames.nextElement();//这个方法像迭代器的next()一样
            String value = request.getHeader(name);//根据请求头名称获取值
            System.out.println(name+&quot;-----&quot;+value);
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="请求头例子：（判断客户端，设置防盗链等）"><a href="#请求头例子：（判断客户端，设置防盗链等）" class="headerlink" title="请求头例子：（判断客户端，设置防盗链等）"></a>请求头例子：（判断客户端，设置防盗链等）</h2><pre><code class="java">@WebServlet(&quot;/requestDemo2&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;

        &amp;#125;


    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        //防盗链例子：
         String referer = request.getHeader(&quot;referer&quot;);
         System.out.println(referer);
         if (referer!=null)&amp;#123;
             if (referer.contains(&quot;/demo&quot;))&amp;#123;
                 response.setContentType(&quot;text/html;charset=utf-8&quot;);
                 response.getWriter().write(&quot;播放电影....&quot;);
             &amp;#125;else &amp;#123;
                 response.setContentType(&quot;text/html;charset=utf-8&quot;);
                 response.getWriter().write(&quot;想看电影吗？来优酷吧...&quot;);
             &amp;#125;
         &amp;#125;

//判断客户端
//        String agent = request.getHeader(&quot;user-agent&quot;);
//        if (agent.contains(&quot;Chrome&quot;)) System.out.println(&quot;谷歌浏览器~~~&quot;);//判断客户端是否为谷歌浏览器

    &amp;#125;
&amp;#125;

</code></pre>
<h1 id="获取请求体信息"><a href="#获取请求体信息" class="headerlink" title="获取请求体信息"></a>获取请求体信息</h1><p>POST请求方式才有请求体，请求体中封装了POST请求参数。</p>
<ul>
<li><code>BufferedReader getReader()</code>获取字符输入流，只能操作字符数据</li>
<li><code>ServletInputStream getInputStream()</code>获取字节输入流，可以操作所有类型数据</li>
</ul>
<pre><code class="java">     @WebServlet(&quot;/requestDemo2&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;


        &amp;#125;


    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;


&amp;#125;

 //以字节流形式读取请求信息
 BufferedReader br = request.getReader();//获取字节流
         String line = null;
         while ((line = br.readLine())!=null)&amp;#123;//读取
             System.out.println(line);</code></pre>
<h2 id="POST方式乱码问题"><a href="#POST方式乱码问题" class="headerlink" title="POST方式乱码问题"></a>POST方式乱码问题</h2><p>GET方式的乱码已由Tomcat解决，仅有POST方式存在乱码</p>
<pre><code class="java">       @WebServlet(&quot;/requestDemo2&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;


        &amp;#125;


    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
     request.setCharacterEncoding(&quot;utf-8&quot;);//设置流编码，指定名称获取值是通过流的形式进行的，故会存在编码问题。
        String username = request.getParameter(&quot;username&quot;);//获取指定名称参数值

        Map&lt;String ,String[]&gt; parameterMap = request.getParameterMap();//获取所有参数并装入map集合

        Set&lt;String&gt; keyset = parameterMap.keySet();//将值存入视图进行遍历准备
        for (String s : keyset) &amp;#123;
            String[] values = parameterMap.get(s);
            for (String value:values)&amp;#123;
                System.out.println(value);
            &amp;#125;

        &amp;#125;

        System.out.println(username);

&amp;#125;
</code></pre>
<h1 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h1><p>转发是指在服务器内部资源间跳转；</p>
<p>即使跳转到多个资源也仅仅是在一个请求的范围内；</p>
<p>跳转时地址栏地址不变。</p>
<pre><code class="java">@WebServlet(&quot;/requestDemo&quot;)
public class requestDemo extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;

       //转发 
       request.getRequestDispatcher(&quot;/requestDemo1&quot;).forward(request,response);
        //getRequestDispatcher(&quot;/requestDemo1&quot;)获取转发对象
        //forward(request,response)进行转发操作
        System.out.println(&quot;requestDemo被访问&quot;);

    &amp;#125;


    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        this.doPost(request,response);
        //因为访问页面默认为GET访问，提交表单多为POST访问;
        //所以此处需调用doPost方法并传入参数
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="java">@WebServlet(&quot;/requestDemo1&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        System.out.println(&quot;requestDemo1被访问&quot;);

        &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
            this.doPost(request,response);
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h1><ul>
<li><code>void setAttribute(String name,Object obj)</code>:存储数据</li>
<li><code>Object getAttitude(String name)</code>:通过键获取值</li>
<li><code>void removeAttribute(String name)</code>:通过键移除键值对</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/requestDemo1&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
        Object hello = request.getAttribute(&quot;hello&quot;);//通过键糊获取值
        System.out.println(hello);
        &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
            this.doPost(request,response);
    &amp;#125;
&amp;#125;</code></pre>
<pre><code class="java">       @WebServlet(&quot;/requestDemo1&quot;)
public class requestDemo1 extends HttpServlet &amp;#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
       request.setAttribute(&quot;hello&quot;,&quot;hello world!&quot;);//存储数据(键值)
        request.getRequestDispatcher(&quot;/requestDemo1&quot;).forward(request,response);
        &amp;#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &amp;#123;
            this.doPost(request,response);
    &amp;#125;
&amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Tomcat" style=color:#016a99>
                Tomcat
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/TomCat-01/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/5">
                <span class="page-num">
                    5
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>