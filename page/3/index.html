
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/20/20210213/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>很久没有更新blog了。</p>
<p>多年以后你会想起么，也会同样哼着这首歌。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/20210213/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/2020-dataB-End/">
        <h2>
            期末作业-数据库mysql
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="原题如下"><a href="#原题如下" class="headerlink" title="原题如下"></a>原题如下</h1><p>设有一个工程供应数据库系统，包括如下四个关系模式： </p>
<p>S(SNO，SNAME， STATUS，CITY)；（SNO的域为1001-1999） </p>
<p>P(PNO，PNAME，COLOR，WEIGHT)； （PNO的域为2001-2999）</p>
<p>J(JNO，JNAME，CITY)；（JNO的域为3001-3999） </p>
<p>SPJ(SNO，PNO，JNO，QTY)； </p>
<p>供应商表S由供应商号、供应商名、状态、城市组成； </p>
<p>零件表P 由零件号、零件名、颜色、重量组成； </p>
<p>工程项目表J由项目号、项目名、城市组成； </p>
<p>供应情况表SPJ由供应商号、零件号、项目号、供应数量组成； </p>
<p>1、创建数据库SPJ；</p>
<p>2、使用数据库SPJ；</p>
<p>3、创建4个具体表，分别为供应商表S、零件表P、工程项目表J、供应情况表SPJ；</p>
<p>4、每个表分别插入2-3条数据（供应商名为自己姓名）；</p>
<p>5、用SQL查询供应工程J3001零件为红色的工程号JNO；</p>
<p>6、用SQL查询没有使用天津供应商生产的零件的工程号；</p>
<p>7、用SQL语句将全部红色零件改为蓝色； </p>
<p>8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系；</p>
<p>9、用SQL语句删除供应商表S中SNO为1001的供应商；</p>
<h1 id="答题操作"><a href="#答题操作" class="headerlink" title="答题操作"></a>答题操作</h1><p>沙雕第一步建库再删库</p>
<h2 id="1、创建数据库SPJ"><a href="#1、创建数据库SPJ" class="headerlink" title="1、创建数据库SPJ"></a>1、创建数据库SPJ</h2><p><code>CREATE DATABASE SPJ;</code></p>
<h2 id="2-使用数据库SPJ"><a href="#2-使用数据库SPJ" class="headerlink" title="2.使用数据库SPJ"></a>2.使用数据库SPJ</h2><p><code>USE spj;</code></p>
<h2 id="3、创建4个具体表"><a href="#3、创建4个具体表" class="headerlink" title="3、创建4个具体表"></a>3、创建4个具体表</h2><p>分别为供应商表S、零件表P、工程项目表J、供应情况表SPJ</p>
<p><strong>创建供应商表S</strong></p>
<pre><code class="sql">
CREATE TABLE `S`(
`SNO` INT NOT NULL AUTO_INCREMENT, -- 不为null 自增长 
`SNAME` VARCHAR(100) NOT NULL,
`STATUS`VARCHAR(100) NOT NULL,
`CITY` VARCHAR(100) NOT NULL,
PRIMARY KEY ( `SNO` ),   -- 设置SNO为主键
CHECK(`SNO`&gt;=1001 AND `SNO`&lt;1999) -- 设置列范围
)ENGINE=INNODB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8;  -- 设置数据库引擎为INNODB 主键自增长从1001开始 默认编码为utf8


</code></pre>
<p><strong>创建零件表P</strong></p>
<pre><code class="sql">CREATE TABLE `P`(
`PNO` INT NOT NULL AUTO_INCREMENT,
`PNAME` VARCHAR(100) NOT NULL,
`COLOR`VARCHAR(100) NOT NULL,
`WEIGHT` VARCHAR(100) NOT NULL,
PRIMARY KEY ( `PNO` ),
CHECK(`PNO`&gt;=2001 AND `PNO`&lt;2999)
)ENGINE=INNODB AUTO_INCREMENT=2001 DEFAULT CHARSET=utf8;
</code></pre>
<p><strong>创建工程项目表J</strong></p>
<pre><code class="sql">CREATE TABLE `J`(
`JNO` INT NOT NULL AUTO_INCREMENT,
`JNAME` VARCHAR(100) NOT NULL,
`CITY`VARCHAR(100) NOT NULL,
PRIMARY KEY ( `JNO` ),
CHECK(`JNO`&gt;=3001 AND `JNO`&lt;3999)
)ENGINE=INNODB AUTO_INCREMENT=2001 DEFAULT CHARSET=utf8;
</code></pre>
<p><strong>供应情况表SPJ</strong></p>
<pre><code class="sql">CREATE TABLE `SPJ`(
`SNO` VARCHAR(100) NOT NULL,
`PNO` VARCHAR(100) NOT NULL,
`JNO` VARCHAR(100) NOT NULL,
`QTY` VARCHAR(100) NOT NULL
)ENGINE=INNODB DEFAULT CHARSET=utf8;
</code></pre>
<h2 id="4、每个表分别插入2-3条数据（供应商名为自己姓名）"><a href="#4、每个表分别插入2-3条数据（供应商名为自己姓名）" class="headerlink" title="4、每个表分别插入2-3条数据（供应商名为自己姓名）"></a>4、每个表分别插入2-3条数据（供应商名为自己姓名）</h2><p><strong>供应商表S插入数据</strong></p>
<pre><code class="sql">INSERT INTO `s`
VALUES (&#39;1001&#39;,&#39;赵玉豪&#39;,&#39;火爆&#39;,&#39;深圳&#39;);
INSERT INTO `s`
VALUES (&#39;1002&#39;,&#39;赵玉豪&#39;,&#39;火爆&#39;,&#39;深圳&#39;);
</code></pre>
<p><strong>供零件表S插入数据</strong></p>
<pre><code class="sql">INSERT INTO `p`
VALUES (&#39;2002&#39;,&#39;把手&#39;,&#39;白色&#39;,&#39;5kg&#39;);
INSERT INTO `p`
VALUES (&#39;2002&#39;,&#39;把手&#39;,&#39;白色&#39;,&#39;5kg&#39;);
</code></pre>
<p><strong>工程项目表S插入数据</strong></p>
<pre><code class="sql">INSERT INTO `j`
VALUES (&#39;3001&#39;,&#39;wwz666&#39;,&#39;深圳&#39;);
</code></pre>
<pre><code class="sql">INSERT INTO `j`
VALUES (&#39;3002&#39;,&#39;wwz666666&#39;,&#39;深圳&#39;);
</code></pre>
<p><strong>供应情况表SPJ插入数据</strong></p>
<pre><code class="sql">INSERT INTO `spj`
VALUES (&#39;1001&#39;,&#39;2001&#39;,&#39;3001&#39;,&#39;100&#39;);
INSERT INTO `spj`
VALUES (&#39;1002&#39;,&#39;2002&#39;,&#39;3002&#39;,&#39;200&#39;);
</code></pre>
<h2 id="5、用SQL查询供应工程J3001零件为红色的工程号JNO；"><a href="#5、用SQL查询供应工程J3001零件为红色的工程号JNO；" class="headerlink" title="5、用SQL查询供应工程J3001零件为红色的工程号JNO；"></a>5、用SQL查询供应工程J3001零件为红色的工程号JNO；</h2><pre><code class="sql">SELECT DISTINCT JNO,COLOR FROM J,P
WHERE JNO=&#39;J3001&#39; AND COLOR=&#39;红色&#39;
</code></pre>
<h2 id="6、用SQL查询没有使用天津供应商生产的零件的工程号；"><a href="#6、用SQL查询没有使用天津供应商生产的零件的工程号；" class="headerlink" title="6、用SQL查询没有使用天津供应商生产的零件的工程号；"></a>6、用SQL查询没有使用天津供应商生产的零件的工程号；</h2><pre><code class="sql">SELECT JNO FROM J
WHERE NOT CITY IN(&#39;天津&#39;)
</code></pre>
<h2 id="7、用SQL语句将全部红色零件改为蓝色；"><a href="#7、用SQL语句将全部红色零件改为蓝色；" class="headerlink" title="7、用SQL语句将全部红色零件改为蓝色；"></a>7、用SQL语句将全部红色零件改为蓝色；</h2><pre><code class="sql">UPDATE p
SET COLOR=&#39;蓝色&#39;;
</code></pre>
<h2 id="8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系"><a href="#8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系" class="headerlink" title="8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系"></a>8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系</h2><pre><code class="sql">INSERT INTO `spj`
VALUES (&#39;S1001&#39;,&#39;P2001&#39;,&#39;J3001&#39;,&#39;400&#39;);
</code></pre>
<h2 id="9、用SQL语句删除供应商表S中SNO为1001的供应商"><a href="#9、用SQL语句删除供应商表S中SNO为1001的供应商" class="headerlink" title="9、用SQL语句删除供应商表S中SNO为1001的供应商"></a>9、用SQL语句删除供应商表S中SNO为1001的供应商</h2><pre><code class="sql">DELETE FROM s
WHERE SNO=&#39;1001&#39;;
</code></pre>
<h1 id="最终效果如下："><a href="#最终效果如下：" class="headerlink" title="最终效果如下："></a>最终效果如下：</h1><p>暂未上传<br><img src="https://img.lbkzw.cn/img/image-20201214090605188.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/sql" style=color:#607d8b>
                sql
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/2020-dataB-End/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/20210805/">
        <h2>
            找回宝塔面板信息|ssh密钥免密登录服务器
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/ubuntu">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                ubuntu
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="找回宝塔面板信息"><a href="#找回宝塔面板信息" class="headerlink" title="找回宝塔面板信息"></a>找回宝塔面板信息</h1><ol>
<li>ssh连接服务器</li>
<li>输入 <code>/etc/init.d/bt default</code></li>
<li>解决</li>
</ol>
<p>补充：</p>
<ul>
<li><p>不用使用额外的ssh工具连接服务器，Linux下shell终端即可（win系统使用git终端也可）</p>
</li>
<li><p>附ssh常用命令：</p>
<pre><code class="shell">
ssh root@127.0.0.1 #以root用户登入服务器地址为127.0.0.1的服务器
ssh root@127.0.0.1 -i id_rsa #使用密钥登录，通常不用输入密码（不过要事先设置，如何设置请看下：）
</code></pre>
<p><strong>前情提示：win系统需要借助git终端</strong></p>
<p>下面我们三步走：</p>
<ol>
<li><p>生成密钥——一路回车</p>
<p><img src="http://img.lbkzw.cn/img/image-20210805133916778.png"></p>
</li>
</ol>
<ol start="2">
<li><p>上传密钥</p>
<p><img src="http://img.lbkzw.cn/img/image-20210805134301432.png" alt="image-20210805134301432"></p>
</li>
<li><p>使用密钥链接</p>
<p><img src="http://img.lbkzw.cn/img/image-20210805134359023.png" alt="image-20210805134359023"></p>
</li>
</ol>
<ul>
<li><p>上面操作用到的command</p>
<pre><code class="ssh">#注意密钥默认存放在.ssh目录（注意你的位置）
#生成密钥
ssh-keygen -t rsa 
#上传密钥
ssh-copy-id -i id_rsa.pub root@127.0.0.1 -p 22
</code></pre>
</li>
</ul>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/shell" style=color:#6484be>
                shell
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/20210805/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Ajax-01/">
        <h2>
            Ajax
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JavaWeb">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JavaWeb
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>用于局部刷新</p>
</blockquote>
<h1 id="异步对象-XMLHttpRequest"><a href="#异步对象-XMLHttpRequest" class="headerlink" title="异步对象(XMLHttpRequest)"></a>异步对象(XMLHttpRequest)</h1><p> readyState属性表示异步对象请求的状态变化<br>     0：创建异步对象时， new XMLHttpRequest();<br>     1: 初始异步请求对象， xmlHttp.open()<br>     2：发送请求， xmlHttp.send()<br>     3: 从服务器端获取了数据，此时3， 注意3是异步对象内部使用， 获取了原始的数据。<br>     4：异步对象把接收的数据处理完成后。 此时开发人员在4的时候处理数据。<br>        在4的时候，开发人员更新当前页面。</p>
<h2 id="计算bmi"><a href="#计算bmi" class="headerlink" title="计算bmi"></a>计算bmi</h2><p>demo全局刷新：</p>
<pre><code class="java">//servlet部分
public class BmiServlet extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String name = request.getParameter(&quot;name&quot;);
        String height = request.getParameter(&quot;height&quot;);
        String weight = request.getParameter(&quot;weight&quot;);

        float h = Float.valueOf(height);
        float w = Float.valueOf(weight);
        float bmi = w/(h*h);
        //判断bmi
        String msg = &quot;&quot;;
        if( bmi &lt;= 18.5) &#123;
            msg = &quot;您比较瘦&quot;;
        &#125; else if( bmi &gt; 18.5 &amp;&amp; bmi &lt;= 23.9 )&#123;
            msg = &quot;你的bmi是正常的&quot;;
        &#125; else if( bmi &gt;24 &amp;&amp; bmi &lt;=27)&#123;
            msg = &quot;你的身体比较胖&quot;;
        &#125; else &#123;
            msg = &quot;你的身体肥胖&quot;;
        &#125;
        System.out.println(&quot;msg=&quot;+msg);
        msg = &quot;你好，&quot;+ name +&quot; &quot;+&quot;你的bim为&quot;+bmi + msg;
        //存入bmi数据
        request.setAttribute(&quot;msg&quot;,msg);
        //这里通过response并以流的方式将数据传输到前端页面
           response.setContentType(&quot;text/html;charset=utf-8&quot;);
        PrintWriter pw = response.getWriter();
        pw.println(msg);
        pw.flush();
        pw.close();

        //注意！！！这里使用的是转发来完成前后端交互
       // request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(request,response);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<pre><code class="jsp">&lt;%--Jsp提交表单部分--%&gt;
&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;全局刷新计算bmi&lt;/p&gt;
&lt;%--注意这里使用的是表单，而我们案例中的局部刷新并未使用表单来提交前端数据--%&gt;
&lt;form action=&quot;bmiPrintServlet&quot; method=&quot;get&quot;&gt;
    姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;
    身高：&lt;input type=&quot;text&quot; name=&quot;height&quot;&gt;&lt;br/&gt;
    体重：&lt;input type=&quot;text&quot; name=&quot;weight&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;

&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="jsp">&lt;%--Jsp显示结果部分--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;显示bmi结果&lt;/h3&gt;
&lt;p&gt;$&#123;msg&#125;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>demo局部刷新</p>
<pre><code class="jsp">&lt;%--Jsp提交并显示结果部分--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;局部刷新-ajax&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //使用内存中的异步对象，代替浏览器发起请求。异步对象使用js创建和管理的。

        function  doAjax() &#123;
            //1.创建异步对象
            var xmlHttp = new XMLHttpRequest();
            //2.绑定事件
            xmlHttp.onreadystatechange = function () &#123;
                //处理服务器端返回的数据，更新当前页面
                //alert(&quot;readyState属性值======&quot; + xmlHttp.readyState + &quot;| status:&quot; + xmlHttp.status)
                if( xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status ==200)&#123;
                    var  data = xmlHttp.responseText;
                    //更新dom对象， 更新页面数据
                    document.getElementById(&quot;mydata&quot;).innerText = data;
                &#125;
            &#125;

            //3.初始请求数据
            //获取dom对象的value属性值
            var name = document.getElementById(&quot;name&quot;).value;
            var w = document.getElementById(&quot;w&quot;).value;
            var h = document.getElementById(&quot;h&quot;).value;

            //bmiPrint?name=李四&amp;w=82&amp;h=1.8
            var param = &quot;name=&quot;+name + &quot;&amp;w=&quot;+w+&quot;&amp;h=&quot;+h;
            //alert(&quot;param=&quot;+param);
            xmlHttp.open(&quot;get&quot;,&quot;bmiAjax?&quot;+param,true);

            //4.发起请求
            xmlHttp.send();
        &#125;



    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;局部刷新ajax-计算bmi&lt;/p&gt;
&lt;div&gt;
    &lt;!-- 没有使用form  --&gt;
    姓名：&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; &lt;br/&gt;
    体重（公斤）:&lt;input type=&quot;text&quot; id=&quot;w&quot; /&gt; &lt;br/&gt;
    身高（米）：&lt;input type=&quot;text&quot; id=&quot;h&quot; /&gt; &lt;br/&gt;
    &lt;input type=&quot;button&quot; value=&quot;计算bmi&quot; onclick=&quot;doAjax()&quot;&gt;
    &lt;br/&gt;
    &lt;br/&gt;
    &lt;div id=&quot;mydata&quot;&gt;等待加载数据....&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><blockquote>
<p>将对象转为Json格式的字符串</p>
</blockquote>
<p>Servlet:</p>
<pre><code class="java">package cn.it.three.controller;

import cn.it.three.dao.ProvinceDao;
import cn.it.three.entity.Province;
import com.fasterxml.jackson.databind.ObjectMapper;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;


public class QueryJsonServlet extends HttpServlet &#123;
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String json = &quot;&#123;&#125;&quot;;
        String strProid = request.getParameter(&quot;proid&quot;);
        if (strProid != null &amp;&amp; strProid.trim().length()&gt;0 )&#123;
            //查询数据库
            ProvinceDao dao = new ProvinceDao();
            Province p = dao.queryProvinceById(Integer.valueOf(strProid));//将以对象的形式返回查询结果
            //将对象转换为json数据
            ObjectMapper om = new ObjectMapper();
            json =om.writeValueAsString(p);
        &#125;
        //返回数据到前端
        response.setContentType(&quot;application/json;charset=utf-8&quot;);//设置json输出编码为utf-8
        PrintWriter printWriter = response.getWriter();
        printWriter.println(json);
        printWriter.flush();
        printWriter.close();
    &#125;
&#125;
</code></pre>
<p>DAO：</p>
<pre><code class="java">package cn.it.three.dao;

import cn.it.three.entity.Province;

import java.sql.*;

//返回单个数据
public class ProvinceDao &#123;

    //根据id获取名称
    public String queryProvinceNameById(Integer provinceId) &#123;
        Connection conn = null;
        PreparedStatement pst = null;
        ResultSet rs = null;
        String sql = &quot;&quot;;

        String url = &quot;jdbc:mysql://localhost:3306/springdb&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;

        String name = &quot;&quot;;

        try &#123;
            //加载驱动包
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //建立数据库连接
            conn = DriverManager.getConnection(url, username, password);
            //创建PreparedStatement
            sql = &quot;select  name from province where id=?&quot;;
            pst = conn.prepareStatement(sql);
            //设置参数值
            pst.setInt(1, provinceId);
            //执行sql
            rs = pst.executeQuery();
            //遍历rs
            /*while(rs.next())&#123; //当你的rs中有多余一条记录时。
               name =  rs.getString(&quot;name&quot;);
            &#125;*/

            if (rs.next()) &#123;
                name = rs.getString(&quot;name&quot;);
            &#125;

        &#125; catch (ClassNotFoundException | SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭资源
            try &#123;
                if (rs != null) &#123;
                    rs.close();
                &#125;
                if (pst != null) &#123;
                    pst.close();
                &#125;
                if (conn != null) &#123;
                    conn.close();
                &#125;

            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

        &#125;
        return name;
    &#125;
    
    //查询单个数据返回一个包含多个数据的对象
    public Province queryProvinceById(Integer provinceId) &#123;
        Connection conn = null;
        PreparedStatement pst = null;
        ResultSet rs = null;
        String sql = &quot;&quot;;

        String url = &quot;jdbc:mysql://localhost:3306/springdb&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;

        Province province = null;//借助json返回多个信息时，我们采用返回对象的方式（json会对对象进行处理）

        try &#123;
            //加载驱动包
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //建立数据库连接
            conn = DriverManager.getConnection(url, username, password);
            //创建PreparedStatement
            sql = &quot;select  id,name,jiancheng,shenghui from province where id=?&quot;;
            pst = conn.prepareStatement(sql);
            //设置参数值
            pst.setInt(1, provinceId);
            //执行sql
            rs = pst.executeQuery();
            //遍历rs
            /*while(rs.next())&#123; //当你的rs中有多余一条记录时。
               name =  rs.getString(&quot;name&quot;);
            &#125;*/

            if (rs.next()) &#123;
                province = new Province();
                //将查询到的数据写入对象中
                province.setId(rs.getInt(&quot;id&quot;));
                province.setJiancheng(rs.getString(&quot;jiancheng&quot;));
                province.setName(rs.getString(&quot;name&quot;));
                province.setShenghui(rs.getString(&quot;shenghui&quot;));

            &#125;

        &#125; catch (ClassNotFoundException | SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭资源
            try &#123;
                if (rs != null) &#123;
                    rs.close();
                &#125;
                if (pst != null) &#123;
                    pst.close();
                &#125;
                if (conn != null) &#123;
                    conn.close();
                &#125;

            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

        &#125;
        return province;
    &#125;
&#125;
</code></pre>
<p>存储数据的对象</p>
<pre><code class="java">package cn.it.three.entity;

public class Province &#123;
    /**
     * 用以存储查询数据*/

    private Integer id;
    private String name;
    private String jiancheng;
    private String shenghui;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getJiancheng() &#123;
        return jiancheng;
    &#125;

    public void setJiancheng(String jiancheng) &#123;
        this.jiancheng = jiancheng;
    &#125;

    public String getShenghui() &#123;
        return shenghui;
    &#125;

    public void setShenghui(String shenghui) &#123;
        this.shenghui = shenghui;
    &#125;
&#125;
</code></pre>
<p>jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;ajax根据省份id获取名称&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function search() &#123;
            //发起ajax请求，传递参数给服务器， 服务器返回数据
            //1.创建异步对象
            var  xmlHttp  = new XMLHttpRequest();
            //2.绑定事件
            //readyState属性每更新一次，下面方法就执行一次
     //        0：创建异步对象时， new XMLHttpRequest();
     //        1: 初始异步请求对象， xmlHttp.open()
     //        2：发送请求， xmlHttp.send()
     //        3: 从服务器端获取了数据，此时3， 注意3是异步对象内部使用， 获取了原始的数据。
     //        4：异步对象把接收的数据处理完成后。 此时开发人员在4的时候处理数据。
     //    在4的时候，开发人员更新当前页面。
            xmlHttp.onreadystatechange = function () &#123;
                if( xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status== 200)&#123;
                    //alert(xmlHttp.responseText)
                    //更新页面，就是更新dom对象
                    document.getElementById(&quot;proname&quot;).value= xmlHttp.responseText;
                &#125;
            &#125;
            //3.初始异步对象
            //获取proid文本框的值
            var proid = document.getElementById(&quot;proid&quot;).value;
            xmlHttp.open(&quot;get&quot;,&quot;queryProvince?proid=&quot;+proid,true);//以get方式发起请求

            //4.发送请求
            xmlHttp.send();
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;ajax根据省份id获取名称&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;省份编号：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proid&quot;/&gt;
            &lt;input type=&quot;button&quot; value=&quot;搜索&quot; onclick=&quot;search()&quot; /&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;省份名称：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proname&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;a href=&quot;html/main.jsp&quot;&gt;link&lt;/a&gt;
&lt;/html&gt;
</code></pre>
<p>Jquery</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;使用json格式的数据&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(function ()&#123;
            $(&quot;:button&quot;).click(function ()&#123;//为按钮标签绑定监听事件
                var proid =$(&quot;#proid&quot;).val();//获取输入值
                $.ajax(&#123;
                    url:&quot;queryJsonServlet&quot;,
                    data:&#123;&quot;proid&quot;:proid&#125;,
                    dataType:&quot;json&quot;,//期望服务端返回json数据
                    //更新页面显示返回数据
                    success:function (resp)&#123;
                        $(&quot;#proname&quot;).val(resp.name)
                        $(&quot;#projiancheng&quot;).val(resp.jiancheng)
                        $(&quot;#proshenghui&quot;).val(resp.shenghui)
                    &#125;
                &#125;)
            &#125;)
        &#125;)


    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;ajax请求使用json格式的数据&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;省份编号：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proid&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;搜索&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;省份名称：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proname&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;省份简称：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;projiancheng&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;省会名称：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proshenghui&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code>
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Ajax" style=color:#607d8b>
                Ajax
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Ajax-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Cookie-01/">
        <h2>
            Cookie
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JavaWeb">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JavaWeb
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote>
<p>用户访问一个网站时，服务器响应时返回cookie，当用户再次访问此网站时（请求头）会携带cookie，服务器以cookie识别用户</p>
</blockquote>
<p>作用：在不登录的情况下，完成服务器对客户端的身份识别</p>
<p>常用方法：</p>
<p><code>new Cookie(String name, String value) </code>创建Cookie并初始化数据     <code>response.addCookie(Cookie cookie) </code>发送Cookie到客户端<br><code>Cookie[]  request.getCookies() </code>获取Cookie</p>
<p><code>setMaxAge(int seconds)</code>用于指定cookie存活时间，时间到后，cookie文件自动失效</p>
<pre><code>               1. 正数：将Cookie数据写到硬盘的文件中，以秒为单位计时，到期cookie自动失效
               2. 负数：默认值,关闭浏览器就删除cookie
               3. 零：删除cookie信息
</code></pre>
<p>将中文数据存储至cookie事先要进行URL编码操作，在需要的时候进行解码操作</p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code class="java">
/**
是否为首次访问：如是则发出欢迎语句，否则提示上次登录时间*/
@WebServlet(&quot;/CookieTest&quot;)
public class CookieTest extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        response.setContentType(&quot;text/html;charset=utf-8&quot;);//设置响应消息体格式以及编码

        Cookie[] cookies = request.getCookies();//获取Cookie
        boolean flag = false;//是否首次访问的标志，默认为false

        //遍历cookies
        if (cookies !=null &amp;&amp; cookies.length &gt; 0)&#123;
            for (Cookie cookie:cookies) &#123;
                String name = cookie.getName();//获取cookie名称
                System.out.println(&quot;cookie name=&quot;+name);
                //不是第一次访问
                if (&quot;lastTime&quot;.equals(name))&#123;
                    flag = true;//第一次访问后将其设为true
                    Date date = new Date();//获取当前时间
                    //设置日期格式
                    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);
                    String str_date = sdf.format(date);//对日期进行格式化
                    System.out.println(&quot;编码前：&quot;+str_date);
                    //URL编码（对中文进行编码便于存储至cookie）
                    str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);
                    System.out.println(&quot;编码后：&quot;+str_date);
                    cookie.setValue(str_date);//修改cookie的值
                    cookie.setMaxAge(60*60*24*30);//设置cookie有效期一个月
                    response.addCookie(cookie);//发送cookie到客户端

                    //响应操作
                    String value = cookie.getValue();
                    System.out.println(&quot;解码前： &quot;+ value);
                    value = URLDecoder.decode(value,&quot;utf-8&quot;);//解码操作
                    System.out.println(&quot;解码后：&quot; + value);
                    response.getWriter().write(&quot;欢迎回来！您上次访问时间为：&quot; + value);
                    break;
                &#125;
            &#125;
        &#125;
        if (cookies!=null || cookies.length&gt;0 || flag ==false)&#123;
            Date date = new Date();//获取当前时间
            //设置日期格式
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);
            String str_date = sdf.format(date);//对日期进行格式化
            System.out.println(&quot;编码前：&quot;+str_date);
            //URL编码（对中文进行编码便于存储至cookie）
            str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);
            System.out.println(&quot;编码后：&quot;+str_date);
            Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);//创建名为lastTime值为当前时间的cookie
            cookie.setMaxAge(60*60*24*30);//设置cookie有效期一个月
            response.addCookie(cookie);//发送cookie到客户端

            //响应
            response.getWriter().write(&quot;欢迎您首次访问！&quot;);
        &#125;
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<h1 id="共享Cookie"><a href="#共享Cookie" class="headerlink" title="共享Cookie"></a>共享Cookie</h1><p>同一服务器下共享：</p>
<p><code>setPath(String path)</code>设置cookie的获取范围。</p>
<p>默认情况下，设置当前的虚拟目录如果要共享，则可将path设置为”/“</p>
<p>同一域名下共享：</p>
<p><code>setDomain(String path)</code>:如果设置一级域名相同，那么多个服务器之间cookie可以共享</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<p>Session的实现依赖于Cookie</p>
<p><img src="http://img.lbkzw.cn/img/20201012161222.png" alt="image-20201012161222663"></p>
<p>session的特点</p>
<ol>
<li>session用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>session可以存储任意类型，任意大小的数据</li>
</ol>
<p>session与Cookie的区别：</p>
<ol>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全</li>
</ol>
<p>方法：</p>
<p>获取HttpSession对象</p>
<p><code>HttpSession session = request.getSession();</code> </p>
<p>使用HttpSession对象</p>
<p><code>Object getAttribute(String name)  </code></p>
<p><code>void setAttribute(String name, Object value)</code><br><code>void removeAttribute(String name)  </code></p>
<pre><code class="java">//在一次会话的多次请求间共享数据
@WebServlet(&quot;/SessionDemo1&quot;)
public class SessionDemo1 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();//获取Session对象
        session.setAttribute(&quot;msg&quot;,&quot;Hello Session!&quot;);//设置Session
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;


@WebServlet(&quot;/SessionDemo2&quot;)
public class SessionDemo2 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();//获取Session对象
        Object msg =session.getAttribute(&quot;msg&quot;);//获取键为msg的值
        System.out.println(msg);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<p><strong>当客户端关闭后，服务器不关闭，再次获取得的Session与之前的Session不是同一个</strong></p>
<p>如何在关闭客户端或服务端的前提下，保存Session数据呢？</p>
<p>创建Cookie,键为JSESSIONID，并存入Session id。</p>
<pre><code class="java">@WebServlet(&quot;/SessionDemo2&quot;)
public class SessionDemo2 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();//获取Session对象
        
        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,session.getId());
        cookie.setMaxAge(60*60);
        response.addCookie(cookie);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<p><strong>客户端不关闭，服务器关闭后，两次获取的session不是同一个，且数据不丢失。</strong></p>
<p>tomcat自动完成以下工作：</p>
<blockquote>
<p>session的钝化：            </p>
<p>在服务器正常关闭之前，将session对象系列化到硬盘上（保存临时文件至Work目录）</p>
<p>session的活化：</p>
<p>在服务器启动后，将session文件转化为内存中的session对象即可。</p>
<p>在idea里的web项目，在重启Tomcat后会删除保存临时文件的Work目录，再新建Work目录从而无法完成活化。</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Cookie" style=color:#006674>
                Cookie
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#6484be>
                Java
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Session" style=color:#016a99>
                Session
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Cookie-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/JS-01/">
        <h2>
            JS作用域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>JavaScript是编译型语言，不同的是JavaScript的代码编译发生在代码执行前的几微秒内</p>
<h1 id="LHS与RHS"><a href="#LHS与RHS" class="headerlink" title="LHS与RHS"></a>LHS与RHS</h1><p>LHS查找的目的为了赋值</p>
<p>RHS查找的目的是为了引用值</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域查找从词法作用域（即最内部作用域）开始逐层向上查找，直到匹配到或触顶为止</p>
<img src="http://img.lbkzw.cn/img/20200830120120.png" alt="screenshot_2020_08_13T21_09_28+0800" style="zoom:50%;" />

<p>全局变量会自动成为全局对象，因此可通过<code> window.a（a是要访问的变量）</code>访问被同名变量屏蔽的全局变量</p>
<h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>使用欺骗词法则JavaScript引擎无法对作用域栈进行优化</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><pre><code class="js">    /*在函数内动态创建变量b，屏蔽全局变量b*/
        function foo(str,a)&#123;
            eval(str);//动态创建代码
            console.log(a,b);
        &#125;
        var b = 2;
        foo(&quot;var b = 3;&quot;,1);
    /*结果：1,3*/
</code></pre>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><pre><code class="js">/*重复引用对象的多个属性*/
        var obj = &#123;
            a = 1,
            b = 2
        &#125;;
        with(obj)&#123;
            a = 3;
            b = 4;
            c = 5;//对象obj中没有c，返回undefined,并创建一个全局变量c = 5;
        &#125;
</code></pre>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数中的作用域属于局部作用域，函数具有很好的闭包性，隐藏该隐藏的。</p>
<p>JavaScript中多</p>
<h3 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h3><ul>
<li>两种方式</li>
</ul>
<pre><code class="js">/*ONE*/
        (function foo()&#123;
            var a = 2;
            console.log(a);
        &#125;)();
/*TWO*/  
        (function foo()&#123;
            var a = 2;
            console.log(a);
        &#125;());//括号位置不同哦
</code></pre>
<ul>
<li>传入参数</li>
</ul>
<pre><code class="js">       /*传入window对象，引用全局变量*/
        var a = 2;
        (function (global)&#123;//匿名IIFE
            var a = 3;
            console.log(a); 
            console.log(global.a);
        &#125;)(window)
/*结果：3,2*/
</code></pre>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>变量声明、函数声明均会提升到顶部。</p>
<p>let声明的块中的变量声明不会提升，而是保留在原地</p>
<p>函数先于变量提升，函数表达式不会被提升，后面的函数声明覆盖前面的函数声明</p>
<pre><code class="js">        function a()&#123;
            console.log(1);
        &#125;
        a = function a()&#123;//不会被提升
            console.log(2);
        &#125;        
        function a()&#123;
            console.log(3);
        &#125;
        a();
/*结果：3*/
</code></pre>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>调用一个函数只返回其属性数据，而没有返回闭包对象（函数内的函数）的不是真模块</p>
<p>具有函数属性的对象不是真模块</p>
<pre><code class="js">/*一个模块*/
        function CoolModule()&#123;
            var something = &quot;so&quot;;
            var another = [1,2,3];
            function doSomething()&#123;
                console.log(something);
            &#125;
            function doAnother()&#123;
                console.log(another.join(&quot;!&quot;));
            &#125;
            return &#123;
                doSomething:doSomething,
                doAnother:doAnother
            &#125;;
        &#125;
        var foo = CoolModule();
        foo.doAnother();
        foo.doSomething();


/*一个单例模式*/
        var foo = (function CoolModule()&#123;
            var something = &quot;so&quot;;
            var another = [1,2,3];
            function doSomething()&#123;
                console.log(something);
            &#125;
            function doAnother()&#123;
                console.log(another.join(&quot;!&quot;));
            &#125;
            return &#123;
                doSomething:doSomething,
                doAnother:doAnother
            &#125;;
        &#125;)();
        foo.doAnother();
        foo.doSomething();
/*结果：
1！2！3！
so
*/
</code></pre>
<h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><h4 id="未来模块机制（python）"><a href="#未来模块机制（python）" class="headerlink" title="未来模块机制（python）"></a>未来模块机制（python）</h4><pre><code>//a.js,一个单独的模块
function a()&#123;
    ...
&#125;
export a;//将当前模块的（变量、函数）标识符导出为公共API
</code></pre>
<pre><code>//b.js
import a from &quot;a&quot;;//从模块a，导入函数a()
function b()&#123;
    ...
&#125;
export b;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#006674>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/JS-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/JDBC-01/">
        <h2>
            JDBC基本使用
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>前言：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库，是官方（sun公司）定义的一套操作所有关系型数据库的接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<ul>
<li>步骤：<ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar<br> 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下<br> 2.右键–&gt;Add As Library</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行sql语句的对象 Statement</li>
<li>执行sql，接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
</ul>
<h1 id="Statement：执行sql的对象"><a href="#Statement：执行sql的对象" class="headerlink" title="Statement：执行sql的对象"></a>Statement：执行sql的对象</h1><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><blockquote>
<ol>
<li><p>boolean execute(String sql) ：可以执行任意的sql</p>
</li>
<li><p>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句,即增删改查</p>
<blockquote>
<p>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</p>
</blockquote>
</li>
</ol>
</blockquote>
<pre><code class="java">package cn.itcast.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class TestJDBC1&#123;
    public static void main(String[] args) &#123;
        Statement stmt = null;
        Connection conn = null;
        try &#123;
            //注册驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //定义sql语句
            String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;
            //获取Connection对象
            conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;,&quot;root&quot;,&quot;root&quot;);
            //获取执行sql的对象Statement
            stmt = conn.createStatement();
            //执行sql
            int count = stmt.executeUpdate(sql);//此方法将返回执行后的影响行数数值,此方法用于执行增、删、改、查的sql语句
            // int count = stmt.execute(sql) ：可以执行任意的sql
            System.out.println(count);
            if(count &gt; 0)&#123;
                System.out.println(&quot;添加成功！&quot;);
            &#125;else&#123;
                System.out.println(&quot;添加失败！&quot;);
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;finally &#123;
            //释放资源
            if (stmt != null)&#123;
                try &#123;
                    stmt.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;
            &#125;
            if (conn != null)&#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;
            &#125;
        &#125;

    &#125;
&#125;
</code></pre>
<h2 id="封装数据库表到对象"><a href="#封装数据库表到对象" class="headerlink" title="封装数据库表到对象"></a>封装数据库表到对象</h2><blockquote>
<p>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</p>
<p>（可用来将表数据封装为对象并装载入集合）</p>
</blockquote>
<pre><code class="java">package cn.itcast.jdbc;

import java.sql.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class TestJDBC3 &#123;

    public List&lt;Emp&gt; findAll()&#123;
        Statement stmt = null;
        Connection conn = null;
        ResultSet rs = null;
        List&lt;Emp&gt;list = null;
        try &#123;
            //注册驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //定义sql语句
            String sql = &quot;select * from emp&quot;;
            //获取Connection对象
            conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;,&quot;root&quot;,&quot;root&quot;);
            //获取执行sql的对象Statement
            stmt = conn.createStatement();
            //执行sql
            rs = stmt.executeQuery(sql);
            Emp emp = null;
            list = new ArrayList&lt;Emp&gt;();

            while (rs.next())&#123;
//        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
//                        * getXxx(参数):获取数据
//                        * Xxx：代表数据类型   如： int getInt() ,    String getString()
//                        * 参数：
//                1. int：代表列的编号,从1开始   如： getString(1)
//                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)

                //获取数据
                int id = rs.getInt(&quot;id&quot;);
                String ename = rs.getString(&quot;ename&quot;);
                int job_id = rs.getInt(&quot;job_id&quot;);
                int mgr = rs.getInt(&quot;mgr&quot;);
                Date joindate = rs.getDate(&quot;joindate&quot;);
                double salary = rs.getDouble(&quot;salary&quot;);
                double bonus = rs.getDouble(&quot;bonus&quot;);
                int dept_id = rs.getInt(&quot;dept_id&quot;);
                //创建Emp对象并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载进集合
                list.add(emp);
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;finally &#123;
            //释放资源
            if (rs != null)&#123;
                try &#123;
                    rs.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (stmt != null)&#123;
                try &#123;
                    stmt.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        return list;
    &#125;
    public static void main(String[] args) &#123;
       var a = new TestJDBC3();
        System.out.println(a.findAll());

    &#125;
&#125;
</code></pre>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol>
<li>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li>
<li>操作：<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li>使用Connection对象来管理事务<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit() <ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback() <ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="java">        public class JDBCDemo10 &#123;

        public static void main(String[] args) &#123;
            Connection conn = null;
            PreparedStatement pstmt1 = null;
            PreparedStatement pstmt2 = null;
    
            try &#123;
                //1.获取连接
                conn = JDBCUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);
    
                //2.定义sql
                //2.1 张三 - 500
                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;
                //2.2 李四 + 500
                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;
                //3.获取执行sql对象
                pstmt1 = conn.prepareStatement(sql1);
                pstmt2 = conn.prepareStatement(sql2);
                //4. 设置参数
                pstmt1.setDouble(1,500);
                pstmt1.setInt(2,1);
    
                pstmt2.setDouble(1,500);
                pstmt2.setInt(2,2);
                //5.执行sql
                pstmt1.executeUpdate();
                // 手动制造异常
                int i = 3/0;
    
                pstmt2.executeUpdate();
                //提交事务
                conn.commit();
            &#125; catch (Exception e) &#123;
                //事务回滚
                try &#123;
                    if(conn != null) &#123;
                        conn.rollback();
                    &#125;
                &#125; catch (SQLException e1) &#123;
                    e1.printStackTrace();
                &#125;
                e.printStackTrace();
            &#125;finally &#123;
                JDBCUtils.close(pstmt1,conn);
                JDBCUtils.close(pstmt2,null);
            &#125;
        &#125;
    
    &#125;
</code></pre>
<p>​        </p>
<h1 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h1><p>通常我们获取一个数据库连接对象，在使用后将其释放。这需要繁琐的申请与释放操作，而我们有更好的方案：即从数据库连接池处获取对象，在不使用的时候再将其归还到连接池中。</p>
<p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
<p>操作步骤：</p>
<ol>
<li>导入jar包 </li>
<li>定义配置文件：以properties形式，可叫任意名称，可放在任意目录下。</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
<h2 id="导入并使用jar包"><a href="#导入并使用jar包" class="headerlink" title="导入并使用jar包"></a>导入并使用jar包</h2><blockquote>
<ol>
<li><img src="http://img.lbkzw.cn/img/20200918202606.png" alt="image-20200918202606795" style="zoom: 50%;" />
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><img src="http://img.lbkzw.cn/img/20200918202636.png" alt="image-20200918202636057" style="zoom:50%;" />
</li>
</ol>
</blockquote>
<h2 id="Properties文件配置"><a href="#Properties文件配置" class="headerlink" title="Properties文件配置"></a>Properties文件配置</h2><pre><code class="java">driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/db4
username=root
password=root
initialSize=1//初始数据库连接数
maxActive=10//最大数据库连接数
maxWait=3000
</code></pre>
<h2 id="数据库连接池的工具类"><a href="#数据库连接池的工具类" class="headerlink" title="数据库连接池的工具类"></a>数据库连接池的工具类</h2><pre><code class="java">package cn.itcast.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * Druid连接池的工具类
 */
public class JDBCUtils &#123;

    //1.定义成员变量 DataSource
    private static DataSource ds ;

    static&#123;
        try &#123;
            //1.加载配置文件
            Properties pro = new Properties();
            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
            //2.获取DataSource
            ds = DruidDataSourceFactory.createDataSource(pro);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     * 获取连接
     */
    public static Connection getConnection() throws SQLException &#123;
        return ds.getConnection();
    &#125;

    /**
     * 释放资源
     */
    public static void close(Statement stmt,Connection conn)&#123;
       /* if(stmt != null)&#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        if(conn != null)&#123;
            try &#123;
                conn.close();//归还连接
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;*/

       close(null,stmt,conn);
    &#125;


    public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;


        if(rs != null)&#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;


        if(stmt != null)&#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        if(conn != null)&#123;
            try &#123;
                conn.close();//归还连接
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    /**
     * 获取连接池方法
     */

    public static DataSource getDataSource()&#123;
        return  ds;
    &#125;

&#125;
</code></pre>
<p>使用连接池工具类</p>
<pre><code class="java">package cn.itcast.datasource.druid;

import cn.itcast.utils.JDBCUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * 使用新的工具类
 */
public class DruidDemo2 &#123;

    public static void main(String[] args) &#123;
        /*
         * 完成添加操作：给account表添加一条记录
         */
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123;
            //1.获取连接
            conn = JDBCUtils.getConnection();
            //2.定义sql
            String sql = &quot;insert into account values(null,?,?)&quot;;
            //3.获取pstmt对象
            pstmt = conn.prepareStatement(sql);
            //4.给？赋值
            pstmt.setString(1,&quot;王五&quot;);
            pstmt.setDouble(2,3000);
            //5.执行sql
            int count = pstmt.executeUpdate();
            System.out.println(count);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //6. 释放资源
            JDBCUtils.close(pstmt,conn);
        &#125;
    &#125;

&#125;
</code></pre>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><blockquote>
<p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>导入jar包(注意版本要匹配，如mysql版本，数据库驱动版本等)</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ul>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ul>
</li>
<li><p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li>update():执行DML语句。增、删、改语句</li>
<li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul>
<li>注意：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li>queryForList():查询结果将结果集封装为list集合<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li>query():查询结果，将结果封装为JavaBean对象<ul>
<li>query的参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject：查询结果，将结果封装为对象<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="java">import cn.itcast.domain.Emp;
            import cn.itcast.utils.JDBCUtils;
            import org.junit.Test;
            import org.springframework.jdbc.core.BeanPropertyRowMapper;
            import org.springframework.jdbc.core.JdbcTemplate;
            import org.springframework.jdbc.core.RowMapper;
            
            import java.sql.Date;
            import java.sql.ResultSet;
            import java.sql.SQLException;
            import java.util.List;
            import java.util.Map;
            
            public class JdbcTemplateDemo2 &#123;
            
                //Junit单元测试，可以让方法独立执行
                                //1. 获取JDBCTemplate对象
                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
                /**
                 * 1. 修改1号数据的 salary 为 10000
                 */
                @Test
                public void test1()&#123;
            
                    //2. 定义sql
                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;
                    //3. 执行sql
                    int count = template.update(sql);
                    System.out.println(count);
                &#125;
            
                /**
                 * 2. 添加一条记录
                 */
                @Test
                public void test2()&#123;
                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;
                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);
                    System.out.println(count);
            
                &#125;
            
                /**
                 * 3.删除刚才添加的记录
                 */
                @Test
                public void test3()&#123;
                    String sql = &quot;delete from emp where id = ?&quot;;
                    int count = template.update(sql, 1015);
                    System.out.println(count);
                &#125;
            
                /**
                 * 4.查询id为1001的记录，将其封装为Map集合
                 * 注意：这个方法查询的结果集长度只能是1
                 */
                @Test
                public void test4()&#123;
                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;
                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);
                    System.out.println(map);
                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;
            
                &#125;
            
                /**
                 * 5. 查询所有记录，将其封装为List
                 */
                @Test
                public void test5()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);
            
                    for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;
                        System.out.println(stringObjectMap);
                    &#125;
                &#125;
            
                /**
                 * 6. 查询所有记录，将其封装为Emp对象的List集合
                 */
            
                @Test
                public void test6()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;
            
                        @Override
                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;
                            Emp emp = new Emp();
                            int id = rs.getInt(&quot;id&quot;);
                            String ename = rs.getString(&quot;ename&quot;);
                            int job_id = rs.getInt(&quot;job_id&quot;);
                            int mgr = rs.getInt(&quot;mgr&quot;);
                            Date joindate = rs.getDate(&quot;joindate&quot;);
                            double salary = rs.getDouble(&quot;salary&quot;);
                            double bonus = rs.getDouble(&quot;bonus&quot;);
                            int dept_id = rs.getInt(&quot;dept_id&quot;);
            
                            emp.setId(id);
                            emp.setEname(ename);
                            emp.setJob_id(job_id);
                            emp.setMgr(mgr);
                            emp.setJoindate(joindate);
                            emp.setSalary(salary);
                            emp.setBonus(bonus);
                            emp.setDept_id(dept_id);
            
                            return emp;
                        &#125;
                    &#125;);
                                        for (Emp emp : list) &#123;
                        System.out.println(emp);
                    &#125;
                &#125;
            
                /**
                 * 6. 查询所有记录，将其封装为Emp对象的List集合
                 */
            
                @Test
                public void test6_2()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));
                    for (Emp emp : list) &#123;
                        System.out.println(emp);
                    &#125;
                &#125;
            
                /**
                 * 7. 查询总记录数
                 */
            
                @Test
                public void test7()&#123;
                    String sql = &quot;select count(id) from emp&quot;;
                    Long total = template.queryForObject(sql, Long.class);
                    System.out.println(total);
                &#125;
            
            &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#006674>
                Java
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/JDBC" style=color:#6484be>
                JDBC
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/JDBC-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-01/">
        <h2>
            接口
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p> 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p>
</blockquote>
<p>接口中可添加静态方法与默认方法；</p>
<p>一个类实现一个接口的同时必须实现该接口的所有方法（可以不用实现默认方法即关键词为为 default的方法）；</p>
<p><strong>extends</strong> 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p>
<h1 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h1><p><img src="http://img.lbkzw.cn/img/20200821084956.jpeg"></p>
<blockquote>
<p>把方法抽象封装到接口或抽象类中，在别的类中对其进行实现即，变得是内容，而其框架则始终如一。</p>
<p>就像我与大厨炒西红柿：大家都是加油、加鸡蛋、加西红柿。只是做出来时味道不同罢了。</p>
</blockquote>
<h1 id="接口与抽象类（选择）"><a href="#接口与抽象类（选择）" class="headerlink" title="接口与抽象类（选择）"></a>接口与抽象类（选择）</h1><table>
<thead>
<tr>
<th>特性</th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>组合</td>
<td>新类可以组合多个接口</td>
<td>只能继承单一抽象类</td>
</tr>
<tr>
<td>状态</td>
<td>不能包含属性（除了静态属性，不支持对象状态）</td>
<td>可以包含属性，非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td>默认方法 和 抽象方法</td>
<td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td>
<td>必须在子类中实现抽象方法</td>
</tr>
<tr>
<td>构造器</td>
<td>没有构造器</td>
<td>可以有构造器</td>
</tr>
<tr>
<td>可见性</td>
<td>隐式 <strong>public</strong></td>
<td>可以是 <strong>protected</strong> 或友元</td>
</tr>
</tbody></table>
<h1 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h1><ul>
<li>创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。</li>
</ul>
<pre><code class="java">import java.util.*;

class Processor &#123;
    /*父类*/
    public String name() &#123;
        return getClass().getSimpleName();
    &#125;
    
    public Object process(Object input) &#123;
        return input;
    &#125;
&#125;

/*子类开始，将所有传入类设置为同一个类的子类*/
class Upcase extends Processor &#123;
    // 返回协变类型
    @Override 
    public String process(Object input) &#123;
        return ((String) input).toUpperCase();
    &#125;
&#125;

class Downcase extends Processor &#123;
    @Override
    public String process(Object input) &#123;
        return ((String) input).toLowerCase();
    &#125;
&#125;

class Splitter extends Processor &#123;
    @Override
    public String process(Object input) &#123;
        // split() divides a String into pieces:
        return Arrays.toString(((String) input).split(&quot; &quot;));
    &#125;
&#125;

/*策略开始*/
public class Applicator &#123;
    public static void apply(Processor p, Object s) &#123;
        //(Processor p。已知：所有传入类设置为同一个类的子类，故其父类的变量可以作为引用
        System.out.println(&quot;Using Processor &quot; + p.name());//获取其类名
        System.out.println(p.process(s));//根据其类名调用其覆盖的相应的process方法
    &#125;
    
    public static void main(String[] args) &#123;
        String s = &quot;We are such stuff as dreams are made on&quot;;
        //进入策略，以下3类均为Processor子类，故可用Processor p分别引用以下3个不同类型的对象
        apply(new Upcase(), s);
        apply(new Downcase(), s);
        apply(new Splitter(), s);
    &#125;
&#125;
</code></pre>
<h1 id="常量字段"><a href="#常量字段" class="headerlink" title="常量字段"></a>常量字段</h1><blockquote>
<p>接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong></p>
</blockquote>
<pre><code class="java">public interface Months &#123;
    int 
    JANUARY = 1, FEBRUARY = 2, MARCH = 3,
    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,
    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
    NOVEMBER = 11, DECEMBER = 12;
&#125;
</code></pre>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><blockquote>
<p>所有类都必须是公共可用的，唯独内部类不同。——一枝独秀</p>
</blockquote>
<ul>
<li>内部类的变量必须是最终变量。传入参数默认为fianl</li>
<li> 创建内部类对象：在拥有外部类对象之前不可创建内部类对象，且必须使用外部类的对象来创建其内部类对象。</li>
<li>典型手法：外部类中的一个方法返回指向内部类的引用。</li>
<li>可以让内部类实现一个接口，再借接口变量对创建的内部类对象进行引用。</li>
<li>当内部类在方法内部时除该方法外，所有类与方法不得访问。</li>
<li>类只能继承一个父类，实现多个内部类继承类，则等同于实现类的多继承。</li>
</ul>
<h2 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h2><blockquote>
<p>利用内部类实现迭代器功能，对其外类元素（方法、字段）进行访问。</p>
</blockquote>
<pre><code class="java">package com.test.day2;

public class Sequence &#123;
    private Object[] items;
    private int next = 0;
    public Sequence(int size)&#123;
        items = new Object[size];
    &#125;
    public void add(Object x)&#123;
        if(next &lt; items.length)
            items[next++] = x;
    &#125;
    private class SequenceSelector implements Selector&#123;
        private  int i = 0;
        @Override
        public boolean end() &#123;return  i == items.length;&#125;
        @Override
        public Object current() &#123;return  items[i];&#125;
        @Override
        public void  next() &#123;if (i &lt; items.length) i++;&#125;//定义一个迭代器，if语句相当于hasNext
    &#125;
    public Selector selector()&#123;
        /*返回指向内部类的引用。*/
        return new SequenceSelector();
        //当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。
        // 然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。
    &#125;

    public static void main(String[] args) &#123;
        Sequence sequence = new Sequence(10);
        for (int i = 0; i &lt; 10; i++)
            sequence.add(Integer.toString(i));//Integer.toString()表示先讲int转换bai成Integer型，然后再将Integer转换成String型。
        Selector selector = sequence.selector();//返回、创建、引用内部类对象操作开始（此处使用接口变量，对内部类对象进行引用）
        //Selector selector = sequence.new SequenceSelector();//外部类方法返回内部类引用、创建内部类对象
        //var selector = sequence.new SequenceSelector();//简写引用、创建内部类对象
       // Sequence.SequenceSelector selector = sequence.new SequenceSelector();//使用外部类.内部类引用、创建内部类对象
        while (!selector.end())&#123;
            System.out.println(selector.current() + &quot; &quot;);
            selector.next();
        &#125;
    &#125;
&#125;
</code></pre>
<p>这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p>
<h2 id="this、new"><a href="#this、new" class="headerlink" title="this、new"></a>this、new</h2><pre><code class="java">public class DotThis &#123;
    void f() &#123; System.out.println(&quot;DotThis.f()&quot;); &#125;
  
    public class Inner &#123;
        public DotThis outer() &#123;
            return DotThis.this;//创建对外部类对象的引用
        &#125;
    &#125;
  
    public Inner inner() &#123; return new Inner(); &#125;
  
    public static void main(String[] args) &#123;
        DotThis dt = new DotThis();//在拥有外部类对象之前不可创建内部类对象。
        DotThis.Inner dti = dt.inner();//必须使用外部类的对象来创建其内部类对象
        dti.outer().f();
    &#125;
&#125;


public class DotNew &#123;
    public class Inner &#123;&#125;
    public static void main(String[] args) &#123;
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象
       // var dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象
    &#125;
&#125;
</code></pre>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul>
<li>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <strong>final</strong> 的</li>
</ul>
<blockquote>
<p>匿名内部类的初始化（借助抽象类）</p>
</blockquote>
<pre><code class="java">package com.test.day2;

abstract class Base &#123;//抽象类的构造器
    Base(int i) &#123;
        System.out.println(&quot;Base constructor, i = &quot; + i);
    &#125;
    public abstract void f();
&#125;
public class AnonymousConstructor &#123;
    public static Base getBase(int i) &#123;
        return new Base(i) &#123;//利用抽象类构造器进行字段初始化。
            &#123; System.out.println(
                    &quot;Inside instance initializer&quot;); &#125;
            @Override
            public void f() &#123;
                System.out.println(&quot;In anonymous f()&quot;);
            &#125;
        &#125;;
    &#125;
    public static void main(String[] args) &#123;
        Base base = getBase(47);
        base.f();
    &#125;
&#125;
</code></pre>
<h2 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h2><blockquote>
<p>普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p>
</blockquote>
<ul>
<li><p>要创建嵌套类的对象，并不需要先创建其外部类的对象，即直接创建并引用即可。</p>
</li>
<li><p>不能从嵌套类的对象中访问非静态的外围类对象。</p>
</li>
</ul>
<pre><code class="java">public class Parcel11 &#123;
    private static class ParcelContents implements Contents &#123;
        private int i = 11;
        @Override
        public int value() &#123; return i; &#125;
    &#125;
    protected static final class ParcelDestination
            implements Destination &#123;
        private String label;
        private ParcelDestination(String whereTo) &#123;
            label = whereTo;
        &#125;
        @Override
        public String readLabel() &#123; return label; &#125;
        // Nested classes can contain other static elements:
        public static void f() &#123;&#125;
        static int x = 10;
        static class AnotherLevel &#123;
            public static void f() &#123;&#125;
            static int x = 10;
        &#125;
    &#125;
    public static Destination destination(String s) &#123;
        return new ParcelDestination(s);
    &#125;
    public static Contents contents() &#123;
        return new ParcelContents();
    &#125;
    public static void main(String[] args) &#123;
        Contents c = contents();
        //并没有创建外部类的对象，再用外部类对象创建内部类。
        //var i = new Parcel11()
        //var c = i.contents()
        Destination d = destination(&quot;Tasmania&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">/**一个接口内部的类（接口内方法、字段默认为final static）*/
public interface ClassInInterface &#123;
    void howdy();
    class Test implements ClassInInterface &#123;
        @Override
        public void howdy() &#123;
            System.out.println(&quot;Howdy!&quot;);
        &#125;
        public static void main(String[] args) &#123;
            new Test().howdy();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><blockquote>
<p>内部类无法被覆盖，但可通过继承覆盖其方法</p>
</blockquote>
<pre><code class="java">class WithInner &#123;
    class Inner &#123;
        public Yolk() &#123;
            System.out.println(&quot;Egg.Yolk()&quot;);
        &#125;
    &#125;
&#125;
public class InheritInner extends WithInner.Inner &#123;//继承须以（外部类.内部）类形式。
    InheritInner(WithInner wi) &#123;
        wi.super();
        @Override
        public Yolk() &#123;
            System.out.println(&quot;BigEgg2.Yolk()&quot;);
    &#125;
    public static void main(String[] args) &#123;
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    &#125;
&#125;
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code class="java">package cn.day.a5;

// files/PathInfo.java
import java.nio.file.*;
import java.net.URI;
import java.io.File;
import java.io.IOException;

public class PathInfo &#123;
    static void show(String id, Object p) &#123;
        System.out.println(id + &quot;: &quot; + p);
    &#125;

    static void info(Path p) &#123;
        show(&quot;toString&quot;, p);
        show(&quot;Exists&quot;, Files.exists(p));//测试文件是否存在
        show(&quot;RegularFile&quot;, Files.isRegularFile(p));
        show(&quot;Directory&quot;, Files.isDirectory(p));//测试文件是否是一个目录。
        show(&quot;Absolute&quot;, p.isAbsolute());//判断此路径是否为绝对路径
        show(&quot;FileName&quot;, p.getFileName());//返回文件名
        show(&quot;Parent&quot;, p.getParent());//返回此文件的父路径，无返回null
        show(&quot;Root&quot;, p.getRoot());//返回此文件的根路径，无返回null
        System.out.println(&quot;******************&quot;);
    &#125;
    public static void main(String[] args) &#123;
        System.out.println(System.getProperty(&quot;os.name&quot;));
        info(Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;));//转化路径（此方法将来可能被弃用）
        Path p = Paths.get(&quot;PathInfo.java&quot;);
        info(p);
        Path ap = p.toAbsolutePath();//获取这个文件的绝对路径
        info(ap);
        info(ap.getParent());
        try &#123;/*传入p引用 文件的父路径，调用info进行处理*/
            info(p.toRealPath());
        &#125; catch(IOException e) &#123;
            System.out.println(e);
        &#125;
        URI u = p.toUri();//返回一个URI来表示该路径
        System.out.println(&quot;URI: &quot; + u);
        Path puri = Paths.get(u);//给定的URI转换为Path对象。
        System.out.println(Files.exists(puri));
        File f = ap.toFile();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#016a99>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-02/">
        <h2>
            集合
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。</p>
<p>基本的集合： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> </p>
</blockquote>
<ul>
<li>集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li>
<li><strong>Set</strong> （元组）不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
<li><strong>Map</strong> （字典）是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><pre><code class="java">import java.util.*;

class Apple &#123;
  private static long counter;
  private final long id = counter++;
  public long id() &#123; return id; &#125;
&#125;

class Orange &#123;&#125;

public class ApplesAndOrangesWithoutGenerics &#123;
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void main(String[] args) &#123;
    ArrayList apples = new ArrayList();
    for(int i = 0; i &lt; 3; i++)
      apples.add(new Apple());
    /*ArrayList 保存的是 Object ，所以不仅可以通过 ArrayList 的 add() 方法将 Apple 对象放入这个集合，而且可以放入 Orange 对象。*/
    apples.add(new Orange());
    for(Object apple : apples) &#123;
      ((Apple) apple).id();
        /*当使用 ArrayList 的 get() 方法来取出你认为是 Apple 的对象时，得到的只是 Object 引用，必须将其转型为 Apple。然后需要将整个表达式用括号括起来，以便在调用 Apple 的 id() 方法之前，强制执行转型。*/
    &#125;
  &#125;
&#125;
/**通过泛型,限定&lt;Apple&gt;类型防止其它类型对象添加到容器中*/
import java.util.*;

class GrannySmith extends Apple &#123;&#125;
public class ApplesAndOrangesWithGenerics &#123;
  public static void main(String[] args) &#123;
    ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; 3; i++)
      apples.add(new GrannySmith());//向上转型也可以添加到容器哦
      apples.add(new Apple());
    // Compile-time error:
    // apples.add(new Orange());
    for(Apple apple : apples) &#123;
      System.out.println(apple.id());
        //使用泛型，容器知道它被限定为什么类型，因此当调用 get() 时，它会替你执行转型，因此从泛型容器中获取元素不需要强制类型转换。
</code></pre>
<h2 id="添加元数组"><a href="#添加元数组" class="headerlink" title="添加元数组"></a>添加元数组</h2><ul>
<li><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。</li>
<li><code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中</li>
</ul>
<pre><code class="java">package com.test.day3;

import java.util.*;

public class AddingGroups &#123;
    public static void main(String[] args) &#123;
        Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));
        Integer[] moreInts = &#123;6,7,8,9,10&#125;;
        collection.addAll(Arrays.asList(moreInts));//Collection.addAll() 方法只能接受另一个 Collection 作为参数
        /*Collection 可以接受另一个 Collection进行初始化，所以使用 Arrays.asList() 可为这个构造器产生输入。
        Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，再调用 Collections.addAll()添加元素 */
        Collections.addAll(collection,11,12,13,14,15);
        Collections.addAll(collection,moreInts);
         /*使用 Arrays.asList() 的输出作为一个 List ，无法调整大小*/
        List&lt;Integer&gt; list = Arrays.&lt;Integer&gt;asList(16,17,18,19,20);
        //告诉编译器 Arrays.asList() 生成的结果 List 类型的实际目标类型是什么。这称为显式类型参数说明
       
        list.set(1,99);

    &#125;
&#125;
</code></pre>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接</li>
<li><strong>Collection</strong> 类型在每个槽中只能保存一个元素。 <strong>Set</strong> 中元素不重复； <strong>Queue</strong> ，只在一端插入对象，并从另一端移除对象； <strong>Map</strong> 在每个槽中存放了两个元素，即<em>键</em>和与之关联的<em>值</em>。</li>
</ul>
<pre><code class="java">import java.util.*;

public class PrintingCollections &#123;
  static Collection
  fill(Collection&lt;String&gt; collection) &#123;
    collection.add(&quot;rat&quot;);
    collection.add(&quot;cat&quot;);
    collection.add(&quot;dog&quot;);
    collection.add(&quot;dog&quot;);
    return collection;
  &#125;
  static Map fill(Map&lt;String, String&gt; map) &#123;
    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);
    map.put(&quot;cat&quot;, &quot;Rags&quot;);
    map.put(&quot;dog&quot;, &quot;Bosco&quot;);
    map.put(&quot;dog&quot;, &quot;Spot&quot;);
    return map;
  &#125;
  public static void main(String[] args) &#123;
    System.out.println(fill(new ArrayList&lt;&gt;()));
      //ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。
    System.out.println(fill(new LinkedList&lt;&gt;()));
      //LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。
      
    System.out.println(fill(new HashSet&lt;&gt;()));
    System.out.println(fill(new TreeSet&lt;&gt;()));
      //如果存储顺序很重要，则可以使用 TreeSet ，它将按比较结果的升序保存对象
    System.out.println(fill(new LinkedHashSet&lt;&gt;()));
      //LinkedHashSet ，它按照被添加的先后顺序保存对象。
      
    System.out.println(fill(new HashMap&lt;&gt;()));
      // 键和值保存在 HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非常快速的算法来控制顺序。
    System.out.println(fill(new TreeMap&lt;&gt;()));
      // TreeMap 通过比较结果的升序来保存键
    System.out.println(fill(new LinkedHashMap&lt;&gt;()));
      //LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。
  &#125;
&#125;
/* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[rat, cat, dog]
[cat, dog, rat]
[rat, cat, dog]
&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;
&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;
&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;
*/
</code></pre>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>统一集合的移动、删除</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p> <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，设计的很糟糕：如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类。</p>
<p><strong>Java 6 添加了 **ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法:</p>
<pre><code class="java">package com.test.day5;

import java.util.ArrayDeque;
import java.util.Deque;

public class Stack&lt;T&gt; &#123;

    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();
    public void push(T v)&#123;storage.push(v);&#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。
    public T peek() &#123;return storage.peek();&#125;
    public T pop() &#123;return storage.pop();&#125;
    public boolean isEmpty() &#123;return storage.isEmpty();&#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法
    @Override
    public String toString()&#123;
        return storage.toString();
    &#125;

&#125;
</code></pre>
<p>onjava8中利用泛型实现的栈：</p>
<pre><code class="java">package com.test.day5;

import java.util.ArrayDeque;
import java.util.Deque;

public class Stack&lt;T&gt; &#123;

    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();
    public void push(T v)&#123;storage.push(v);&#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。
    public T peek() &#123;return storage.peek();&#125;
    public T pop() &#123;return storage.pop();&#125;
    public boolean isEmpty() &#123;return storage.isEmpty();&#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法
    @Override
    public String toString()&#123;
        return storage.toString();
    &#125;

&#125;
//测试：
public class StackTest2 &#123;
    public static void main(String[] args) &#123;
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();//创建此对象的同时，Stack类也将创建ArrayDeque对象
        for (String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))
            stack.push(s);
        while (!stack.isEmpty())
            System.out.println(stack.pop() + &quot; &quot;);
    &#125;
&#125;
</code></pre>
<h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><ul>
<li><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。  </p>
</li>
<li><p><strong>Set</strong> 最常见的用途是测试归属性。</p>
<p>**迭代器与集合 **</p>
<pre><code class="java">public class InterfaceVsIterator &#123;
  public static void display(Iterator&lt;Pet&gt; it) &#123;
    while(it.hasNext()) &#123;
      Pet p = it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);//返回越过的值
    &#125;
    System.out.println();
  &#125;
  public static void display(Collection&lt;Pet&gt; pets) &#123;
    for(Pet p : pets)
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    System.out.println();
  &#125;
    /*两个版本的 display() 方法都可以使用 Map 或 Collection 的子类型来工作。 而且Collection 接口和 Iterator 都将 display() 方法与低层集合的特定实现解耦。
     Collection 要更方便一点，因为它是 Iterable 类型，因此在 display(Collection) 的实现中可以使用 for-in 构造，这使得代码更加清晰*/
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; petList = Pets.list(8);
    Set&lt;Pet&gt; petSet = new HashSet&lt;&gt;(petList);
    Map&lt;String, Pet&gt; petMap = new LinkedHashMap&lt;&gt;();
    String[] names = (&quot;Ralph, Eric, Robin, Lacey, &quot; +
      &quot;Britney, Sam, Spot, Fluffy&quot;).split(&quot;, &quot;);
    for(int i = 0; i &lt; names.length; i++)
      petMap.put(names[i], petList.get(i));
    display(petList);
    display(petSet);
    display(petList.iterator());
    display(petSet.iterator());
    System.out.println(petMap);
    System.out.println(petMap.keySet());
    display(petMap.values());
    display(petMap.values().iterator());
  &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><code>offer()</code>在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。</li>
<li><code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 </li>
<li><code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</li>
<li>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象</li>
</ul>
<pre><code class="java">package com.test.day4;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

public class QueueDemo &#123;
    public static void printQ(Queue queue)&#123;
        /*删除队列中所有元素*/
        while (queue.peek()!=null)//peek()查询队列第一个元素
            System.out.println(queue.remove()+&quot;&quot;);
        System.out.println();
    &#125;

    public static void main(String[] args) &#123;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        Random rand = new Random(47);//用来生成随机数
        for (int i = 0; i &lt; 10; i++)
            queue.offer(rand.nextInt(i+10));//向队列添加元素
        printQ(queue);
        Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();
        for (char c: &quot;Brontosaurus&quot;.toCharArray())//将字符串分为单个字符加入队列中
            qc.offer(c);
        printQ(qc);

    &#125;
</code></pre>
<h3 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h3><ul>
<li>可以通过提供Comparator 来修改队列元素顺序。 </li>
<li><strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素</li>
<li><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</li>
</ul>
<pre><code class="java">import java.util.*;
/*int string 均有默认的大小顺序*/
public class PriorityQueueDemo &#123;
  public static void main(String[] args) &#123;
    PriorityQueue&lt;Integer&gt; priorityQueue =
      new PriorityQueue&lt;&gt;();
    Random rand = new Random();
    for(int i = 0; i &lt; 10; i++)
      priorityQueue.offer(rand.nextInt(i + 10));//将指定的元素插入此优先级队列。
    QueueDemo.printQ(priorityQueue);//删除并打印队列所有元素

    List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20,
      18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);
    priorityQueue = new PriorityQueue&lt;&gt;(ints);
    QueueDemo.printQ(priorityQueue);
    priorityQueue = new PriorityQueue&lt;&gt;(
        ints.size(), Collections.reverseOrder());//反序排列
    priorityQueue.addAll(ints);
    QueueDemo.printQ(priorityQueue);

    String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;
    List&lt;String&gt; strings =
      Arrays.asList(fact.split(&quot;&quot;));//将这个字符串分解为字母（依据空格）填入列表中
    PriorityQueue&lt;String&gt; stringPQ =
      new PriorityQueue&lt;&gt;(strings);
    QueueDemo.printQ(stringPQ);
    stringPQ = new PriorityQueue&lt;&gt;(
      strings.size(), Collections.reverseOrder());//按原stringPQ大小，创建一个新的队列，反并序排列
    stringPQ.addAll(strings);//将strings中的所有元素添加进队列
    QueueDemo.printQ(stringPQ);

    Set&lt;Character&gt; charSet = new HashSet&lt;&gt;();
    for(char c : fact.toCharArray())//toCharArray分割字符。
      charSet.add(c); 
    PriorityQueue&lt;Character&gt; characterPQ =
      new PriorityQueue&lt;&gt;(charSet);//创建队列对象并将集合的元素“安排”到队列中
    QueueDemo.printQ(characterPQ);
  &#125;
&#125;
/* Output:
0 1 1 1 1 1 3 5 8 14
1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25
25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1
      A A B C C C D D E E E F H H I I L N N O O O O S S
S T T U U U W
W U U U T T S S S O O O O N N L I I H H F E E E D D C C
C B A A
  A B C D E F H I L N O S T U W
*/
</code></pre>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code class="java">package com.test.day5;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class Statistics &#123;
    public static void main(String[] args) &#123;
        Random rand = new Random(47);
        Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();//创建键值均为int类型的字典对象
        for (int i = 0; i &lt; 1000; i++)&#123;
            int r = rand.nextInt(20);
            Integer freq = m.get(r);//查询有无值r，无则返回null
            m.put(r, freq == null ? 1: freq + 1 );//如字典中有这个值，则为其加一
        &#125;
        System.out.println(m);
    &#125;
&#125;

</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#016a99>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-02/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-03/">
        <h2>
            函数式编程
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>任何 Lambda 表达式的基本语法是：</p>
<ol>
<li>参数。</li>
<li>接着 <code>-&gt;</code>，可视为“产出”。</li>
<li><code>-&gt;</code> 之后的内容都是方法体。</li>
</ol>
</blockquote>
<p>当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例;</p>
<p> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见;</p>
<p>如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表;</p>
<p>对于多个参数，将参数列表放在括号 <code>()</code> 中;</p>
<p>表达式的结果自动成为<strong>Lambda 表达式</strong>的返回值，在此处使用 <strong>return</strong> 关键字是非法的。</p>
<p><strong>递归</strong>方法必须是实例变量或静态变量，否则会出现编译时错误</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用组成：类名或对象名 <code>::</code> 方法名</p>
<pre><code class="java">package com.test.day6;

// functional/MethodReferences.java

import java.util.*;

interface Callable &#123; // [1]
    void call(String s);
&#125;

class Describe &#123;
    void show(String msg) &#123; // [2]
        System.out.println(msg);
    &#125;
&#125;

public class MethodReferences &#123;
    static void hello(String name) &#123; // [3]
        System.out.println(&quot;Hello, &quot; + name);
    &#125;
    static class Description &#123;
        String about;
        Description(String desc) &#123; about = desc; &#125;
        void help(String msg) &#123; // [4]
            System.out.println(about + &quot; &quot; + msg);
        &#125;
    &#125;
    static class Helper &#123;
        static void assist(String msg) &#123; // [5]
            System.out.println(msg);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        Describe d = new Describe();
        Callable c = d::show;
        //将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。
        c.call(&quot;call()&quot;); //现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show(),因为其签名均是String。

        c = MethodReferences::hello; //这是一个静态方法引用。
        c.call(&quot;Bob&quot;);

        c = new Description(&quot;valuable&quot;)::help; // 对已实例化对象的方法的引用，称为绑定方法引用。
        c.call(&quot;information&quot;);

        c = Helper::assist; // 内部类方法引用
        c.call(&quot;Help!&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p><strong>Runnable</strong> 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 <code>run()</code> 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong>：</p>
<pre><code class="java">// 方法引用与 Runnable 接口的结合使用

class Go &#123;
  static void go() &#123;
    System.out.println(&quot;Go::go()&quot;);
  &#125;
&#125;

public class RunnableMethodReference &#123;
  public static void main(String[] args) &#123;

    new Thread(new Runnable() &#123;//内部类方法
      public void run() &#123;
        System.out.println(&quot;Anonymous&quot;);
      &#125;
    &#125;).start();

    new Thread(
      () -&gt; System.out.println(&quot;lambda&quot;)//lambda表达式
    ).start();

    new Thread(Go::go).start();//方法引用
  &#125;
&#125;
</code></pre>
<h2 id="未绑定的方法引用"><a href="#未绑定的方法引用" class="headerlink" title="未绑定的方法引用"></a>未绑定的方法引用</h2><blockquote>
<p>在目标类没有对象的时候对其采用方法引用，即为未绑定方法引用（静态类除外）</p>
<p>可使用目标类类型的方法参数解决未绑定方法引用问题</p>
</blockquote>
<pre><code class="java">package com.test.day6;

// functional/UnboundMethodReference.java

// 没有方法引用的对象

class X &#123;
    String f() &#123; return &quot;X::f()&quot;; &#125;
&#125;

interface MakeString &#123;
    String make();
&#125;

interface TransformX &#123;
    String transform(X x);
&#125;

public class UnboundMethodReference &#123;
    public static void main(String[] args) &#123;
        // MakeString ms = X::f; // 不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。
        TransformX sp = X::f;//TransformX下的String transform(X x)方法接受一个X类的参数，所以可与完成对象绑定并成功调用方法。
        X x = new X();
        System.out.println(sp.transform(x)); // [2]
        System.out.println(x.f()); // 同等效果
    &#125;
&#125;




package com.test.day6;

// functional/MultiUnbound.java

// 未绑定的方法与多参数的结合运用

class This &#123;
    void two(int i, double d) &#123;&#125;
    void three(int i, double d, String s) &#123;&#125;
    void four(int i, double d, String s, char c) &#123;&#125;
&#125;
/*接口方法中加入对象类型参数 达到绑定对象目的*/
interface TwoArgs &#123;
    void call2(This athis, int i, double d);//参数This athis达到绑定对象目的
&#125;

interface ThreeArgs &#123;
    void call3(This athis, int i, double d, String s);
&#125;

interface FourArgs &#123;
    void call4(
            This athis, int i, double d, String s, char c);
&#125;

public class MultiUnbound &#123;
    public static void main(String[] args) &#123;
        TwoArgs twoargs = This::two;
        ThreeArgs threeargs = This::three;
        FourArgs fourargs = This::four;
        This athis = new This();
        twoargs.call2(athis, 11, 3.14);//相当于woargs.call2(this.athis, 11, 3.14),成功绑定对象并传入参数调用方法
        threeargs.call3(athis, 11, 3.14, &quot;Three&quot;);
        fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, &#39;Z&#39;);
    &#125;
&#125;
</code></pre>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><pre><code class="java">package com.test.day6;

// functional/CtorReference.java

class Dog &#123;
    String name;
    int age = -1; // For &quot;unknown&quot;
    Dog() &#123; name = &quot;stray&quot;; &#125;
    Dog(String nm) &#123; name = nm; &#125;
    Dog(String nm, int yrs) &#123; name = nm; age = yrs; &#125;
&#125;

interface MakeNoArgs &#123;
    Dog make();
&#125;

interface Make1Arg &#123;
    Dog make(String nm);
&#125;

interface Make2Args &#123;
    Dog make(String nm, int age);
&#125;

public class CtorReference &#123;
    public static void main(String[] args) &#123;
        /*[1][2][3]分别引用不同签名的构造器*/
        MakeNoArgs mna = Dog::new; // [1]根据MakeNoArgs接口中方法的签名引用相符的构造器
        Make1Arg m1a = Dog::new;   // [2]根据Make1Arg接口中方法的签名引用相符的构造器
        Make2Args m2a = Dog::new;  // [3]根据MakeNoArgsMake2Args接口中方法的签名引用相符的构造器
        
        Dog dn = mna.make();//相当于调用引用Dog类的构造器
        Dog d1 = m1a.make(&quot;Comet&quot;);
        Dog d2 = m2a.make(&quot;Ralph&quot;, 4);
    &#125;
&#125;
</code></pre>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><blockquote>
<p>只包含一个抽象方法的接口（接口中方法默认为抽象的）</p>
<p>如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会自动包装方法引用或 Lambda 表达式到实现目标接口的类的实例中。</p>
</blockquote>
<pre><code class="java">// functional/FunctionalAnnotation.java

@FunctionalInterface
//@FunctionalInterface 的作用：接口中如果有多个方法则会产生编译期错误
interface Functional &#123;
  String goodbye(String arg);
&#125;

interface FunctionalNoAnn &#123;
  String goodbye(String arg);
&#125;


public class FunctionalAnnotation &#123;
  public String goodbye(String arg) &#123;
    return &quot;Goodbye, &quot; + arg;
  &#125;
  public static void main(String[] args) &#123;
    FunctionalAnnotation fa =
      new FunctionalAnnotation();
    Functional f = fa::goodbye;
    FunctionalNoAnn fna = fa::goodbye;
    // Functional fac = fa; // Incompatible
    Functional fl = a -&gt; &quot;Goodbye, &quot; + a;
    FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a;
  &#125;
&#125;
</code></pre>
<p><code>java.util.function</code> 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。</p>
<p> 以下是基本命名准则：</p>
<ol>
<li>如果只处理对象而非基本类型，名称则为 <code>Function</code>，<code>Consumer</code>，<code>Predicate</code> 等。参数类型通过泛型添加。</li>
<li>如果接收的参数是基本类型，则由名称的第一部分表示，如 <code>LongConsumer</code>，<code>DoubleFunction</code>，<code>IntPredicate</code> 等，但基本 <code>Supplier</code> 类型例外。</li>
<li>如果返回值为基本类型，则用 <code>To</code> 表示，如 <code>ToLongFunction &lt;T&gt;</code> 和 <code>IntToLongFunction</code>。</li>
<li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 <code>UnaryOperator</code>，两个参数使用 <code>BinaryOperator</code>。</li>
<li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li>
<li>如果接收的两个参数类型不同，则名称中有一个 <code>Bi</code>。</li>
</ol>
<p>下表描述了 <code>java.util.function</code> 中的目标类型（包括例外情况）：</p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>函数式方法名</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>无参数；   无返回值</td>
<td><strong>Runnable</strong>   (java.lang)     <code>run()</code></td>
<td><strong>Runnable</strong></td>
</tr>
<tr>
<td>无参数；   返回类型任意</td>
<td><strong>Supplier</strong>   <code>get()</code>   <code>getAs类型()</code></td>
<td><strong>Supplier<code>&lt;T&gt;</code>    BooleanSupplier    IntSupplier    LongSupplier    DoubleSupplier</strong></td>
</tr>
<tr>
<td>无参数；   返回类型任意</td>
<td><strong>Callable</strong>   (java.util.concurrent)    <code>call()</code></td>
<td><strong>Callable<code>&lt;V&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数；   无返回值</td>
<td><strong>Consumer</strong>   <code>accept()</code></td>
<td><strong><code>Consumer&lt;T&gt;</code>   IntConsumer   LongConsumer   DoubleConsumer</strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong></td>
<td><strong>BiConsumer</strong>   <code>accept()</code></td>
<td><strong><code>BiConsumer&lt;T,U&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong>；   1 引用；   1 基本类型</td>
<td><strong>Obj类型Consumer</strong>   <code>accept()</code></td>
<td><strong><code>ObjIntConsumer&lt;T&gt;</code>   <code>ObjLongConsumer&lt;T&gt;</code>   <code>ObjDoubleConsumer&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数；   返回类型不同</td>
<td><strong>Function</strong>   <code>apply()</code>   <strong>To类型</strong> 和 <strong>类型To类型</strong>   <code>applyAs类型()</code></td>
<td><strong>Function<code>&lt;T,R&gt;</code>   IntFunction<code>&lt;R&gt;</code>   <code>LongFunction&lt;R&gt;</code>   DoubleFunction<code>&lt;R&gt;</code>   ToIntFunction<code>&lt;T&gt;</code>   <code>ToLongFunction&lt;T&gt;</code>   <code>ToDoubleFunction&lt;T&gt;</code>   IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>1 参数；   返回类型相同</td>
<td><strong>UnaryOperator</strong>   <code>apply()</code></td>
<td><strong><code>UnaryOperator&lt;T&gt;</code>   IntUnaryOperator   LongUnaryOperator   DoubleUnaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同；   返回类型相同</td>
<td><strong>BinaryOperator</strong>   <code>apply()</code></td>
<td><strong><code>BinaryOperator&lt;T&gt;</code>   IntBinaryOperator   LongBinaryOperator   DoubleBinaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同;   返回整型</td>
<td>Comparator   (java.util)   <code>compare()</code></td>
<td><strong><code>Comparator&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数；   返回布尔型</td>
<td><strong>Predicate</strong>   <code>test()</code></td>
<td><strong><code>Predicate&lt;T&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   IntPredicate   LongPredicate   DoublePredicate</strong></td>
</tr>
<tr>
<td>参数基本类型；   返回基本类型</td>
<td><strong>类型To类型Function</strong>   <code>applyAs类型()</code></td>
<td><strong>IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>2 参数类型不同</td>
<td><strong>Bi操作</strong>   (不同方法名)</td>
<td><strong><code>BiFunction&lt;T,U,R&gt;</code>   <code>BiConsumer&lt;T,U&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   <code>ToIntBiFunction&lt;T,U&gt;</code>   <code>ToLongBiFunction&lt;T,U&gt;</code>   <code>ToDoubleBiFunction&lt;T&gt;</code></strong></td>
</tr>
</tbody></table>
<p>此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#006674>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-03/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/2/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            

            
            <a href="/">
                <span class="page-num">1</span>
            </a>
            

            

            
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
        </span>
        

        <span class="current">
            3
        </span>

        
        <span>
            <a href="/page/4/">
                <span class="page-num">
                    4
                </span>
            </a>
            
            <a href="/page/5">
                <span class="page-num">
                    5
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/6">
                <span class="page-num">
                    6
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/4/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>