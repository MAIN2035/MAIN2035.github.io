
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/20/Java-Stack-01/">
        <h2>
            Stack,Queue,Tree
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/dataStructure">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                dataStructure
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <pre><code class="mermaid">graph LR

A[扫描输入] --&gt;B&#123;是否为运算符&#125;

    B --&gt; |是运算符| C&#123;运算符栈是否为空&#125;
    B --&gt;|是数值| D&#123;判断是否为多位数&#125;
    D --&gt;|是多位| J[扫描到运算符为止]
    J --&gt; K
    D --&gt;|是个位| K[压入数值栈]
    C --&gt;|为空| E[将运算符压入栈]
    C --&gt;|不为空| F&#123;比较运算符优先级&#125;
    F --&gt;|优先级高于栈顶| G[入栈]
    F --&gt;|优先级低于栈顶| H[弹出运算符栈与数值栈中元素]
    H --&gt;|进行计算| I[将计算结果与比较优先级的运算符分别入栈]
    O[中缀表达式算法]
   
</code></pre>
<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>方法：为每个运算符旁的数值加括号如:<code>a+b*c; </code>改为<code> (a+(b*c))</code>，再将运算符移到括号外，得到后缀表达式<code> abc*+</code></p>
<p>转为算法：</p>
<ol>
<li>新建运算符栈，从左至右扫描，</li>
<li>运算符栈空时直接入栈，不为空则比较优先级，优先级大于时直接入栈，等于或小于时先（原栈顶元素）出栈，（档期元素）再入栈</li>
<li>到达末尾（即扫描完毕时），弹出所有运算符并追加到表达式末尾</li>
</ol>
<p>后缀表达式求值：遇到符号弹出数值进行求值（数值优先处于符号右方）</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="数组实现："><a href="#数组实现：" class="headerlink" title="数组实现："></a>数组实现：</h2><pre><code class="java">package com.pdf.data;

import org.junit.Test;

public class ArrayStack &#123;
    /*字段分别为：栈大小、模拟栈的数组、栈顶*/
    private int maxsize;
    private int[] stack;
    private int top = -1;
    public ArrayStack(int maxsize)&#123;
        this.maxsize = maxsize;
        stack = new int[this.maxsize];
    &#125;
    /*The stack is full*/
    public boolean isFull()&#123;
        return top+1 == maxsize;
    &#125;
    /*The stack is void*/
    public boolean isEmpty()&#123;
        return top == -1;
    &#125;
    /*Press-in data*/
    public void push(int value)&#123;
        if (isFull())&#123;
            System.out.println(&quot;Stack fill&quot;);
            return;
        &#125;
        top++;
        stack[top]=value;
    &#125;
    /*Pop-up data*/
    public int pop()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;Stack Void&quot;);
        &#125;
        int value = stack[top];
        top--;
        return value;
    &#125;
    /*print Stack*/
    public void list()&#123;
        if (isEmpty())&#123;
            System.out.println(&quot;Stack void&quot;);
            return;
        &#125;
        for (int i=top;i&gt;=0;i--)&#123; System.out.printf(&quot;stack[%d]=%d\n&quot;,i,stack[i]);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        var mStack = new ArrayStack(100);
        for (int i = 1; i &lt; 101; i++) &#123;
            assert i &lt; 50:i;//断言
            mStack.push(i);
        &#125;
        mStack.list();

    &#125;
&#125;
</code></pre>
<h2 id="链表实现："><a href="#链表实现：" class="headerlink" title="链表实现："></a>链表实现：</h2><pre><code class="java">package com.abstrast.data.stack;

import java.util.EmptyStackException;

/*链表实现栈*/
public final class LinkedStack&lt;T&gt; implements StackInterface&lt;T&gt; &#123;
    private Node topNode;//指向栈顶
    public LinkedStack()&#123;
        topNode = null;
    &#125;
    /*节点类*/
    private class Node&#123;
        private T data;
        private Node next;
        Node(T newEntry,Node topNode)&#123;
            data = newEntry;
            next = topNode;

        &#125;

        public Node getNextNode() &#123;
            return next;
        &#125;

        public T getData() &#123;
            return data;
        &#125;
    &#125;
    @Override
    public void push(T newEntry) &#123;
//        Node newNode = new Node(newEntry,topNode);
//        topNode = newNode;
        topNode = new Node(newEntry,topNode);// 压入数据时直接指向栈顶
    &#125;

    @Override
    public T pop() &#123;
        T top = peek();
        topNode = topNode.getNextNode();
        return top;
    &#125;

    @Override
    public T peek() &#123;//查看栈顶元素
       if(isEmpty())
           throw new EmptyStackException();
       else
           return topNode.getData();
    &#125;

    @Override
    public boolean isEmpty() &#123;
        return topNode ==null;//顶栈为null则为空
    &#125;

    @Override
    public void clear() &#123;//没有顶栈则栈为空
        topNode = null;

    &#125;

//    public static void main(String[] args) &#123;
//        var a = new LinkedStack&lt;String&gt;();
//        a.push(&quot;a&quot;);
//        a.push(&quot;b&quot;);
//        a.push(&quot;c&quot;);
//        a.push(&quot;d&quot;);
//        a.peek();
//        a.pop();
//        a.peek();
//    &#125;
&#125;
</code></pre>
<h2 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h2><pre><code class="java">import java.util.Iterator;
/**
 * 这是一个动态数组栈*/

public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;&#123;//实现Iterable&lt;Item&gt;接口后可以使用foreach遍历
    private Item[] a = (Item[]) new Object[1];//栈元素数量，通过强制类型转换Object数组实现泛型号=数组
    private int N = 0;//元素数量
    public boolean isEmpty()&#123;
        return N == 0;
    &#125;
    public int size()&#123;
        return N;
    &#125;
    /*实现动态数组*/
    private void resize(int max)&#123;
        Item[] temp = (Item[]) new Object[max];//创建空间大小为2倍的新数组
        for (int i = 0; i &lt; N; i++)&#123;//复制数组元素
            temp[i] = a[i];
        &#125;
        a = temp;
    &#125;
    public void push(Item item)&#123;
        if (N == a.length)resize(2*a.length);//数组存储空间不足，则扩大为2倍
        a[N++] = item;//每次添加元素N+1
    &#125;
    public Item pop()&#123;
        Item item = a[--N];
        a[N] = null;//防止游离元素，即不在栈中，但仍存在于数组中的元素
        if (N &gt; 0&amp;&amp;N == a.length/4)resize(a.length/2);//如果该数组仅仅占用1/4,那么缩小它
        return item;
    &#125;
    public Iterator&lt;Item&gt; iterator()&#123;//实现了一个迭代器
        return new ReverseArrayIterator();
    &#125;
    private class ReverseArrayIterator implements Iterator&lt;Item&gt;&#123;
        private int i = N;
        public boolean hasNext()&#123;return  i &gt; 0;&#125;
        public Item next()&#123;return a[--i];&#125;//next即越过并返回这个元素，
        // 数组下标从0开始，而数组中只要存在元素那么数量便从1开始，故需要减1（否则下标N下的元素不存在则返回null）
        public void remove()&#123;&#125;
    &#125;

    public static void main(String[] args) &#123;
        long startTime = System.currentTimeMillis(); // 获取开始时间
        var a = new ResizingArrayStack&lt;String&gt;();
        for (int i = 0; i &lt; 1000000; i++) &#123;
            a.push(&quot;abc&quot;+i);
        &#125;
        for (String s: a)
            System.out.println(s);
        long endTime = System.currentTimeMillis(); // 获取结束时间
        System.out.println(&quot;程序运行时间： &quot; + (endTime - startTime) + &quot;ms&quot;);


    &#125;
&#125;
</code></pre>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h2><pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue &lt;T&gt;implements Iterable&lt;T&gt;&#123;
    /**分析：
     * 队列实现需包含：队列长度、头指针，尾指针、结点类。
     *功能:增、删、清空查看队列、队列有无、查看队列头元素
     * 迭代：队列类实现可迭代接口Iterable&lt;T&gt;，再由内部类实现迭代器。
     */
    private int length;
    private Node head,tail;

    /*节点类*/
    private class Node&lt;T&gt;&#123;
        private T data;
        private Node next;

        Node(T data) &#123;
            this.data = data;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;Node(&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &#39;)&#39;;
        &#125;
    &#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&#123;
//        return length!=0;也可以哦
        return head == null;
    &#125;
    /*添加元素*/
    private void enqueue(T x)&#123;
        if (isEmpty())&#123;
            tail = head = new Node&lt;T&gt;(x);
            length++;
        &#125;else &#123;
            tail = tail.next = new Node&lt;T&gt;(x);//尾指针与与原尾结点均指向新结点
            length++;
        &#125;
    &#125;
    /*删除元素*/
    public T dequeue()&#123;
        if (isEmpty())&#123;
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &#125;else&#123;
            T returnValue = (T) head.data;
            head = head.next;
            length--;
            return returnValue;
        &#125;
    &#125;
    /*清空队列*/
    public void makeEmpty()&#123;
        head=tail=null;
        length=0;
    &#125;

    /*返回头元素*/
    public T getHead() throws Exception &#123;
        if (isEmpty())&#123;
            throw new Exception(&quot;队列无数据&quot;);
        &#125;else&#123;
            return (T) head.data;
        &#125;
    &#125;
    /*查看队列中所有元素*/
    public void showQueue()&#123;
        Node head =this.head;//引用head便于进行遍历
        while (head.next!=null)&#123;
            System.out.println(head.data);
            head=head.next;
        &#125;
        System.out.println(head.data);

    &#125;
    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&#123;
        private Node current = head;
        public boolean hasNext() &#123;
            return current != null;
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &#125;

        public T next() &#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;
            current = current.next;
            return item;
        &#125;

    &#125;

    @Override
    public String toString() &#123;
        return &quot;ListQueue&#123;&quot; +
                &quot;length=&quot; + length +
                &quot;, head=&quot; + head +
                &quot;, tail=&quot; + tail +
                &#39;&#125;&#39;;
    &#125;

    /*测试*/
    public static void main(String[] args) throws Exception &#123;
        var a = new ListQueue&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &#123;//添加元素
            a.enqueue(i);
        &#125;
        for (int i: a) &#123;
            System.out.println(i);

        &#125;
      //覆盖toString只为了更直观的查看队列
        System.out.println(a+&quot;&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="数组模拟队列-amp-amp-单例模式"><a href="#数组模拟队列-amp-amp-单例模式" class="headerlink" title="数组模拟队列&amp;&amp;单例模式"></a>数组模拟队列&amp;&amp;单例模式</h2><pre><code class="java">import org.junit.Test;

public class ArrayQueue &#123;

    private static int maxsize;
    /*分别创建最大容量、头指针、尾指针、数组*/
    private int front = -1;
    private int rear = -1;
    private int[] arr;
    private static ArrayQueue MYARRAYQUEUE;
    private ArrayQueue(int maxsize)&#123;
        this.maxsize = maxsize;
        arr = new int[maxsize];
    &#125;
    /*队列是否为满*/
    public boolean isFull()&#123;
        return rear == maxsize-1;//因为尾、头部指针开始均指向-1，故容量减1为满
    &#125;
    /*队列是否为空*/
    public boolean isEmpty()&#123;
        return rear  == front;
    &#125;
    /*添加数据到队列*/
    public void addQueue(int n)&#123;
       if (isFull())&#123;
           System.out.println(&quot;挤挤总会有的？？？&quot;);
           return;
       &#125;
       arr[++rear]=n;// 写入尾部
    &#125;
    public static synchronized ArrayQueue getArrayQueue(int a)&#123;
        if(null != MYARRAYQUEUE)return MYARRAYQUEUE;
        maxsize = a;
        MYARRAYQUEUE = new ArrayQueue(a);
        return MYARRAYQUEUE;
    &#125;

    public void showQueue() &#123;
        var a = ArrayQueue.getArrayQueue(maxsize);
        // 遍历
        if (isEmpty()) &#123;
            System.out.println(&quot;队列空的，没有数据~~&quot;);
            return;
        &#125;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);
        &#125;
    &#125;
&#125;
class RunArrayQueue extends Thread&#123;
    @Override
    public void run() &#123;
        var a = ArrayQueue.getArrayQueue(4);
        a.showQueue();
        a.addQueue(4);
        a.addQueue(5);
        a.addQueue(6);
        a.showQueue();
    &#125;

    public static void main(String[] args) &#123;
        var a = new RunArrayQueue();
        var b = new RunArrayQueue();
        a.start();
        b.start();
    &#125;
&#125;
</code></pre>
<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><pre><code class="java">public class CircleArrayQueue &#123;
    private static int maxsize;
    /*分别创建最大容量、头指针、尾指针、数组*/
    private int front = 0;
    private int rear = 0;
    private int[] arr;

    private CircleArrayQueue(int maxsize) &#123;
        this.maxsize = maxsize;
        arr = new int[maxsize];
    &#125;

    /*队列是否为满*/
    public boolean isFull() &#123;
        return (rear + 1) % maxsize == front;
        //无论指针怎么移动，rear总与最后一个元素间隔一格
    &#125;

    /*队列是否为空*/
    public boolean isEmpty() &#123;
        return rear == front;
    &#125;

    /*添加数据到队列*/
    public void addQueue(int n) &#123;
        if (isFull()) &#123;
            System.out.println(&quot;挤挤总会有的？？？&quot;);
            return;
        &#125;
        arr[rear] = n;
        rear = (rear + 1) % maxsize;
    &#125;

    /*取出数据*/
    public int getQueue() &#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;队列为空你币没了&quot;);
        &#125;
        int value = arr[front];
        front = (front + 1)%maxsize;
        return value;

    &#125;
    /*打印队列*/
    public void showQueue() &#123;
        // 遍历
        if (isEmpty()) &#123;
            System.out.println(&quot;队列空的，没有数据~~&quot;);
            return;
        &#125;
        for (int i = 0; i &lt; front + size(); i++) &#123;
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i%maxsize, arr[i%maxsize]);
        &#125;
    &#125;
    public int size()&#123;
        return (rear + maxsize -front)%maxsize;
    &#125;
    //显示队列头信息
    public int headQueue()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;队列为空&quot;);
        &#125;
        return arr[front];
    &#125;

    public static void main(String[] args) &#123;
       var a = new CircleArrayQueue(10);
    &#125;
&#125;

</code></pre>
<h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><h3 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h3><pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue2&lt;T&gt;implements Iterable&lt;T&gt;&#123;
    /**双向队列不带头结点
     */
    private int length;
    private Node head,tail;

    /*节点类*/
    private class Node&lt;T&gt;&#123;
        private T data;
        private Node next;
        private Node prev;

        Node(T data) &#123;
            this.data = data;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;Node&#123;&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &quot;, prev=&quot; + prev +
                    &#39;&#125;&#39;;
        &#125;
    &#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&#123;
//        return length==0;也可以哦
        return head == null;
    &#125;
    /*队头添加元素*/
    private void addHead(T x)&#123;
        if (isEmpty())&#123;
            tail = head = new Node(x);
            length++;
            &#125;
        else &#123;
            Node newNode = head;//指向原head指向的首结点
            head = new Node(x);//将head指向添加的新结点
            //head.prev=null;类中的成员字段会自动初始化为null，故不必设置新首结点prev=null
            head.next = newNode;//将新结点的next指向原首节点
            newNode.prev = head;//原首结点的prev指向新结点
            length++;//队列长度+1
        &#125;
    &#125;
    /*队尾添加元素*/
    private void addTail(T x)&#123;
        if (isEmpty())&#123;
            tail = head = new Node(x);
            length++;
        &#125;
        else &#123;
            Node newNode = tail;
            tail = new Node(x);
            //tail.next=null;类中的成员字段会自动初始化为null，故不必设置新尾结点next=null
            newNode.next = tail;//原尾结点的next指向新结点
            tail.prev=newNode;//新结点的prev指向原尾结点
            length++;
        &#125;
    &#125;

    /*队头删除元素*/
    public T removeHead()&#123;
        if (isEmpty())&#123;//队列无元素抛出异常
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &#125;else&#123;
            T returnValue = (T) head.data;
            head = head.next;
            length--;
            //如果删除时队列中只存在一个元素则head=null，否则令首节点的prev=null
            if (length==0)&#123;
                tail=head=null;
            &#125;else &#123;
                head.prev=null;
            &#125;
            return returnValue;
        &#125;
    &#125;
    /*队尾删除元素*/
    public T removeTail()&#123;
        if (isEmpty())&#123;
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &#125;else&#123;
            T returnValue = (T) tail.data;
            tail = tail.prev;
            length--;
            if (length==0)&#123;
                tail=head=null;
            &#125;else &#123;
                tail.next=null;
            &#125;
            return returnValue;//返回被删除结点的值
        &#125;
    &#125;
    /*清空队列*/
    public void makeEmpty()&#123;
        head=tail=null;
        length=0;
    &#125;

    /*返回头元素*/
    public T getHead() throws Exception &#123;
        if (isEmpty())&#123;
            throw new Exception(&quot;队列无数据&quot;);
        &#125;else&#123;
            return (T) head.data;
        &#125;
    &#125;
    /*查看队列中所有元素*/
    public void showQueue()&#123;
        Node head =this.head;//引用head便于进行遍历
        while (head.next!=null)&#123;
            System.out.println(head.data);
            head=head.next;
        &#125;
        System.out.println(head.data);

    &#125;
    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&#123;
        private ListQueue2.Node current = head;//指向首结点
        public boolean hasNext() &#123;
            return current != null;
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &#125;

        public T next() &#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;//存储当前结点中的值
            current = current.next;//更新指针，指向下一个结点
            return item;//返回当前结点中的值
        &#125;

    &#125;

    @Override
    public String toString() &#123;
        return &quot;ListQueue&#123;&quot; +
                &quot;length=&quot; + length +
                &quot;, head=&quot; + head +
                &quot;, tail=&quot; + tail +
                &#39;&#125;&#39;;
    &#125;

    /*测试*/
    public static void main(String[] args) throws Exception &#123;
        var a = new ListQueue2&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &#123;//添加元素
            a.addHead(i);
            a.removeTail();
        &#125;a.removeTail();
        for (int i: a) &#123;
            System.out.println(i);

        &#125;
      //覆盖toString只为了更直观的查看队列
        System.out.println(a+&quot;&quot;);
    &#125;
&#125;

</code></pre>
<p>###带头结点</p>
<pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue3&lt;T&gt;implements Iterable&lt;T&gt;&#123;
    /**双向队列带头结点的
     * 引入一个头结点nil， 初始化时nil的prev和next分别指向自身。用于判断队列是否为空
     * 加入新元素以后只需要操作新增节点，nil 和 nil的下一个节点。
     */
    private int length;
    private Node headNode;


    /*节点类*/
    private class Node&lt;T&gt;&#123;
        private T data;
        private Node next;
        private Node prev;
        //使用了默认结点构造器

        @Override
        public String toString() &#123;
            return &quot;Node&#123;&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &quot;, prev=&quot; + prev +
                    &#39;&#125;&#39;;
        &#125;
    &#125;
    public ListQueue3()&#123;
        headNode = new Node();
        headNode.next = headNode;
        headNode.prev = headNode;
    &#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&#123;
//        return length==0;也可以哦
        return headNode.next == headNode;
    &#125;
    /*队头添加元素
    * 添加的所有元素都将位于头结点之后*/
    private void addHead(T x)&#123;
            Node newNode = new Node();//创建新结点
            newNode.data=x;
            //以下操作顺序不能颠倒
            //先将新结点的前驱为头结点，后继为头结点的原后继
            newNode.prev=headNode;
            newNode.next=headNode.next;
            //再将头结点的原后继的前驱、改为新结点
            headNode.next.prev=newNode;
            headNode.next=newNode;//最后将头结点的后继为新结点

            length++;//队列长度+1

    &#125;
    /*队尾添加元素
    * 添加的所有元素都将位于头结点之前*/
    private void addTail(T x)&#123;
        Node newNode = new Node();//创建新结点
        newNode.data=x;
        newNode.next=headNode;//新结点的后继为头结点
        //以下操作顺序不能颠倒
        newNode.prev=headNode.prev;//现将新结点的前驱为头结点的前驱
        headNode.prev.next=newNode;//再将头结点前驱的后继为新结点
        headNode.prev=newNode;//最后将头结点前驱改为新结点
        length++;//队列长度+1

    &#125;

    /*队头删除元素*/
    public T removeHead()&#123;
        if (isEmpty())
            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);
        Node del = headNode.next;//指向将要删除的结点
        T retunValue = (T) del.data;
        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点
        del.next.prev = headNode;
        headNode.next = del.next;
        length--;
        return retunValue;
    &#125;
    /*队尾删除元素*/
    public T removeTail()&#123;
        if (isEmpty())
            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);
        Node del = headNode.prev;//指向将要删除的结点
        T retunValue = (T) del.data;
        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点
        del.prev.next=headNode;
        headNode.prev=del.prev;
        length--;
        return retunValue;
    &#125;
    /*清空队列*/
    public void makeEmpty()&#123;
        headNode.next=null;
        length=0;
    &#125;

    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&#123;
        private ListQueue3.Node current = headNode.next;//指向头结点
        public boolean hasNext() &#123;
            return current != headNode;
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &#125;

        public T next() &#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;//存储当前结点中的值
            current = current.next;//更新指针，指向下一个结点
            return item;//返回当前结点中的值
        &#125;

    &#125;





    /*测试*/
    public static void main(String[] args) throws Exception &#123;
        var a = new ListQueue3&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &#123;
            a.addTail(i);
        &#125;a.removeHead();
        for (int i: a) &#123;
            System.out.println(i);

        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树结点类：</p>
<pre><code class="java">package cn.three.cloth.Tree;
/**
 * 二叉树结点类*/
public class Node&lt;T&gt;&#123;
    private int no;
    private T element;
    private Node left;
    private Node right;

    public Node(int no, T element) &#123;
        this.no = no;
        this.element = element;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public T getElement() &#123;
        return element;
    &#125;

    public Node getLeft() &#123;
        return left;
    &#125;

    public Node getRight() &#123;
        return right;
    &#125;

    public void setNo(int no) &#123;
        this.no = no;
    &#125;

    public void setElement(T element) &#123;
        this.element = element;
    &#125;

    public void setLeft(Node left) &#123;
        this.left = left;
    &#125;

    public void setRight(Node right) &#123;
        this.right = right;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Node&#123;&quot; +
                &quot;no=&quot; + no +
                &quot;, element=&quot; + element +&quot;&#125;&quot;;
    &#125;

    /*前、中、后序遍历开始*/
    //前序遍历
    public void preOrder()&#123;
        System.out.println(this);
        if (this.left != null)&#123;
            this.left.preOrder();
        &#125;
        if (this.right != null)&#123;
            this.right.preOrder();
        &#125;
    &#125;
    //中序遍历
    public void infixOrder()&#123;
        if (this.left != null)&#123;
            this.left.infixOrder();
        &#125;
        System.out.println(this);
        if (this.right != null)&#123;
            this.right.infixOrder();
        &#125;
    &#125;
    //后序遍历
    public void postOrder()&#123;
        if (this.left != null)&#123;
            this.left.postOrder();
        &#125;
        if (this.right != null)&#123;
            this.right.postOrder();
        &#125;
        System.out.println(this);
    &#125;

    /*前、中、后序查找开始*/
    //前序查找、
    public Node preOrderSearch(int no)&#123;
        if (this.no == no)&#123;
            return this;
        &#125;
        Node resNode = null;
        if (this.left != null)&#123;
            resNode = this.left.preOrderSearch(no);
        &#125;
        if (resNode != null)&#123;
            return resNode;
        &#125;
        if (this.right != null)&#123;
            resNode = this.right.preOrderSearch(no);
        &#125;
        return resNode;
    &#125;
    //中序查找
    public Node infixOrderSearch(int no)&#123;
        Node resNode = null;
        if (this.left != null)&#123;
            resNode = this.left.infixOrderSearch(no);
        &#125;
        if (resNode != null)&#123;
            return resNode;
        &#125;
        if (this.no == no)&#123;
            return this;
        &#125;
        if (this.right != null)&#123;
            resNode = this.right.infixOrderSearch(no);
        &#125;
        return resNode;
    &#125;
    //后序查找
    public Node postOrderSearch(int no)&#123;
        Node resNode = null;
        if (this.left != null)&#123;
            resNode = this.left.postOrderSearch(no);
        &#125;
        if (resNode != null)&#123;
            return resNode;
        &#125;
        if (this.right != null)&#123;
            resNode = this.right.postOrderSearch(no);
        &#125;
        if (this.no == no)&#123;
            return this;
        &#125;
        return resNode;
    &#125;
    /*删除结点*/
    public void delNode(int no)&#123;
        //判断当前结点的左、右结点是否为要删除结点
        if (this.left !=null &amp;&amp; this.left.no == no)&#123;
            this.left = null;
            return;
        &#125;
        if (this.right !=null &amp;&amp; this.right.no == no)&#123;
            this.right = null;
            return;
        &#125;
        //··左、右递归删除
        if (this.left != null)&#123;
            this.left.delNode(no);
        &#125;;
        if (this.right != null)&#123;
            this.right.delNode(no);
        &#125;;


    &#125;

&#125;
</code></pre>
<p>二叉树：</p>
<pre><code class="java">
package cn.three.cloth.Tree;
/**
 * 二叉树*/
public class BinaryTree1 &#123;
    private Node root;

    public void setRoot(Node root) &#123;
        this.root = root;
    &#125;
/*前、中、后序遍历*/
    public void preOrder()&#123;
        if (this.root != null)&#123;
            this.root.preOrder();
        &#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &#125;

    public void infixOrder()&#123;
        if (this.root != null)&#123;
            this.root.infixOrder();
        &#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &#125;

    public void postOrder()&#123;
        if (this.root != null)&#123;
            this.root.postOrder();
        &#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &#125;
    /*前、中、后序遍历*/
    public Node preOrderSearch(int no)&#123;
        if (root != null)&#123;
            return root.preOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    public Node infixOrderSearch(int no)&#123;
        if (root != null)&#123;
            return root.infixOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    public Node postOrderSearch(int no)&#123;
        if (root != null)&#123;
            return root.postOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    public void delNode(int no)&#123;
        if (root != null)&#123;//该树不为空树
            if (root.getNo() == no)&#123;//该树根结点是否为目标结点
                root = null;
            &#125;else &#123;
                root.delNode(no);//递归删除（Node类中的）以此结点为根结点。沿着左结点遍历查询删除，如未找到则再沿着根结点的右结点遍历查询
            &#125;
        &#125;else &#123;
            System.out.println(&quot;该树为空！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组<img src="https://i.loli.net/2020/09/13/qRFTifeoytCw1c6.png"></h1><pre><code class="java">
public class SparseArray &#123;

    public static void main(String[] args) &#123;
        // 创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;
        // 输出原始的二维数组
        System.out.println(&quot;原始的二维数组~~&quot;);
        for (int[] row : chessArr1) &#123;
            for (int data : row) &#123;
                System.out.printf(&quot;%d\t&quot;, data);
            &#125;
            System.out.println();
        &#125;

        // 将二维数组 转 稀疏数组的思路
        // 1. 先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int i = 0; i &lt; 11; i++) &#123;
            for (int j = 0; j &lt; 11; j++) &#123;
                if (chessArr1[i][j] != 0) &#123;
                    sum++;
                &#125;
            &#125;
        &#125;

        // 2. 根据非0数据个数再加一（记录总行、列、有效值个数）创建对应的稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        
        // 遍历二维数组，将非0的值存放到 sparseArr中
        int count = 0; //count 用于记录是第几个非0数据
        for (int i = 0; i &lt; 11; i++) &#123;
            for (int j = 0; j &lt; 11; j++) &#123;
                if (chessArr1[i][j] != 0) &#123;
                    count++;
                    sparseArr[count][0] = i;//行
                    sparseArr[count][1] = j;//列
                    sparseArr[count][2] = chessArr1[i][j];//值
                &#125;
            &#125;
        &#125;
        
        // 输出稀疏数组的形式
        System.out.println();
        System.out.println(&quot;得到稀疏数组为~~~~&quot;);
        for (int i = 0; i &lt; sparseArr.length; i++) &#123;
            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        &#125;
        System.out.println();
        
        //将稀疏数组 --》 恢复成 原始的二维数组
        /*
         *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]
            2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
         */
        
        //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
        
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        
        //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可
        
        for(int i = 1; i &lt; sparseArr.length; i++) &#123;
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        &#125;
        
        // 输出恢复后的二维数组
        System.out.println();
        System.out.println(&quot;恢复后的二维数组&quot;);
        
        for (int[] row : chessArr2) &#123;
            for (int data : row) &#123;
                System.out.printf(&quot;%d\t&quot;, data);
            &#125;
            System.out.println();
        &#125;
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#006674>
                Java
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-Stack-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Java-datas-heap/">
        <h2>
            heap,heap-sort
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/dataStructure">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                dataStructure
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>堆：以<strong>完全二叉树</strong>的形式展现：</p>
<p>除了树的最后一层结点不需要是满的，其它的每一层<strong>从左到右</strong>都是满的，如果最后一层结点不 是满的，那么要求<strong>左满右不满</strong></p>
<p><img src="http://img.lbkzw.cn/img/20201029185145.png" alt="image-20201029185145002"></p>
<p>并以<strong>数组</strong>进行存储。每个结点都大于等于它的两个<strong>子结点</strong>。</p>
<p>如下图，如用k表示<strong>当前结点</strong>，则其的<strong>左右结点</strong>分别为2k，2k+1，任意结点的<strong>父节点</strong>为k/2</p>
<p>k/2(包括k/2)前是<strong>非叶子结点</strong>k/2之后是<strong>叶子结点</strong>。</p>
<p><img src="http://img.lbkzw.cn/img/20201027152457.png" alt="image-20201027152457648"></p>
<h1 id="堆实现"><a href="#堆实现" class="headerlink" title="堆实现"></a>堆实现</h1><pre><code class="java">package cn.three.cloth.heap;

public class Heap&lt;T extends  Comparable &lt;T&gt;&gt; &#123;//类型 T 必须实现 Comparable 接口，并且这个接口的类型是 T
    private T[] items;//存储堆
    private int N;//堆元素的数量

    public Heap(int x) &#123;
        this.items = (T[]) new Comparable[x+1];//数组索引0处不存放元素
    &#125;

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j)&#123;
        return items[i].compareTo(items[j])&lt;0;
    &#125;
    //交换堆中i索引和j索引处的值
    private void exch(int i,int j)&#123;
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    &#125;

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax()&#123;
        T max = items[1];
        exch(1,N);//交换最大元素与末尾元素的位置
        items[N]=null;//清除游离元素
        N--;//元素数量减一
        sink(1);//下沉
        return max;
    &#125;
    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k)&#123;
        //将当前结点k与其较大的一个子结点对比，如果当前结点k小，则交换位置父子双方双方位置
        while(2*k&lt;=N)&#123;
            //当前结点无左子节点时停止循环
            int max;
            //找出左右子结点中最大的一个，并存入max
            if (2*k+1&lt;=N)&#123;//当前结点是否有右结点
                if (less(2*k,2*k+1))&#123;
                    max = 2*k+1;
                &#125;else&#123;
                    max = 2*k;
                &#125;
            &#125;else &#123;
                max = 2*k;
            &#125;

            //判断max是否小于当前结点
            if (!less(k,max))&#123;
                break;
            &#125;
            exch(k,max);//交换k与max的位置
            k = max;//并改变下次循环时k的值为max，进行后续的下沉循环操作
        &#125;



    &#125;

    //插入要上浮，删除要下沉
    //往堆中插入一个元素
    public void insert(T t)&#123;
        items[++N]=t;
        swim(N);//插入一个大的数值会影响堆内的顺序，故需要将元素置于一个恰当的位置
    &#125;
    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k)&#123;
        while (k&gt;1)&#123;
            if (less(k/2,k))&#123;//比较k结点与其父节点的大小
                exch(k/2,k);//将k与其父节点交换位置
            &#125;
            k = k / 2;//比较与交换结束后更新k的位置为其父结点
        &#125;
    &#125;

    public static void main(String[] args) &#123;
            Heap&lt;String&gt; heap = new Heap&lt;String&gt;(20);
            heap.insert(&quot;A&quot;);
            heap.insert(&quot;B&quot;);
            heap.insert(&quot;C&quot;);
            heap.insert(&quot;D&quot;);
            heap.insert(&quot;E&quot;);
            heap.insert(&quot;F&quot;);
            heap.insert(&quot;G&quot;);


            String del;
            while((del=heap.delMax())!=null)&#123;
                System.out.print(del+&quot;,&quot;);
            &#125;
        &#125;
&#125;
</code></pre>
<p>#堆排序</p>
<p>创建一个新数组，在其索引1（包含索引1）处往后对原数组进行复制，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后 对扫描到的每一个元素做下沉操作。</p>
<pre><code class="java">package cn.three.cloth.heap;

import java.util.Arrays;

public class HeapSort1 &#123;
    //调用此方法使用堆排序（从小到大排序）
    public static  void sort(Comparable[] source) &#123;
        Comparable[] heap = new Comparable[source.length+1];//创建一个大小为传入数组length+1的数组（此数组0索引下不添加数据）
        createHeap(source,heap);//创建堆
        int N = heap.length-1;//定义一个变量，记录未排序的元素中最大的索引

        //通过循环将小的元素排列在前
        while(N!=1)&#123;
            exch(heap,1,N);//交换元素
            N--; //排序交换后最大元素所在的索引，不参与此后的堆下沉
            sink(heap,1, N);//需要对索引1处的元素进行对的下沉调整
        &#125;
        //用排序好的数据覆盖原数组
        System.arraycopy(heap,1,source,0,source.length);

    &#125;

    private static  boolean less(Comparable[] heap, int i, int j) &#123;
        return heap[i].compareTo(heap[j])&lt;0;
        //heap[i]小于heap[j]时返回True，否则返回false
        //compareTo根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。
    &#125;

    //交换位置
    private static  void exch(Comparable[] heap, int i, int j) &#123;
        Comparable tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
    &#125;

    //构造堆进行排序
    private static void createHeap(Comparable[] source, Comparable[] heap) &#123;
        //复制数组source从下标0开始，复制到heap数组从索引1开始的位置往后
        System.arraycopy(source,0,heap,1,source.length);
        for (int i = (heap.length)/2;i&gt;0;i--)&#123;//从最后一个非叶结点开始下沉操作，直到所有非叶结点下沉完毕
            sink(heap,i,heap.length-1);
        &#125;
        //循环结束后将得到一个有序的堆（自根结点元素依次减小）

    &#125;

    //在heap堆中，对target处的元素做下沉
    //下沉之后大的元素在前.
    private static void sink(Comparable[] heap, int target, int range)&#123;

        while(2*target&lt;=range)&#123;//当前结点无左子节点时停止循环
            //1.找出当前结点的较大的子结点
            int max = 2*target;
            if (2*target+1&lt;=range)&#123;
                if (less(heap,2*target,2*target+1))&#123;
                    max = 2*target+1;
                &#125;
            &#125;
            //2.比较当前结点的值和较大子结点的值
            if (less(heap,target,max))&#123;
                //小于则交换父子结点位置
                exch(heap,target,max);
                target = max;
            &#125;else &#123;
                break;//大于则退出下沉循环
            &#125;
        &#125;
    &#125;



    public static void main(String[] args) &#123;
        String[] arry =&#123;&quot;a&quot;,&quot;d&quot;,&quot;b&quot;,&quot;s&quot;,&quot;Z&quot;,&quot;z&quot;&#125;;
        HeapSort1.sort(arry);
        System.out.println(Arrays.toString(arry));
    &#125;
&#125;

</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java" style=color:#607d8b>
                Java
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Java-datas-heap/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Javadm-02/">
        <h2>
            单例模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>最简单的设计模式，它是一种仅提供一个对象实例的方法。</p>
<pre><code class="java">interface Resource &#123;
    int getValue();
    void setValue(int x);
&#125;

/*
* 由于这不是从Cloneable基类继承而且没有添加可克隆性，
* 因此将其设置为final可防止通过继承添加可克隆性。
* 这也实现了线程安全的延迟初始化：
*/
final class Singleton &#123;
    private static final class ResourceImpl implements Resource &#123;
        private int i;
        private ResourceImpl(int i) &#123;//只有一个私有构造器供静态内部类调用
            this.i = i;
        &#125;
        /*两个属性*/
        public synchronized int getValue() &#123;
            return i;
        &#125;
        public synchronized void setValue(int x) &#123;
            i = x;
        &#125;
    &#125;

    private static class ResourceHolder &#123;
        private static Resource resource = new ResourceImpl(47);
    &#125;
    public static Resource getResource() &#123;//此公共静态方法供外部调用，返回对象
        return ResourceHolder.resource;
    &#125;
&#125;

public class SingletonPattern &#123;
    public static void main(String[] args) &#123;
        Resource r = Singleton.getResource();
        System.out.println(r.getValue());
        Resource s2 = Singleton.getResource();
        s2.setValue(9);
        System.out.println(r.getValue());
        try &#123;     
             // 不能这么做，会发生：compile-time error（编译时错误）.     
             // Singleton s3 = (Singleton)s2.clone();    
             &#125; catch(Exception e) &#123;      
                 throw new RuntimeException(e);    
             &#125;  
        &#125;
&#125; /* Output: 47 9 */
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java设计模式" style=color:#6484be>
                Java设计模式
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Javadm-02/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Javadm-01/">
        <h2>
            状态模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>将代理对象在生命周期内从一个实现切换到另一种实现</p>
<pre><code class="java">package cn;
//patterns/StateDemo.java //状态模式的简单演示
interface StateBase &#123;
    void f();

    void g();

    void h();

    void changeImp(StateBase newImp);
&#125;
/**
 * 多个操作类，多个代理类;
 * 一个共同接口一脉相承，中途变法自家兄弟*/
class State implements StateBase &#123;
    private StateBase implementation;

    State(StateBase imp) &#123;
        implementation = imp;//引用new Implementation1() new Implementation2()
    &#125;

    @Override
    public void changeImp(StateBase newImp) &#123;
        implementation = newImp;
    &#125;
     @Override
    public void f() &#123;
         implementation.f();
    &#125;

    @Override
    public void g() &#123;
        implementation.g();
    &#125;

    public void h() &#123;
        implementation.h();
    &#125;
&#125;

class Implementation1 implements StateBase &#123;
    @Override
    public void f() &#123;
        System.out.println(&quot;Implementation1.f()&quot;);
    &#125;

    @Override
    public void g() &#123;
        System.out.println(&quot;Implementation1.g()&quot;);
    &#125;

    @Override
    public void h() &#123;
        System.out.println(&quot;Implementation1.h()&quot;);
    &#125;

    @Override
    public void changeImp(StateBase newImp) &#123;
        //改变传入的参数，即改变private StateBase implementation字段的引用，以达到在代理对象的生命周期内从一个实现切换到另一种实现的目的
    &#125;
&#125;

class Implementation2 implements StateBase &#123;
    @Override
    public void f() &#123;
        System.out.println(&quot;Implementation2.f()&quot;);
    &#125;

    @Override
    public void g() &#123;
        System.out.println(&quot;Implementation2.g()&quot;);
    &#125;

    @Override
    public void h() &#123;
        System.out.println(&quot;Implementation2.h()&quot;);
    &#125;

    @Override
    public void changeImp(StateBase newImp) &#123;
    &#125;
&#125;

public class StateDemo &#123;
    static void test(StateBase b) &#123;
        b.f();
        b.g();
        b.h();
    &#125;

    public static void main(String[] args) &#123;
        StateBase b = new State(new Implementation1());
        test(b);
        b.changeImp(new Implementation2());//注意此时传入的对象
        test(b);
        b.changeImp(new Implementation1());
        test(b);
    &#125;
&#125;
/* Output:
Implementation1.f()
Implementation1.g()
Implementation1.h()
Implementation2.f()
Implementation2.g()
Implementation2.h()
Implementation1.f()
Implementation1.g()
Implementation1.h()
*/
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java设计模式" style=color:#607d8b>
                Java设计模式
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Javadm-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/Javadm-03/">
        <h2>
            代理模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>只要代理对象以某种方式代表具体实现的方法调用，那么基本思想就算实现了。而，拥有一个公共接口是很方便的，因此具体实现必须实现代理对象调用的所有方法。</p>
<pre><code class="java">// patterns/ProxyDemo.java
// Simple demonstration of the Proxy pattern
interface ProxyBase &#123;
    void f();

    void g();

    void h();
&#125;

class Proxy implements ProxyBase &#123;
    private ProxyBase implementation;//这是一个私有字段

    Proxy() &#123;
        implementation = new Implementation();//创建所代理类（Implementation）的对象
    &#125;
    /*覆盖方法并调用所代理类（Implementation）的方法*/
    @Override
    public void f() &#123; implementation.f(); &#125;
    @Override
    public void g() &#123; implementation.g(); &#125;
    @Override
    public void h() &#123; implementation.h(); &#125;
&#125;

class Implementation implements ProxyBase &#123;
    /*与代理类实现同一个接口,必须实现（覆盖）接口中所有方法哦/
    @Override
    public void f() &#123;
        System.out.println(&quot;Implementation.f()&quot;);
    &#125;
    @Override
    public void g() &#123;
        System.out.println(&quot;Implementation.g()&quot;);
    &#125;
    @Override
    public void h() &#123;
        System.out.println(&quot;Implementation.h()&quot;);
    &#125;
&#125;

public class ProxyDemo &#123;
    public static void main(String[] args) &#123;
        Proxy p = new Proxy();
        p.f();
        p.g();
        p.h();
    &#125;
&#125;
/*
Output:
Implementation.f()
Implementation.g()
Implementation.h()
*/
/*总结：
1.代理模式中通常代理类与被代理类实现一个公共接口利于交流。
2.在创建代理类对象的时，被代理类的对象也将同时创建（因为new被代理类写在代理类的构造器中）并为代理类的一个私有变量引用
3. so，想要调用被代理类的方法只需使用代理类 私有变量.被代理类的方法 （即在代理类中使用方法调用被代理类的方法）*/
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java设计模式" style=color:#016a99>
                Java设计模式
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/Javadm-03/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/c╓╕╒δ╡─┤½╡▌/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="c指针的传递"><a href="#c指针的传递" class="headerlink" title="c指针的传递"></a>c指针的传递</h1><h2 id="作为函数参数传递"><a href="#作为函数参数传递" class="headerlink" title="作为函数参数传递"></a>作为函数参数传递</h2><p>真正的传入一个指针到函数中</p>
<p><img src="http://img.lbkzw.cn/img/image-20210827171357110.png" alt="image-20210827171357110"></p>
<p>间接的传入指针到函数中</p>
<p><img src="http://img.lbkzw.cn/img/image-20210827171451818.png" alt="image-20210827171451818"></p>
<p>p1就是指针p，而p2是一个新的指针</p>
<p>以下分别为指针p、p1、p2的地址：</p>
<p><img src="http://img.lbkzw.cn/img/image-20210827171611554.png" alt="image-20210827171611554"></p>
<h2 id="作为变量传递"><a href="#作为变量传递" class="headerlink" title="作为变量传递"></a>作为变量传递</h2><ol>
<li>直接改变变量的值</li>
</ol>
<p><img src="http://img.lbkzw.cn/img/image-20210827172216274.png" alt="image-20210827172216274"></p>
<ol start="2">
<li>间接改变变量的值</li>
</ol>
<p>这里改变的是指针p2中存储的地址的值，而不是p2中所存储地址对应内存的值</p>
<p>举个例子：</p>
<p>目的：我们想将小明称为小红</p>
<p>做法：</p>
<ol>
<li>直接将将小明改名为小红，那么身份证上写的也是小红，但小明他还是那个小明。</li>
<li>直接找来了小红，说她是小明变的。</li>
</ol>
<p>做法1就是直接改变变量的值，做法2就是间接改变变量的值</p>
<p><img src="http://img.lbkzw.cn/img/image-20210827172151988.png" alt="image-20210827172151988"></p>
<p>测试程序：</p>
<pre><code class="c">/*
 * @Author: itThree
 * @Date: 2021-08-27 13:59:28
 * @LastEditTime: 2021-08-27 17:11:14
 * @Description: 
 * @FilePath: \cpp\testcpp\swapWithPointers.cpp
 * 光阴之逆旅，百代之过客，而已
 */
#include&lt;stdio.h&gt;

//传入指针p,参数int* &amp;p解析指针地址
//就是说传入的是真正的指针p
void testp1(int* &amp;p1)&#123;
    int num1 = 2020;
    //将p1地址对应内存下的值直接改变；
    *p1 = num1;
    printf(&quot;%d,%d,%d,%p\n&quot;,p1,*p1,num1,&amp;p1);


&#125;
//传入指针p,参数int* p初始化并指向传入的指针
//就是说初始化一个指针指向指针p所指向的东西
void testp2(int* p2)&#123;
   int num2 = 2019;
   //将p2指向num2的地址
   p2 = &amp;num2;
   printf(&quot;%d,%d,%d,%p\n&quot;,p2,*p2,num2,&amp;p2);

   &#125;
int main()&#123;
    // int x = 1;
    // int y = 2;
    // //传入x,y的地址，交换其值的位置
    // swapWithPointers(&amp;x,&amp;y);
    // printf(&quot;x=%d\ty=%d&quot;,x,y);
    int num = 2021;
    int* p = &amp;num;
    printf(&quot;初始值:\n&quot;);
    printf(&quot;%d,%d,%d,%p\n&quot;,p,*p,num,&amp;p);
    printf(&quot;经过test1:\n&quot;);
    testp1(p);
    printf(&quot;经过test2:\n&quot;);
    testp2(p);
    //从结果可以看出test1真正的改变了num的值，而test2仅是将指针指向了另一个地址
    printf(&quot;最终:\n&quot;);
    printf(&quot;%d,%d,%d,%p\n&quot;,p,*p,num,&amp;p);
    

    return 0;
&#125;
</code></pre>
<p>运行结果：</p>
<p><img src="http://img.lbkzw.cn/img/image-20210827172030142.png" alt="image-20210827172030142"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/c╓╕╒δ╡─┤½╡▌/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/java-mybatis-01/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>#基础支持层</p>
<h2 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h2><p>常见的三种解析方式： DOM SAX StAX</p>
<p>DOM整体将XML整体解析为树状样式</p>
<p>优点：便于获取数据，如在父子兄弟节点间切换很自然</p>
<p>缺点：占用资源较大</p>
<p>SAX基于事件模型的解析方式，解析时只将xml的一部分加载到内存，可在任一节点注册回调函数。</p>
<p>解析器解析到此节点（注册回调函数的节点）时会通过回调函数将事件发送给应用程序（推模式）</p>
<p>StAx同SAX将XML作为一个事件流处理，应用程序调用调用解析器进行解析，最后解析器返回结果</p>
<p>优点：占用资源小</p>
<p>缺点：只能向后单向进行无法支持XPath（查询XML文档）</p>
<pre><code class="java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.apache.ibatis.builder.xml;

import java.io.IOException;
import java.io.InputStream;
import java.util.Locale;
import org.apache.ibatis.io.Resources;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

public class XMLMapperEntityResolver implements EntityResolver &#123;
    ////mybatis-config文件与指定文件的SystemId
    private static final String IBATIS_CONFIG_SYSTEM = &quot;ibatis-3-config.dtd&quot;;
    private static final String IBATIS_MAPPER_SYSTEM = &quot;ibatis-3-mapper.dtd&quot;;
    private static final String MYBATIS_CONFIG_SYSTEM = &quot;mybatis-3-config.dtd&quot;;
    private static final String MYBATIS_MAPPER_SYSTEM = &quot;mybatis-3-mapper.dtd&quot;;
    //mybatis-config.xml文件位置
    private static final String MYBATIS_CONFIG_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;;
    //映射文件位置
    private static final String MYBATIS_MAPPER_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;;

    public XMLMapperEntityResolver() &#123;
    &#125;
    
    //查找指定的dtd文档调用getInputSource读取文档
    public InputSource resolveEntity(String publicId, String systemId) throws SAXException &#123;
        try &#123;
            if (systemId != null) &#123;
                //将传入的SystemId转为小写
                String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);
                
                if (lowerCaseSystemId.contains(&quot;mybatis-3-config.dtd&quot;) || lowerCaseSystemId.contains(&quot;ibatis-3-config.dtd&quot;)) &#123;
                    return this.getInputSource(&quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;, publicId, systemId);
                &#125;

                if (lowerCaseSystemId.contains(&quot;mybatis-3-mapper.dtd&quot;) || lowerCaseSystemId.contains(&quot;ibatis-3-mapper.dtd&quot;)) &#123;
                    return this.getInputSource(&quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;, publicId, systemId);
                &#125;
            &#125;

            return null;
        &#125; catch (Exception var4) &#123;
            throw new SAXException(var4.toString());
        &#125;
    &#125;
//读取dtd文档生成InputSource对象
    private InputSource getInputSource(String path, String publicId, String systemId) &#123;
        InputSource source = null;
        if (path != null) &#123;
            try &#123;
                InputStream in = Resources.getResourceAsStream(path);
                source = new InputSource(in);
                source.setPublicId(publicId);
                source.setSystemId(systemId);
            &#125; catch (IOException var6) &#123;
            &#125;
        &#125;

        return source;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/java-mybatis-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/hexo-01/">
        <h2>
            hexo for github的那些事情
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/hexo">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                hexo
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <blockquote>
<p>首先申明：本篇并非安装hexo的教程，而是本人安装hexo时遇到的一些问题及解决方案。<br><strong>一站式部署hexo教程：</strong><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a><br>本人操作均按hexo<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a>进行。<br>按官方文档来，问题会比按网上的帖子少的多，且你遇到的问题一定有人已经遇到过，百度搜索你遇到的错误就很容易解决</p>
</blockquote>
<h2 id="官方第一坑"><a href="#官方第一坑" class="headerlink" title="官方第一坑"></a>官方第一坑</h2><p>官方文档中用gh-pages分支，可是全程没有提到，仅仅用到的时候才提到，这个会出问题，不如从一开始就在gh-pages分支上进行</p>
<h3 id="创建gh-pages分支"><a href="#创建gh-pages分支" class="headerlink" title="创建gh-pages分支"></a>创建gh-pages分支</h3><p><strong>创建分支时主分支的版本库不能为空</strong></p>
<pre><code class="git">git init //创建本地库
git branch -v //查看分支
vim index.html //创建文件（为win10用户请自行手动创建一个文件，仅仅提交版本库用）
git add .
git branch gh-pages//创建分支
</code></pre>
<h2 id="官方第二坑"><a href="#官方第二坑" class="headerlink" title="官方第二坑"></a>官方第二坑</h2><p>文档没有明明白白的说<code>deploy:</code>的填写<br><code>_config.yml</code>中<code>deploy:</code>一定要填写好：</p>
<pre><code class="hexo">deploy:
  type: &#39;git&#39;
  repo: 你远程库的ssh地址
  branch: gh-pages//分支名
</code></pre>
<h2 id="hexo命令易懂叙述："><a href="#hexo命令易懂叙述：" class="headerlink" title="hexo命令易懂叙述："></a>hexo命令易懂叙述：</h2><pre><code class="hexo">hexo g //生成网页
hexo s //本地预览（部署网站到本地，测试用啦）
hexo d //部署网站到远程库
hexo clean //清除缓存（网页缓存）

hexo clean&amp;&amp;hexo g&amp;&amp;hexo s //连招，清除缓存生成网页并开启本地预览
hexo clean&amp;&amp;hexo g&amp;&amp;hexo d //连招，清除缓存生成网页并部署到远程库
</code></pre>
<h2 id="我用到的一些git命令："><a href="#我用到的一些git命令：" class="headerlink" title="我用到的一些git命令："></a>我用到的一些git命令：</h2><pre><code class="git">git add . //添加所有到版本库
git commit -m&quot;1&quot; //提交到本地库
git push blog gh-pages --force //本地库覆盖远程库
git config --global user.email xxx@163.com //本地标识
</code></pre>
<h2 id="我遇到的一些错误："><a href="#我遇到的一些错误：" class="headerlink" title="我遇到的一些错误："></a>我遇到的一些错误：</h2><p><code> 执行 hexo deploy 后,出现 error deployer not found:github 的错误</code><br><strong>解决方案：</strong><br><code>npm install hexo-deployer-git --save</code></p>
<p><strong>忘记遇到的什么问题了：</strong><code>npm install hexo-renderer-pug hexo-renderer-stylus </code></p>
<p>  ps：博客，电脑访问不了的话，可以换手机试试。最经网络老抽风无法访问github.io后缀的域名</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/hexo" style=color:#6484be>
                hexo
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/git" style=color:#6484be>
                git
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/github" style=color:#006674>
                github
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/hexo-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/javadm-04/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试时，程序运行的成功与否并不依靠返回值、打印语句来判断;通常我们使用断言而非print来展示返回值</p>
<pre><code class="java">Assert.assertEquals(-1,value)//预测变量value的值为-1
assert i &lt; 50:i;//断言i的值小于50（如i大于等于50将发生异常并返回实际i的值）
</code></pre>
<p>idea中运行结果为绿色就是运行成功，红色则失败。</p>
<p><code>@Before</code>在测试方法前自动执行，通常用来申请资源</p>
<p><code>@After</code>在测试方法后自动执行，通常用来释放资源</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote>
<pre><code class="java">import java.lang.annotation.*;
//元注解：对注解进行注解
@Target(ElementType.TYPE)//该注解可以被写在什么位置，取值如：类、方法、字段、包等
@Retention(RetentionPolicy.RUNTIME)//表明注解保留的时间段如：运行时即存入字节码并为JVM所接收、仅保留到字节码、保留到编译时（前）
@Documented//注解可以被抽取到javadoc文档中
@Inherited//该注解是否可以被继承

public @interface MyAnnotation &#123;
    String value();
    int a();

&#125;

@MyAnnotation(value = &quot;value&quot;,a=0)
public class MyAnnotationTest &#123;
&#125;
</code></pre>
<p> 用于描述注解的注解</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/20/javadm-04/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/20/js-02/">
        <h2>
            变量&&语法
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JS">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JS
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>函数体内局部变量优先级高于全局变量；</p>
<p>函数内的变量声明将提升至函数体顶部，同时在原位置完成初始化var声明；</p>
<p>在for循环中使用var声明变量时，该变量的作用域为for循环所属函数。</p>
<pre><code class="js"> var a=[];  
 for(var i = 0;i&lt;10;i++)&#123;  
     var q = i;  
    a[i]=function()&#123;console.log(q)&#125;  
 &#125;  
 a[0]()  
       
/*其中，由于for循环并不是一个函数体，所以for循环中定义的变量q和i是作用域for循环所在的函数体，和a同级，  
i++ 和  q=i 并不是重新定义变量，只是重复赋值，最终循环结束，i = 10,q=9; */ 
</code></pre>
<p>let声明的变量，只在let所在的代码块有效果</p>
<pre><code class="js">1.  var a=[];  
2.  for(let i = 0;i&lt;10;i++)&#123;  
3.     ley q = i;  
4.     a[i]=function()&#123;console.log(q)&#125;  
5.  &#125;  
6.  a[6]()    
//这里会输出   6  let声明的变量仅在块级作用域有效，所以这里的i只在本轮循环有效果，每次循环的i其实都是一个新的变量
</code></pre>
<h1 id="function-声明"><a href="#function-声明" class="headerlink" title="function 声明"></a>function 声明</h1><pre><code class="js">/*定义一个函数 */
//one:
function mysqrt(x)&#123;//使用此声明则函数名与函数初始化块均“提前”到脚本或函数的顶部
    return Math.sqrt(x*x);
    
&#125;
//two
var mysqrt = function(x)&#123;return Math.sqrt(x*x);&#125;//使用此声明则仅有变量声明“提前”到脚本或函数的顶部，初始化体仍在原来的位置
</code></pre>
<h1 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h1><ul>
<li>for-in 会跳过null、undefined</li>
<li>只遍历可枚举的（包含继承的属性名）</li>
</ul>
<pre><code class="js">/*使用for-in 变量数组元素 */
var o = &#123;x:1,y:2,z:3&#125;
var a = [],i = 0//声明一个数组与一个变量
for(a[i++]in o); 
</code></pre>
<h1 id="continue-break"><a href="#continue-break" class="headerlink" title="continue,break"></a>continue,break</h1><p>带标签的continue,break作用相同，均是跳转到指定循环（均不得跳转至所属函数边界，即所属函数外）</p>
<pre><code class="js">mainloop: while(token!=null)&#123;
    continue mainloop;
&#125;
mainloop: while(token!=null)&#123;
    break mainloop;//mainloop为自定义标记
&#125;
</code></pre>
<h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h1><p>检索对象列表，解析变量名</p>
<pre><code>
/*用于简化代码*/
with(document.forms[0])&#123;
    name.value=&quot;&quot;;
    address.value=&quot;&quot;;
    email.value=&quot;&quot;;
&#125;
/*简化前*/
var f = document.form[0];
f.name.value=&quot;&quot;;
f.address.value=&quot;&quot;;
f.email.value=&quot;&quot;;
</code></pre>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="严格相等"><a href="#严格相等" class="headerlink" title="===严格相等"></a>===严格相等</h2><ul>
<li>比较过程中没有类型的转换，两个值类型不同则其不等</li>
<li>值为null或undefined则其不等</li>
<li>均是相同的布尔值则相等</li>
<li>其中一个值为NaN则不等**</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><ul>
<li>值为null或undefined则其相等</li>
<li>两个不同类型的值转换后相等则其相等（如：true转换为1 false转换为0 再进行比较）</li>
</ul>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><ul>
<li>左操作数是一个字符串或可以转换为字符串，有操作数是一个对象</li>
<li>如右侧对象包含左侧操作数，表达式返回true</li>
</ul>
<pre><code class="js">var a = &#123;x:a&#125;
&quot;x&quot; in a; //true
</code></pre>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ul>
<li>如左侧对象是右侧类的实例，表达式将返回true</li>
</ul>
<pre><code class="js">var mynew = new Date();
mynew instanceof Date;//返回true
</code></pre>
<h1 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a>null、undefined</h1><ul>
<li>null是一个特殊对象（非对象），多用来表示字符串、数字、对象得无值。</li>
<li>undefined（未定义） 表示属性或元素不存在</li>
<li>===可区分null与undefined，而==则不行</li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code class="js">x+&quot;&quot;//等价于String(x)
+x//等价于Number(x)
!!x//等价于Boolean(x)
</code></pre>
<p><strong>对象向字符串转换</strong></p>
<p>有toString则通过此方法将其变为字符串，无toString则通过ValueOf，二者均无则报错。</p>
<p>空数组向数值转换结果为0</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul>
<li>throw 抛出异常</li>
</ul>
<pre><code class="js">try&#123;/*可能出现异常的代码*/&#125;
catch()&#123;/*对异常的处理*/&#125;
finally&#123;/*不管发不发生异常都执行的语句*/&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JS基础" style=color:#006674>
                JS基础
            </a>
        </span>
        
    </div>

    <a href="/2022/03/20/js-02/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/4/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <a href="/page/4/">
                <span class="page-num">
                    4
                </span>
            </a>
        </span>
        

        <span class="current">
            5
        </span>

        
        <span>
            <a href="/page/6/">
                <span class="page-num">
                    6
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/6/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>