
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || </title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.0.1"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ITthreeの博客</h1>
                <h3></h3>
                <h5>ITthreeの博客,我思故我在</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2020/10/16/Javadm-02/">
        <h2>
            单例模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>最简单的设计模式，它是一种仅提供一个对象实例的方法。</p>
<pre><code class="java">interface Resource &amp;#123;
    int getValue();
    void setValue(int x);
&amp;#125;

/*
* 由于这不是从Cloneable基类继承而且没有添加可克隆性，
* 因此将其设置为final可防止通过继承添加可克隆性。
* 这也实现了线程安全的延迟初始化：
*/
final class Singleton &amp;#123;
    private static final class ResourceImpl implements Resource &amp;#123;
        private int i;
        private ResourceImpl(int i) &amp;#123;//只有一个私有构造器供静态内部类调用
            this.i = i;
        &amp;#125;
        /*两个属性*/
        public synchronized int getValue() &amp;#123;
            return i;
        &amp;#125;
        public synchronized void setValue(int x) &amp;#123;
            i = x;
        &amp;#125;
    &amp;#125;

    private static class ResourceHolder &amp;#123;
        private static Resource resource = new ResourceImpl(47);
    &amp;#125;
    public static Resource getResource() &amp;#123;//此公共静态方法供外部调用，返回对象
        return ResourceHolder.resource;
    &amp;#125;
&amp;#125;

public class SingletonPattern &amp;#123;
    public static void main(String[] args) &amp;#123;
        Resource r = Singleton.getResource();
        System.out.println(r.getValue());
        Resource s2 = Singleton.getResource();
        s2.setValue(9);
        System.out.println(r.getValue());
        try &amp;#123;     
             // 不能这么做，会发生：compile-time error（编译时错误）.     
             // Singleton s3 = (Singleton)s2.clone();    
             &amp;#125; catch(Exception e) &amp;#123;      
                 throw new RuntimeException(e);    
             &amp;#125;  
        &amp;#125;
&amp;#125; /* Output: 47 9 */
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java设计模式" style=color:#016a99>
                Java设计模式
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Javadm-02/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Javadm-01/">
        <h2>
            状态模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>将代理对象在生命周期内从一个实现切换到另一种实现</p>
<pre><code class="java">package cn;
//patterns/StateDemo.java //状态模式的简单演示
interface StateBase &amp;#123;
    void f();

    void g();

    void h();

    void changeImp(StateBase newImp);
&amp;#125;
/**
 * 多个操作类，多个代理类;
 * 一个共同接口一脉相承，中途变法自家兄弟*/
class State implements StateBase &amp;#123;
    private StateBase implementation;

    State(StateBase imp) &amp;#123;
        implementation = imp;//引用new Implementation1() new Implementation2()
    &amp;#125;

    @Override
    public void changeImp(StateBase newImp) &amp;#123;
        implementation = newImp;
    &amp;#125;
     @Override
    public void f() &amp;#123;
         implementation.f();
    &amp;#125;

    @Override
    public void g() &amp;#123;
        implementation.g();
    &amp;#125;

    public void h() &amp;#123;
        implementation.h();
    &amp;#125;
&amp;#125;

class Implementation1 implements StateBase &amp;#123;
    @Override
    public void f() &amp;#123;
        System.out.println(&quot;Implementation1.f()&quot;);
    &amp;#125;

    @Override
    public void g() &amp;#123;
        System.out.println(&quot;Implementation1.g()&quot;);
    &amp;#125;

    @Override
    public void h() &amp;#123;
        System.out.println(&quot;Implementation1.h()&quot;);
    &amp;#125;

    @Override
    public void changeImp(StateBase newImp) &amp;#123;
        //改变传入的参数，即改变private StateBase implementation字段的引用，以达到在代理对象的生命周期内从一个实现切换到另一种实现的目的
    &amp;#125;
&amp;#125;

class Implementation2 implements StateBase &amp;#123;
    @Override
    public void f() &amp;#123;
        System.out.println(&quot;Implementation2.f()&quot;);
    &amp;#125;

    @Override
    public void g() &amp;#123;
        System.out.println(&quot;Implementation2.g()&quot;);
    &amp;#125;

    @Override
    public void h() &amp;#123;
        System.out.println(&quot;Implementation2.h()&quot;);
    &amp;#125;

    @Override
    public void changeImp(StateBase newImp) &amp;#123;
    &amp;#125;
&amp;#125;

public class StateDemo &amp;#123;
    static void test(StateBase b) &amp;#123;
        b.f();
        b.g();
        b.h();
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        StateBase b = new State(new Implementation1());
        test(b);
        b.changeImp(new Implementation2());//注意此时传入的对象
        test(b);
        b.changeImp(new Implementation1());
        test(b);
    &amp;#125;
&amp;#125;
/* Output:
Implementation1.f()
Implementation1.g()
Implementation1.h()
Implementation2.f()
Implementation2.g()
Implementation2.h()
Implementation1.f()
Implementation1.g()
Implementation1.h()
*/</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java设计模式" style=color:#016a99>
                Java设计模式
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Javadm-01/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-11/">
        <h2>
            1~4章
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="JavaBeans模式"><a href="#JavaBeans模式" class="headerlink" title="JavaBeans模式"></a>JavaBeans模式</h1><blockquote>
<p>当我们需要传入多个参数构造对象时（比如有时传入2个参数，有时传入20个参数），可采用“重叠构造器模式”即利用“重载”机制。</p>
<p>但如果需要传入的参数是2-2000个呢？</p>
<p>我们总不能复写2000个构造器吧。</p>
<p>我们可采用: <strong>JavaBeans模式</strong></p>
</blockquote>
<p>用一个无参数的构造器创建对象，然后通过多个set方法设置参数。</p>
<pre><code class="java">public class myJavaBeans &amp;#123;
    private int id;
    private String name;
    private String sex;
    /*更多字段省略*/
    public myJavaBeans() &amp;#123;
    &amp;#125;
    public void setId(int id) &amp;#123;
        this.id = id;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public void setSex(String sex) &amp;#123;
        this.sex = sex;
    &amp;#125;
&amp;#125;
</code></pre>
<p><em>这个方法模式存在线程安全</em></p>
<p>下面有一种Builder模式可保证线程安全</p>
<p><strong>Builder模式</strong></p>
<p>使用<strong>静态内部类</strong>（静态工厂方法）设置属性（参数），最后创建类（返回其父类的对象）完成对象初始化。</p>
<pre><code class="java">public class myBuilder &amp;#123;
    private int id;
    private String name;
    private String sex;

    public static class Builder  &amp;#123;//静态内部类只会被加载一次
        private int id;
        private String name;
        private String sex;

        public Builder() &amp;#123;
        &amp;#125;

        public Builder setId(int id) &amp;#123;
            this.id = id;
            return this;//返回this，用于实现链接式调用
        &amp;#125;

        public Builder setName(String name) &amp;#123;
            this.name = name;
            return this;
        &amp;#125;

        public Builder setSex(String sex) &amp;#123;
            this.sex = sex;
            return this;
        &amp;#125;
        //通过此方法返回内部类对象，此时内部类对象
        public myBuilder builder()&amp;#123;
            return new myBuilder(this);
        &amp;#125;
    &amp;#125;

    private myBuilder(Builder builder) &amp;#123;
        //构造器传入静态内部类builder对象，对myBuilder进行初始化。
        this.id = builder.id;
        this.name = builder.name;
        this.sex = builder.sex;
    &amp;#125;

    public static void main(String[] args) &amp;#123;
        myBuilder demoMyBuilder = new myBuilder.Builder().setId(0).setName(&quot;张三&quot;).setSex(&quot;男&quot;).builder();
        //此内部类的set方法返回其本身，故可以将多个set方法调用链接起来
        System.out.println(demoMyBuilder.sex);
        System.out.println(demoMyBuilder.id);
        System.out.println(demoMyBuilder.name);
    &amp;#125;
&amp;#125;
</code></pre>
<p>使用泛型构建任何对象</p>
<pre><code class="java">public interface Builder1&lt;T&gt; &amp;#123;
    public T build();
&amp;#125;</code></pre>
<h1 id="单例模式Singleton"><a href="#单例模式Singleton" class="headerlink" title="单例模式Singleton"></a>单例模式Singleton</h1><ol>
<li><p>仅设置一个私有构造器，使用公共的final静态字段构造对象。</p>
<pre><code class="java">
public class Elvis &amp;#123;
    public static final Elvis INSTANCE = new Elvis();//加载类时将自动创建对象
    private Elvis()&amp;#123;&amp;#125;
    public void leaveTheBuilding()&amp;#123;&amp;#125;
&amp;#125;</code></pre>
</li>
<li><p>通过静态工厂方法:设置一个私有构造器，一个私有final静态字段（构造对象），最后通过一个静态方法返回final静态字段。</p>
<pre><code class="java">class Elvis1&amp;#123;
    //1.字段私有化
    private static final Elvis1 INSTANCE = new Elvis1();
    //2.构造器私有化
    private Elvis1()&amp;#123;&amp;#125;
    //2.静态工厂方法返回对象引用
    public static Elvis1 getInstance()&amp;#123;return INSTANCE;&amp;#125;
    public void leaveTheBuilding()&amp;#123;&amp;#125;
&amp;#125;</code></pre>
</li>
</ol>
<h1 id="消除过期元素"><a href="#消除过期元素" class="headerlink" title="消除过期元素"></a>消除过期元素</h1><pre><code class="java">import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.EmptyStackException;

public class Stack &amp;#123;
    private Object[] elements;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private int size = 0;
    public Stack()&amp;#123;
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    &amp;#125;
    //动态数组
    private void ensureCapacity()&amp;#123;
        if (elements.length == size)&amp;#123;
            elements = Arrays.copyOf(elements,2*size+1);
        &amp;#125;
    &amp;#125;
    //添加元素
    public void push(Object e)&amp;#123;
        ensureCapacity();//先判断数组是否有空间（空间不足则扩展空间）
        elements[size++] = e;
    &amp;#125;

    //弹出元素
//    public Object pop()&amp;#123;
//        if (size == 0)&amp;#123;//栈为空抛出异常
//            throw new EmptyStackException();
//        &amp;#125;
//        return elements[--size];
//        //注意：即使连续使用多个pop()方法，经历--size的元素仍然存在于数组中
//    &amp;#125;
    public Object pop()&amp;#123;
        if (size == 0)&amp;#123;
            throw new EmptyStackException();
        &amp;#125;
        Object result = elements[--size];
        elements[size] = null;//将索引赋值为null，消除过期元素
        return result;
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="使类与成员的可访问性最小化"><a href="#使类与成员的可访问性最小化" class="headerlink" title="使类与成员的可访问性最小化"></a>使类与成员的可访问性最小化</h1><ol>
<li>创建类时不声明则默认为缺省即包访问级别，声明为protected时仅可被子类、同一包内的类访问。</li>
<li>子类覆盖父类方法时访问级别不得低于其父类</li>
</ol>
<p><strong>闭包性：public&lt;default（缺省级别，默认）&lt;protected&lt;private</strong></p>
<p>private与protected不能用来修饰类；</p>
<p>只有同一包内的另一个类迫切需要访问一个成员时，我们才会将private修改为protected。</p>
<h1 id="在公共类中使用访问方法而非公共-域"><a href="#在公共类中使用访问方法而非公共-域" class="headerlink" title="在公共类中使用访问方法而非公共 域"></a>在公共类中使用访问方法而非公共 域</h1><ol>
<li>将公共类字段私有化，通过set、get方法对其进行修改、访问。</li>
<li>可使用不可变的公共字段：<code>public final int ID;</code></li>
</ol>
<h1 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h1><ol>
<li><p>字段采用是<code> private final</code>修饰，提供创建新对象的方法而不提供修改的方法,修改时返回新对象。</p>
<pre><code class="java">public final class Complex &amp;#123;
    private final double re;
    private final double im;

    public Complex(double re, double im) &amp;#123;
        this.re = re;
        this.im = im;
    &amp;#125;
    public Complex add(Complex o)&amp;#123;//修改时返回新对象
        return new Complex(re-o.re,im+o.re);
    &amp;#125;
&amp;#125;</code></pre>
</li>
</ol>
<ol start="2">
<li><p>.字段采用是 <code>private final</code>修饰，有仅一个私有构造器，通过静态工厂方法返回对象</p>
<pre><code class="java">public final class Complex &amp;#123;
    private final double re;
    private final double im;

    private Complex(double re, double im) &amp;#123;
        this.re = re;
        this.im = im;
    &amp;#125;
    public static Complex valueOf(double re, double im)&amp;#123;
        return new Complex(re,im);
    &amp;#125;
&amp;#125;</code></pre>
</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/EffectiveJava" style=color:#6484be>
                EffectiveJava
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-11/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-10/">
        <h2>
            浅拷贝与深拷贝
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><blockquote>
<p>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。</p>
</blockquote>
<p>验证：</p>
<pre><code class="java">package com.data.test;

public class Students implements Cloneable&amp;#123;
    //clone()方法是protected修饰的，因此需要实现Cloneable接口才能调用，同时需要覆写clone()方法才能调用。
    private int id;
    private int age;
    private String name;
    private Teacher teacher;

    public Students(int id, int age, String name, Teacher teacher) &amp;#123;
        this.id = id;
        this.age = age;
        this.name = name;
        this.teacher = teacher;
    &amp;#125;

    public int getId() &amp;#123;
        return id;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public Teacher getTeacher() &amp;#123;
        return teacher;
    &amp;#125;

    public void setId(int id) &amp;#123;
        this.id = id;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public void setTeacher(Teacher teacher) &amp;#123;
        this.teacher = teacher;
    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;Students&amp;#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, teacher=&quot; + teacher +
                &#39;&amp;#125;&#39;;
    &amp;#125;
    @Override
    protected Object clone() throws CloneNotSupportedException &amp;#123;
            return super.clone();
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="java">package com.data.test;

public class Teacher &amp;#123;
    private String name;
    private String six;

    public Teacher(String name, String six) &amp;#123;
        this.name = name;
        this.six = six;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public String getSix() &amp;#123;
        return six;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public void setSix(String six) &amp;#123;
        this.six = six;
    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;Teacher&amp;#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, six=&#39;&quot; + six + &#39;\&#39;&#39; +
                &#39;&amp;#125;&#39;;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="java">package com.data.test;

public class TestObject &amp;#123;
    public static void main(String[] args) throws CloneNotSupportedException &amp;#123;
        var stu = new Students(01,20,&quot;张三&quot;,new Teacher(&quot;王五&quot;,&quot;男&quot;));
        var stuClone =(Students)stu.clone();
        /*判断此俩对象地址是否相同*/
        if (stu.equals(stuClone))&amp;#123;
            System.out.println(&quot;地址相同&quot;);
        &amp;#125;else System.out.println(&quot;地址不同&quot;);
        /*toString查看数据*/
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证浅拷贝不拷贝对象仅仅拷贝对象引用*/
        System.out.println(&quot;----------验证浅拷贝不拷贝对象仅仅拷贝对象引用-----------&quot;);
        var aT = stu.getTeacher();
        aT.setName(&quot;尼古拉斯&quot;);
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证浅拷贝会复制字段*/
        System.out.println(&quot;----------验证浅拷贝会复制字段-----------&quot;);
        stu.setId(2);
        System.out.println(stu);
        System.out.println(stuClone);
        /*修改数据*/
        System.out.println(&quot;----------通过改变引用的方式进行数据修改(不影响原始对象即被拷贝的对象)-----------&quot;);
        stu.setTeacher(new Teacher(&quot;李四&quot;,&quot;女&quot;));
        //即使在clone后，stu与stuClone引用的仍是同一个对象，故可以通过改变引用的方式进行数据修改
        System.out.println(stuClone);
        System.out.println(stu);
    &amp;#125;
&amp;#125;
</code></pre>
<p>运行结果：</p>
<img src="http://img.lbkzw.cn/img/20200927111340.png" alt="image-20200927111340317" style="zoom:50%;" />

<h1 id="对象的toString"><a href="#对象的toString" class="headerlink" title="对象的toString"></a>对象的toString</h1><p>未覆盖toString：</p>
<blockquote>
<p>打印的是该对象的地址</p>
</blockquote>
<img src="http://img.lbkzw.cn/img/20200927103720.png" alt="image-20200927103720635" style="zoom:50%;" />

<p>覆盖toString：</p>
<pre><code class="java">@Override
    public String toString() &amp;#123;
        return &quot;Students&amp;#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, teacher=&quot; + teacher +
                &#39;&amp;#125;&#39;;//teacher是一个对象的引用
    &amp;#125;</code></pre>
<img src="http://img.lbkzw.cn/img/20200927103948.png" alt="image-20200927103948710" style="zoom:50%;" />

<p>由于未覆盖teacher引用对象的toString，故打印出其引用对象的地址。</p>
<p>覆盖teacher引用对象的toString</p>
<pre><code class="java">@Override
    public String toString() &amp;#123;
        return &quot;Teacher&amp;#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, six=&#39;&quot; + six + &#39;\&#39;&#39; +
                &#39;&amp;#125;&#39;;
    &amp;#125;</code></pre>
<p>运行结果：</p>
<img src="http://img.lbkzw.cn/img/20200927104304.png" alt="image-20200927104304776" style="zoom:50%;" />

<h1 id="深度拷贝"><a href="#深度拷贝" class="headerlink" title="深度拷贝"></a>深度拷贝</h1><ol>
<li>为类重写原始类与克隆类的clone方法，实现其自我克隆：<br>这个缺点是：如果克隆类中也引用了一个对象则又需要对这个对象的类实现Cloneable接口并覆盖其clone方法，接着再克隆这个对象，周而复始，无往不利。</li>
</ol>
<pre><code class="java">/*Students类的clone*/
@Override
    protected Object clone() throws CloneNotSupportedException &amp;#123;
            var cloneStudents = (Students)super.clone();
            cloneStudents.teacher = (Teacher)teacher.clone();
            //对新克隆的Students对象中的元素即teacher引用的对象进行克隆。
            return cloneStudents;
    &amp;#125;



/*Teacher类的clone*/
@Override
    protected Object clone() throws CloneNotSupportedException &amp;#123;
        return super.clone();
    &amp;#125;
</code></pre>
<ol start="2">
<li>利用序列化：</li>
</ol>
<p>一个用来序列化的类</p>
<pre><code class="java">package com.data.test;

import java.io.*;

public class Copy implements Serializable &amp;#123;
    private static final long serialVersionUID = 1L;
    protected &lt;T&gt;T copy() throws IOException, ClassNotFoundException &amp;#123;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);
        /*反序列化*/
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return (T) ois.readObject();

    &amp;#125;
&amp;#125;
</code></pre>
<p>原始类与克隆类继承copy类（用于序列化操作）</p>
<pre><code class="java">public class Students extends Copy&amp;#123;...&amp;#125;
public class Teacher extends Copy&amp;#123;...&amp;#125;</code></pre>
<pre><code class="java">package com.data.test;

import java.io.IOException;

public class TestObject &amp;#123;
    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &amp;#123;
        var stu = new Students(01,20,&quot;张三&quot;,new Teacher(&quot;王五&quot;,&quot;男&quot;));
        Students stuClone =stu.copy();
        /*判断此俩对象地址是否相同*/
        if (stu.equals(stuClone))&amp;#123;
            System.out.println(&quot;地址相同&quot;);
        &amp;#125;else System.out.println(&quot;地址不同&quot;);
        /*toString查看数据*/
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证拷贝对象*/
        System.out.println(&quot;----------验证拷贝对象-----------&quot;);
        var aT = stu.getTeacher();
        aT.setName(&quot;尼古拉斯&quot;);
        System.out.println(stuClone);
        System.out.println(stu);
        /*验证复制字段*/
        System.out.println(&quot;----------验证复制字段-----------&quot;);
        stu.setId(2);
        System.out.println(stu);
        System.out.println(stuClone);
    &amp;#125;
&amp;#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-10/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-09/">
        <h2>
            IO流
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="流的分类："><a href="#流的分类：" class="headerlink" title="流的分类："></a>流的分类：</h2><p>操作数据单位：字节流、字符流<br>数据的流向：输入流、输出流<br>流的角色：节点流、处理流</p>
<h2 id="流的体系结构"><a href="#流的体系结构" class="headerlink" title="流的体系结构"></a>流的体系结构</h2><h3 id="整体结构体系"><a href="#整体结构体系" class="headerlink" title="整体结构体系"></a>整体结构体系</h3><img src="http://img.lbkzw.cn/img/20200830171143.png" alt="2020-08-30" style="zoom: 67%;" />


<h3 id="主要流"><a href="#主要流" class="headerlink" title="主要流"></a>主要流</h3><table>
<thead>
<tr>
<th><strong>抽象基类</strong></th>
<th><strong>节点流（或文件流）</strong></th>
<th><strong>缓冲流（处理流的一种）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream</td>
<td>FileInputStream   (read(byte[] buffer))</td>
<td>BufferedInputStream (read(byte[] buffer))</td>
</tr>
<tr>
<td>OutputStream</td>
<td>FileOutputStream  (write(byte[] buffer,0,len)</td>
<td>BufferedOutputStream (write(byte[] buffer,0,len) / flush()</td>
</tr>
<tr>
<td>Reader</td>
<td>FileReader (read(char[] cbuf))</td>
<td>BufferedReader (read(char[] cbuf) / readLine())</td>
</tr>
<tr>
<td>Writer</td>
<td>FileWriter (write(char[] cbuf,0,len)</td>
<td>BufferedWriter (write(char[] cbuf,0,len) / flush()</td>
</tr>
</tbody></table>
<h1 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h1><blockquote>
<p>直接作用于文件</p>
</blockquote>
<h2 id="字符流：FileReader与FileWriter"><a href="#字符流：FileReader与FileWriter" class="headerlink" title="字符流：FileReader与FileWriter"></a>字符流：FileReader与FileWriter</h2><pre><code class="java">  @Test
    public void testFileReaderFileWriter() &amp;#123;
        FileReader fr = null;//为完美关闭流提供条件。
        //由下方代码得出：代码执行到finally时，若未创建流且变量fr为非null值，则将引起异常（为创建流而关闭流）
        FileWriter fw = null;
        try &amp;#123;
            //1.创建File类的对象，指明读入和写出的文件
            File srcFile = new File(&quot;hello.txt&quot;);
            File destFile = new File(&quot;hello2.txt&quot;);

            //不能使用字符流来处理图片等字节数据
//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);
//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);


            //2.创建输入流和输出流的对象
            fr = new FileReader(srcFile);
            fw = new FileWriter(destFile);


            //3.数据的读入和写出操作
            char[] cbuf = new char[5];
            int len;//记录每次读入到cbuf数组中的字符的个数
            while((len = fr.read(cbuf)) != -1)&amp;#123;//从流fr中将 cbuf.length 个字节的数据读入一个 char 数组中
//直到因到达流末尾而返回 -1时停止循环。
                fw.write(cbuf,0,len);

            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //4.关闭流资源
            //方式一：
//            try &amp;#123;
//                if(fw != null)
//                    fw.close();
//            &amp;#125; catch (IOException e) &amp;#123;
//                e.printStackTrace();
//            &amp;#125;finally&amp;#123;
//                try &amp;#123;
//                    if(fr != null)
//                        fr.close();
//                &amp;#125; catch (IOException e) &amp;#123;
//                    e.printStackTrace();
//                &amp;#125;
//            &amp;#125;
            //方式二：
            try &amp;#123;
                if(fw != null)//确定创建了流
                    fw.close();
            &amp;#125; catch (IOException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;

            try &amp;#123;
                if(fr != null)
                    fr.close();
            &amp;#125; catch (IOException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;

        &amp;#125;

    &amp;#125;</code></pre>
<h2 id="字节流：FileInputStream与FileOutputStream"><a href="#字节流：FileInputStream与FileOutputStream" class="headerlink" title="字节流：FileInputStream与FileOutputStream"></a>字节流：FileInputStream与FileOutputStream</h2><p>对于文本文件(.txt,.java,.c,.cpp…)，使用字符流处理;</p>
<p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理。</p>
<pre><code class="java">@Test                                                                    
public void testFileInputStream() &amp;#123;                                      
    FileInputStream fis = null;                                          
    try &amp;#123;                                                                
        //1. 造文件                                                         
        File file = new File(&quot;hello.txt&quot;);                               

        //2.造流                                                           
        fis = new FileInputStream(file);                                 
         /*1、2这样写也可以fis = new FileInputStream(&quot;hello.txt&quot;);会自动包裹*/                                                               
        //3.读数据                                                          
        byte[] buffer = new byte[5];  //这是个byte数组哦
        //由于中文在utf-8编码中占用3个字节（最高占用到6个字节），而每次读入5个字节可能发生乱码
        int len;//记录每次读取的字节的个数                                           
        while((len = fis.read(buffer)) != -1)&amp;#123;                           

            String str = new String(buffer,0,len); //通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。                      
            System.out.print(str);                                       

        &amp;#125;                                                                
    &amp;#125; catch (IOException e) &amp;#123;                                            
        e.printStackTrace();                                             
    &amp;#125; finally &amp;#123;                                                          
        if(fis != null)&amp;#123;                                                 
            //4.关闭资源                                                     
            try &amp;#123;                                                        
                fis.close();                                             
            &amp;#125; catch (IOException e) &amp;#123;                                    
                e.printStackTrace();                                     
            &amp;#125;                                                            

        &amp;#125;                                                                
    &amp;#125;                                                                    

&amp;#125;                                                                        </code></pre>
<h1 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h1><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>作用于流，在流外再包裹一层流。</p>
<p>BufferedInputStream会一次性从文件中读取8192个(8Kb),存在缓冲区中,直到缓冲区装满了,才重新从文件中读取下一个8192个字节数组;</p>
<p>不会直接写到文件,先写到缓冲区中直到缓冲区写满,BufferedOutputStream才会把缓冲区中的数据一次性写到文件里;</p>
<p><code>flush()</code>刷新缓冲区，可以强制将缓冲区的内容全部写入输出流;close()方法关闭带缓冲流的流时，会自动刷新缓冲区后再关闭流。</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><pre><code class="java"> @Test
    public void testBufferedReaderBufferedWriter()&amp;#123;
        BufferedReader br = null;
        BufferedWriter bw = null;
        try &amp;#123;
            //创建文件和相应的流
            br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;)));
            bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;)));

            //读写操作
            //方式一：使用char[]数组
//            char[] cbuf = new char[1024];
//            int len;
//            while((len = br.read(cbuf)) != -1)&amp;#123;
//                bw.write(cbuf,0,len);
//    //            bw.flush();
//            &amp;#125;

            //方式二：使用String
            String data;
            while((data = br.readLine()) != null)&amp;#123;
                //方法一：
//                bw.write(data + &quot;\n&quot;);//data中不包含换行符
                //方法二：
                bw.write(data);//data中不包含换行符
                bw.newLine();//提供换行的操作

            &amp;#125;


        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //关闭资源
            if(bw != null)&amp;#123;

                try &amp;#123;
                    bw.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
            if(br != null)&amp;#123;
                try &amp;#123;
                    br.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;

    &amp;#125;</code></pre>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h3><pre><code class="java">@Test
    public void BufferedStreamTest()&amp;#123;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try &amp;#123;
            //1.造文件
            File srcFile = new File(&quot;爱情与友情.jpg&quot;);
            File destFile = new File(&quot;爱情与友情3.jpg&quot;);
            //2.造流
            //2.1 造节点流
            FileInputStream fis = new FileInputStream((srcFile));
            FileOutputStream fos = new FileOutputStream(destFile);
            //2.2 造缓冲流
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);

            //3.复制的细节：读取、写入
            byte[] buffer = new byte[10];
            int len;
            while((len = bis.read(buffer)) != -1)&amp;#123;
                bos.write(buffer,0,len);

//                bos.flush();//刷新缓冲区，可以强制将缓冲区的内容全部写入输出流

            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //4.资源关闭
            //要求：先关闭外层的流，再关闭内层的流
            if(bos != null)&amp;#123;
                try &amp;#123;
                    bos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if(bis != null)&amp;#123;
                try &amp;#123;
                    bis.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
//        fos.close();
//        fis.close();
        &amp;#125;
    &amp;#125;</code></pre>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>提供字节流与字符流之间的转换</p>
<pre><code class="java">package com.atguigu.java;

import org.junit.Test;

import java.io.*;

/**
 * 处理流之二：转换流的使用
 * 1.转换流：属于字符流
 *   InputStreamReader：将一个字节的输入流转换为字符的输入流
 *   OutputStreamWriter：将一个字符的输出流转换为字节的输出流
 *
 * 2. 解码：字节、字节数组  ---&gt;字符数组、字符串
 *    编码：字符数组、字符串 ---&gt; 字节、字节数组
 *
 *
 * 3.字符集
 *ASCII：美国标准信息交换码。
    用一个字节的7位可以表示。
 ISO8859-1：拉丁码表。欧洲码表
    用一个字节的8位表示。
 GB2312：中国的中文编码表。最多两个字节编码所有字符
 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。
 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。

 *
 *
 * @author shkstart
 * @create 2019 下午 4:25
 */
public class InputStreamReaderTest &amp;#123;

    /*
    此时处理异常的话，仍然应该使用try-catch-finally
    InputStreamReader的使用，实现字节的输入流到字符的输入流的转换
     */
    /*
    此时处理异常的话，仍然应该使用try-catch-finally

    综合使用InputStreamReader和OutputStreamWriter
     */

    @Test
    public void test1()  &amp;#123;
    FileInputStream fis = null;
    //在js中我们知道，catch也具有局部作用域，因此照本方法处理异常需要将引用流的变量在全局作用域声明
        // （方法中的变量不会默认初始化为null，需要手动处理）
    InputStreamReader isr =null;

        try &amp;#123;
            fis = new FileInputStream(&quot;dbcp.txt&quot;);
//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集
            //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集
            isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//使用系统默认的字符集

            char[] cbuf = new char[20];
            int len;
            while((len = isr.read(cbuf)) != -1)&amp;#123;
                String str = new String(cbuf,0,len);
                System.out.print(str);
            &amp;#125;

        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if (isr!=null)&amp;#123;
                try &amp;#123;
                    isr.close();
                &amp;#125;catch (IOException e)&amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;

        &amp;#125;

    &amp;#125;
    @Test
    public void test2()&amp;#123;
        InputStreamReader isr = null;
        OutputStreamWriter osw = null;
        try &amp;#123;
            FileInputStream fis = new FileInputStream(new File(&quot;dbcp.txt&quot;));
            FileOutputStream fos = new FileOutputStream(new File(&quot;dbcp_gbk.txt&quot;));

            isr = new InputStreamReader(fis,&quot;utf-8&quot;);
            osw = new OutputStreamWriter(fos,&quot;gbk&quot;);

            //2.读写过程
            char[] cbuf = new char[20];
            int len;
            while((len = isr.read(cbuf)) != -1)&amp;#123;
                osw.write(cbuf,0,len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;

            //3.关闭资源
            if (isr!=null)&amp;#123;
                try &amp;#123;
                    isr.close();
                &amp;#125;catch (IOException e)&amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if (isr!=null)&amp;#123;
                try &amp;#123;
                    osw.close();
                &amp;#125;catch (IOException e)&amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><blockquote>
<p>将对象序列化为二进制流便于在网络中传输</p>
</blockquote>
<p>序列化:用ObjectOutputStream类保存基本类型数据或对象的机制<br>反序列化:用ObjectInputStream类读取基本类型数据或对象的机制</p>
<p>可序列化的类必须实现以下接口任意一个：</p>
<ul>
<li><p>Serializable</p>
<p>实现Serializable接口的类都有一个表示序列化版本标识符的静态变量:<code>private static final long serialVersionUID;</code><br>serialVersionUID用来进行版本控制;如果类没有显示定义这个静态常量,它的值是Java运行时环境根据类的内部细节自<br>动生成的;若类的实例变量做了修改,serialVersionUID 可能发生变化。</p>
</li>
<li><p>Externalizable</p>
</li>
</ul>
<pre><code class="java">import java.io.Serializable;

/**
 * Person需要满足如下的要求，方可序列化
 * 1.需要实现接口：Serializable
 * 2.当前类提供一个全局常量：serialVersionUID
 * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性
 *   也必须是可序列化的。（默认情况下，基本数据类型可序列化）
 *
 *
 * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
 *
 *
 * @author shkstart
 * @create 2019 上午 10:38
 */
/*一个将用以序列化的类*/
public class Person implements Serializable&amp;#123;//实现接口：Serializable

    public static final long serialVersionUID = 475463534532L;//全局常量：serialVersionUID

    private String name;
    private int age;
    private int id;
    private Account acct;

    public Person(String name, int age, int id) &amp;#123;
        this.name = name;
        this.age = age;
        this.id = id;
    &amp;#125;

    public Person(String name, int age, int id, Account acct) &amp;#123;
        this.name = name;
        this.age = age;
        this.id = id;
        this.acct = acct;
    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &quot;Person&amp;#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, id=&quot; + id +
                &quot;, acct=&quot; + acct +
                &#39;&amp;#125;&#39;;
    &amp;#125;

    public int getId() &amp;#123;
        return id;
    &amp;#125;

    public void setId(int id) &amp;#123;
        this.id = id;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;

    public Person(String name, int age) &amp;#123;

        this.name = name;
        this.age = age;
    &amp;#125;

    public Person() &amp;#123;

    &amp;#125;
&amp;#125;

class Account implements Serializable&amp;#123;
    public static final long serialVersionUID = 4754534532L;
    private double balance;

    @Override
    public String toString() &amp;#123;
        return &quot;Account&amp;#123;&quot; +
                &quot;balance=&quot; + balance +
                &#39;&amp;#125;&#39;;
    &amp;#125;

    public double getBalance() &amp;#123;
        return balance;
    &amp;#125;

    public void setBalance(double balance) &amp;#123;
        this.balance = balance;
    &amp;#125;

    public Account(double balance) &amp;#123;

        this.balance = balance;
    &amp;#125;
&amp;#125;
/*序列化操作开始*/
@Test
    public void testObjectOutputStream()&amp;#123;
        ObjectOutputStream oos = null;

        try &amp;#123;
            //1.
            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));
            //2.
            oos.writeObject(new String(&quot;我爱北京天安门&quot;));
            oos.flush();//刷新操作

            oos.writeObject(new Person(&quot;王铭&quot;,23));
            oos.flush();

            oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000)));
            oos.flush();

        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if(oos != null)&amp;#123;
                //3.
                try &amp;#123;
                    oos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;

    &amp;#125;

    /*
    反序列化：将磁盘文件中的对象还原为内存中的一个java对象
    使用ObjectInputStream来实现
     */
    @Test
    public void testObjectInputStream()&amp;#123;
        ObjectInputStream ois = null;
        try &amp;#123;
            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();//注意之前创建的是Person的对象
            Person p1 = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p);
            System.out.println(p1);

        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (ClassNotFoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if(ois != null)&amp;#123;
                try &amp;#123;
                    ois.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;
    &amp;#125;</code></pre>
<h1 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h1><blockquote>
<p>可读可写、可盐可甜</p>
</blockquote>
<p><code>public RandomAccessFile(File file, String mode)</code><br><code>public RandomAccessFile(String name, String mode)</code><br>创建 RandomAccessFile 类实例需要指定一个 mode 参数,该参数指定 RandomAccessFile 的访问模式:</p>
<ol>
<li>r: 以只读方式打开</li>
<li>rw:打开以便读取和写入</li>
<li>rwd:打开以便读取和写入;同步文件内容的更新</li>
<li>rws:打开以便读取和写入;同步文件内容和元数据的更新</li>
</ol>
<p>如果模式为只读r。则不会创建文件,而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 </p>
<p>如果模式为rw读写，如果文件不存在则会去创建文件。</p>
<pre><code class="java">   @Test
    public void test1() &amp;#123;

        RandomAccessFile raf1 = null;
        RandomAccessFile raf2 = null;
        try &amp;#123;
            //1.
            raf1 = new RandomAccessFile(&quot;爱情与友情.jpg&quot;,&quot;r&quot;);
            raf2 = new RandomAccessFile(new File(&quot;爱情与友情12.jpg&quot;),&quot;rw&quot;);
            //2.
            byte[] buffer = new byte[1024];
            int len;
            while((len = raf1.read(buffer)) != -1)&amp;#123;
                raf2.write(buffer,0,len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //3.
            if(raf1 != null)&amp;#123;
                try &amp;#123;
                    raf1.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if(raf2 != null)&amp;#123;
                try &amp;#123;
                    raf2.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;
    &amp;#125;
/*插入数据*/
    @Test
    public void test2() throws IOException &amp;#123;

        RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);

        raf1.seek(3);//将指针调到角标为3的位置
        raf1.write(&quot;xyz&quot;.getBytes());//使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组
        raf1.close();

    &amp;#125;</code></pre>
<h1 id="字节流实现图片加密解密"><a href="#字节流实现图片加密解密" class="headerlink" title="字节流实现图片加密解密"></a>字节流实现图片加密解密</h1><pre><code class="java">package com.atguigu.exer;

import org.junit.Test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author shkstart
 * @create 2019 下午 4:08
 */
public class PicTest &amp;#123;

    //图片的加密
    @Test
    public void test1() &amp;#123;

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try &amp;#123;
            fis = new FileInputStream(&quot;爱情与友情.jpg&quot;);
            fos = new FileOutputStream(&quot;爱情与友情secret.jpg&quot;);

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) &amp;#123;
                //字节数组进行修改
                //错误的
                //            for(byte b : buffer)&amp;#123;
                //                b = (byte) (b ^ 5);
                //            &amp;#125;
                //正确的
                for (int i = 0; i &lt; len; i++) &amp;#123;
                    buffer[i] = (byte) (buffer[i] ^ 5);
                &amp;#125;


                fos.write(buffer, 0, len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if (fos != null) &amp;#123;
                try &amp;#123;
                    fos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if (fis != null) &amp;#123;
                try &amp;#123;
                    fis.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;


    &amp;#125;


    //图片的解密
    @Test
    public void test2() &amp;#123;

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try &amp;#123;
            fis = new FileInputStream(&quot;爱情与友情secret.jpg&quot;);
            fos = new FileOutputStream(&quot;爱情与友情4.jpg&quot;);

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) &amp;#123;
                //字节数组进行修改
                //错误的
                //            for(byte b : buffer)&amp;#123;
                //                b = (byte) (b ^ 5);
                //            &amp;#125;
                //正确的
                for (int i = 0; i &lt; len; i++) &amp;#123;
                    buffer[i] = (byte) (buffer[i] ^ 5);
                &amp;#125;

                fos.write(buffer, 0, len);
            &amp;#125;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            if (fos != null) &amp;#123;
                try &amp;#123;
                    fos.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
            if (fis != null) &amp;#123;
                try &amp;#123;
                    fis.close();
                &amp;#125; catch (IOException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;

            &amp;#125;
        &amp;#125;


    &amp;#125;
&amp;#125;</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-09/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2020/10/16/Java-08/">
        <h2>
            Java泛型
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/Java">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                Java
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>泛型是编译时泛型，用于检查类型安全以及类型推断，虚拟机运行时已经被擦除；</p>
<p>泛型的类型参数T在编译后为Object类型；</p>
<p>泛型方法能使方法独立于类而产生变化。</p>
<h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><pre><code class="java">/**泛型类*/
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&amp;#123; 
    //key这个成员变量的类型为T由实例化时指定  
    private T key;

    public Generic(T value) &amp;#123; //只有方法所在类声明了T泛型类，那么成员方法才可接收一个T类型的参数
        this.key = value;
    &amp;#125;

    public T getKey()&amp;#123; //这只是类中一个普通的成员方法，只不过其返回值是同泛型类T一样的类型
        //如为public F getKey()，将发生异常
        return key;
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><pre><code class="JAVA">/**泛型接口*/
//我们可以为接口传入无数个实参，形成无数种类型的Generator接口。
//定义一个泛型接口
public interface Generator&lt;T&gt; &amp;#123;
    public T next();
&amp;#125;

 //类实现泛型接口时，需将泛型的声明也一起加到类中
 //即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&amp;#123;
 //如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;。
class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&amp;#123;
    @Override
    public T next() &amp;#123;
        return null;
    &amp;#125;
&amp;#125;</code></pre>
<h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><pre><code class="java">/**泛型方法*/
//在泛型类中声明了一个泛型方法，使用泛型E，E可以为任意类型，可与方法所在类的类型相同，也可以不同。
//如下：这是一个泛型T的类，它有一个泛型E的泛型方法，这个泛型方法接收并返回一个E类型的参数（类型由实例决定）
public class Test1 &lt;T&gt; &amp;#123;
    public &lt;E&gt; E function1(E a)&amp;#123; return  a;&amp;#125;
&amp;#125;

 //    1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。
 //    2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,
  IllegalAccessException&amp;#123;
        T instance = tClass.newInstance();
        return instance;
&amp;#125;
/*  public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&amp;#123;
       为T的泛型接收一个为E的形参，这将发生异常
    &amp;#125;  */</code></pre>
<h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><p>当操作类型时，不需要使用类型的具体功能而只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p>
<p><strong>？</strong>和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>
<pre><code class="java">//’？’是类型实参，而不是类型形参 
public void showKeyValue1(Generic&lt;?&gt; obj)&amp;#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&amp;#125;</code></pre>
<h1 id="要使静态方法接收泛型参数则必须将其写为泛型方法"><a href="#要使静态方法接收泛型参数则必须将其写为泛型方法" class="headerlink" title="要使静态方法接收泛型参数则必须将其写为泛型方法"></a>要使静态方法接收泛型参数则必须将其写为泛型方法</h1><pre><code class="java">public class StaticGenerator&lt;T&gt; &amp;#123;

     //如：public static void show(T t)&amp;#123;..&amp;#125;,此时编译器会提示错误信息：
      //    &quot;StaticGenerator cannot be refrenced from static context&quot;

    public static &lt;T&gt; void show(T t)&amp;#123;

    &amp;#125;
&amp;#125;</code></pre>
<h1 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h1><p><strong>泛型的上下边界添加，必须与泛型的声明在一起</strong> </p>
<pre><code class="java">/*只准传入某种类型的父类或；只准传入某种类型的子类。*/
public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&amp;#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&amp;#125;
/**泛型类的边界限定*/
public class Generic&lt;T extends Number&gt;&amp;#123;
    private T key;

    public Generic(T key) &amp;#123;
        this.key = key;
    &amp;#125;

    public T getKey()&amp;#123;
        return key;
    &amp;#125;
&amp;#125;
/**泛型方法的边界限定*/
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&amp;#123;
    System.out.println(&quot;container key :&quot; + container.getKey());
    T test = container.getKey();
    return test;
&amp;#125;</code></pre>
<h1 id="限定"><a href="#限定" class="headerlink" title="限定"></a>限定</h1><ol>
<li>一个类如果没有限定类型，那么虚拟机将会使用Object对其类型进行替换</li>
<li>如果限定了类型，则将类型替换为限定的类型</li>
<li>如限定多个类型，则默认替换为第一个限定类型</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java基础" style=color:#6484be>
                Java基础
            </a>
        </span>
        
    </div>

    <a href="/2020/10/16/Java-08/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/4/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <a href="/page/4/">
                <span class="page-num">
                    4
                </span>
            </a>
        </span>
        

        <span class="current">
            5
        </span>

        

    </div>

    <div class="next">
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="../images/icon.jpg " alt="头像">
        </div>
        <div class="name">
            ITthree
        </div>
        <div class="descriptions">
            
            <div class="description">
                待到山花烂漫时，她在丛中笑~
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/main2035">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://lbkzw.cn">
                    导航页面
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>