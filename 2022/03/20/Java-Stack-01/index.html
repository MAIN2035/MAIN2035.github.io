
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITthreeの博客 || Stack,Queue,Tree</title>
    <meta name="author" content="ITthree">
    <meta name="description" content="ITthreeの博客,我思故我在 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/../images/icon.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ITthreeの博客</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories/ubuntu">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags/shell">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>ITthreeの博客</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories/ubuntu">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags/shell">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Stack,Queue,Tree </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/20
        </span>

        
        <span class="category">
            <a href="/categories/dataStructure">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                dataStructure
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java" style=color:#6484be>
                    Java
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <pre><code class="mermaid">graph LR

A[扫描输入] --&gt;B&#123;是否为运算符&#125;

    B --&gt; |是运算符| C&#123;运算符栈是否为空&#125;
    B --&gt;|是数值| D&#123;判断是否为多位数&#125;
    D --&gt;|是多位| J[扫描到运算符为止]
    J --&gt; K
    D --&gt;|是个位| K[压入数值栈]
    C --&gt;|为空| E[将运算符压入栈]
    C --&gt;|不为空| F&#123;比较运算符优先级&#125;
    F --&gt;|优先级高于栈顶| G[入栈]
    F --&gt;|优先级低于栈顶| H[弹出运算符栈与数值栈中元素]
    H --&gt;|进行计算| I[将计算结果与比较优先级的运算符分别入栈]
    O[中缀表达式算法]
   
</code></pre>
<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>方法：为每个运算符旁的数值加括号如:<code>a+b*c; </code>改为<code> (a+(b*c))</code>，再将运算符移到括号外，得到后缀表达式<code> abc*+</code></p>
<p>转为算法：</p>
<ol>
<li>新建运算符栈，从左至右扫描，</li>
<li>运算符栈空时直接入栈，不为空则比较优先级，优先级大于时直接入栈，等于或小于时先（原栈顶元素）出栈，（档期元素）再入栈</li>
<li>到达末尾（即扫描完毕时），弹出所有运算符并追加到表达式末尾</li>
</ol>
<p>后缀表达式求值：遇到符号弹出数值进行求值（数值优先处于符号右方）</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="数组实现："><a href="#数组实现：" class="headerlink" title="数组实现："></a>数组实现：</h2><pre><code class="java">package com.pdf.data;

import org.junit.Test;

public class ArrayStack &#123;
    /*字段分别为：栈大小、模拟栈的数组、栈顶*/
    private int maxsize;
    private int[] stack;
    private int top = -1;
    public ArrayStack(int maxsize)&#123;
        this.maxsize = maxsize;
        stack = new int[this.maxsize];
    &#125;
    /*The stack is full*/
    public boolean isFull()&#123;
        return top+1 == maxsize;
    &#125;
    /*The stack is void*/
    public boolean isEmpty()&#123;
        return top == -1;
    &#125;
    /*Press-in data*/
    public void push(int value)&#123;
        if (isFull())&#123;
            System.out.println(&quot;Stack fill&quot;);
            return;
        &#125;
        top++;
        stack[top]=value;
    &#125;
    /*Pop-up data*/
    public int pop()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;Stack Void&quot;);
        &#125;
        int value = stack[top];
        top--;
        return value;
    &#125;
    /*print Stack*/
    public void list()&#123;
        if (isEmpty())&#123;
            System.out.println(&quot;Stack void&quot;);
            return;
        &#125;
        for (int i=top;i&gt;=0;i--)&#123; System.out.printf(&quot;stack[%d]=%d\n&quot;,i,stack[i]);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        var mStack = new ArrayStack(100);
        for (int i = 1; i &lt; 101; i++) &#123;
            assert i &lt; 50:i;//断言
            mStack.push(i);
        &#125;
        mStack.list();

    &#125;
&#125;
</code></pre>
<h2 id="链表实现："><a href="#链表实现：" class="headerlink" title="链表实现："></a>链表实现：</h2><pre><code class="java">package com.abstrast.data.stack;

import java.util.EmptyStackException;

/*链表实现栈*/
public final class LinkedStack&lt;T&gt; implements StackInterface&lt;T&gt; &#123;
    private Node topNode;//指向栈顶
    public LinkedStack()&#123;
        topNode = null;
    &#125;
    /*节点类*/
    private class Node&#123;
        private T data;
        private Node next;
        Node(T newEntry,Node topNode)&#123;
            data = newEntry;
            next = topNode;

        &#125;

        public Node getNextNode() &#123;
            return next;
        &#125;

        public T getData() &#123;
            return data;
        &#125;
    &#125;
    @Override
    public void push(T newEntry) &#123;
//        Node newNode = new Node(newEntry,topNode);
//        topNode = newNode;
        topNode = new Node(newEntry,topNode);// 压入数据时直接指向栈顶
    &#125;

    @Override
    public T pop() &#123;
        T top = peek();
        topNode = topNode.getNextNode();
        return top;
    &#125;

    @Override
    public T peek() &#123;//查看栈顶元素
       if(isEmpty())
           throw new EmptyStackException();
       else
           return topNode.getData();
    &#125;

    @Override
    public boolean isEmpty() &#123;
        return topNode ==null;//顶栈为null则为空
    &#125;

    @Override
    public void clear() &#123;//没有顶栈则栈为空
        topNode = null;

    &#125;

//    public static void main(String[] args) &#123;
//        var a = new LinkedStack&lt;String&gt;();
//        a.push(&quot;a&quot;);
//        a.push(&quot;b&quot;);
//        a.push(&quot;c&quot;);
//        a.push(&quot;d&quot;);
//        a.peek();
//        a.pop();
//        a.peek();
//    &#125;
&#125;
</code></pre>
<h2 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h2><pre><code class="java">import java.util.Iterator;
/**
 * 这是一个动态数组栈*/

public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;&#123;//实现Iterable&lt;Item&gt;接口后可以使用foreach遍历
    private Item[] a = (Item[]) new Object[1];//栈元素数量，通过强制类型转换Object数组实现泛型号=数组
    private int N = 0;//元素数量
    public boolean isEmpty()&#123;
        return N == 0;
    &#125;
    public int size()&#123;
        return N;
    &#125;
    /*实现动态数组*/
    private void resize(int max)&#123;
        Item[] temp = (Item[]) new Object[max];//创建空间大小为2倍的新数组
        for (int i = 0; i &lt; N; i++)&#123;//复制数组元素
            temp[i] = a[i];
        &#125;
        a = temp;
    &#125;
    public void push(Item item)&#123;
        if (N == a.length)resize(2*a.length);//数组存储空间不足，则扩大为2倍
        a[N++] = item;//每次添加元素N+1
    &#125;
    public Item pop()&#123;
        Item item = a[--N];
        a[N] = null;//防止游离元素，即不在栈中，但仍存在于数组中的元素
        if (N &gt; 0&amp;&amp;N == a.length/4)resize(a.length/2);//如果该数组仅仅占用1/4,那么缩小它
        return item;
    &#125;
    public Iterator&lt;Item&gt; iterator()&#123;//实现了一个迭代器
        return new ReverseArrayIterator();
    &#125;
    private class ReverseArrayIterator implements Iterator&lt;Item&gt;&#123;
        private int i = N;
        public boolean hasNext()&#123;return  i &gt; 0;&#125;
        public Item next()&#123;return a[--i];&#125;//next即越过并返回这个元素，
        // 数组下标从0开始，而数组中只要存在元素那么数量便从1开始，故需要减1（否则下标N下的元素不存在则返回null）
        public void remove()&#123;&#125;
    &#125;

    public static void main(String[] args) &#123;
        long startTime = System.currentTimeMillis(); // 获取开始时间
        var a = new ResizingArrayStack&lt;String&gt;();
        for (int i = 0; i &lt; 1000000; i++) &#123;
            a.push(&quot;abc&quot;+i);
        &#125;
        for (String s: a)
            System.out.println(s);
        long endTime = System.currentTimeMillis(); // 获取结束时间
        System.out.println(&quot;程序运行时间： &quot; + (endTime - startTime) + &quot;ms&quot;);


    &#125;
&#125;
</code></pre>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h2><pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue &lt;T&gt;implements Iterable&lt;T&gt;&#123;
    /**分析：
     * 队列实现需包含：队列长度、头指针，尾指针、结点类。
     *功能:增、删、清空查看队列、队列有无、查看队列头元素
     * 迭代：队列类实现可迭代接口Iterable&lt;T&gt;，再由内部类实现迭代器。
     */
    private int length;
    private Node head,tail;

    /*节点类*/
    private class Node&lt;T&gt;&#123;
        private T data;
        private Node next;

        Node(T data) &#123;
            this.data = data;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;Node(&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &#39;)&#39;;
        &#125;
    &#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&#123;
//        return length!=0;也可以哦
        return head == null;
    &#125;
    /*添加元素*/
    private void enqueue(T x)&#123;
        if (isEmpty())&#123;
            tail = head = new Node&lt;T&gt;(x);
            length++;
        &#125;else &#123;
            tail = tail.next = new Node&lt;T&gt;(x);//尾指针与与原尾结点均指向新结点
            length++;
        &#125;
    &#125;
    /*删除元素*/
    public T dequeue()&#123;
        if (isEmpty())&#123;
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &#125;else&#123;
            T returnValue = (T) head.data;
            head = head.next;
            length--;
            return returnValue;
        &#125;
    &#125;
    /*清空队列*/
    public void makeEmpty()&#123;
        head=tail=null;
        length=0;
    &#125;

    /*返回头元素*/
    public T getHead() throws Exception &#123;
        if (isEmpty())&#123;
            throw new Exception(&quot;队列无数据&quot;);
        &#125;else&#123;
            return (T) head.data;
        &#125;
    &#125;
    /*查看队列中所有元素*/
    public void showQueue()&#123;
        Node head =this.head;//引用head便于进行遍历
        while (head.next!=null)&#123;
            System.out.println(head.data);
            head=head.next;
        &#125;
        System.out.println(head.data);

    &#125;
    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&#123;
        private Node current = head;
        public boolean hasNext() &#123;
            return current != null;
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &#125;

        public T next() &#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;
            current = current.next;
            return item;
        &#125;

    &#125;

    @Override
    public String toString() &#123;
        return &quot;ListQueue&#123;&quot; +
                &quot;length=&quot; + length +
                &quot;, head=&quot; + head +
                &quot;, tail=&quot; + tail +
                &#39;&#125;&#39;;
    &#125;

    /*测试*/
    public static void main(String[] args) throws Exception &#123;
        var a = new ListQueue&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &#123;//添加元素
            a.enqueue(i);
        &#125;
        for (int i: a) &#123;
            System.out.println(i);

        &#125;
      //覆盖toString只为了更直观的查看队列
        System.out.println(a+&quot;&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="数组模拟队列-amp-amp-单例模式"><a href="#数组模拟队列-amp-amp-单例模式" class="headerlink" title="数组模拟队列&amp;&amp;单例模式"></a>数组模拟队列&amp;&amp;单例模式</h2><pre><code class="java">import org.junit.Test;

public class ArrayQueue &#123;

    private static int maxsize;
    /*分别创建最大容量、头指针、尾指针、数组*/
    private int front = -1;
    private int rear = -1;
    private int[] arr;
    private static ArrayQueue MYARRAYQUEUE;
    private ArrayQueue(int maxsize)&#123;
        this.maxsize = maxsize;
        arr = new int[maxsize];
    &#125;
    /*队列是否为满*/
    public boolean isFull()&#123;
        return rear == maxsize-1;//因为尾、头部指针开始均指向-1，故容量减1为满
    &#125;
    /*队列是否为空*/
    public boolean isEmpty()&#123;
        return rear  == front;
    &#125;
    /*添加数据到队列*/
    public void addQueue(int n)&#123;
       if (isFull())&#123;
           System.out.println(&quot;挤挤总会有的？？？&quot;);
           return;
       &#125;
       arr[++rear]=n;// 写入尾部
    &#125;
    public static synchronized ArrayQueue getArrayQueue(int a)&#123;
        if(null != MYARRAYQUEUE)return MYARRAYQUEUE;
        maxsize = a;
        MYARRAYQUEUE = new ArrayQueue(a);
        return MYARRAYQUEUE;
    &#125;

    public void showQueue() &#123;
        var a = ArrayQueue.getArrayQueue(maxsize);
        // 遍历
        if (isEmpty()) &#123;
            System.out.println(&quot;队列空的，没有数据~~&quot;);
            return;
        &#125;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);
        &#125;
    &#125;
&#125;
class RunArrayQueue extends Thread&#123;
    @Override
    public void run() &#123;
        var a = ArrayQueue.getArrayQueue(4);
        a.showQueue();
        a.addQueue(4);
        a.addQueue(5);
        a.addQueue(6);
        a.showQueue();
    &#125;

    public static void main(String[] args) &#123;
        var a = new RunArrayQueue();
        var b = new RunArrayQueue();
        a.start();
        b.start();
    &#125;
&#125;
</code></pre>
<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><pre><code class="java">public class CircleArrayQueue &#123;
    private static int maxsize;
    /*分别创建最大容量、头指针、尾指针、数组*/
    private int front = 0;
    private int rear = 0;
    private int[] arr;

    private CircleArrayQueue(int maxsize) &#123;
        this.maxsize = maxsize;
        arr = new int[maxsize];
    &#125;

    /*队列是否为满*/
    public boolean isFull() &#123;
        return (rear + 1) % maxsize == front;
        //无论指针怎么移动，rear总与最后一个元素间隔一格
    &#125;

    /*队列是否为空*/
    public boolean isEmpty() &#123;
        return rear == front;
    &#125;

    /*添加数据到队列*/
    public void addQueue(int n) &#123;
        if (isFull()) &#123;
            System.out.println(&quot;挤挤总会有的？？？&quot;);
            return;
        &#125;
        arr[rear] = n;
        rear = (rear + 1) % maxsize;
    &#125;

    /*取出数据*/
    public int getQueue() &#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;队列为空你币没了&quot;);
        &#125;
        int value = arr[front];
        front = (front + 1)%maxsize;
        return value;

    &#125;
    /*打印队列*/
    public void showQueue() &#123;
        // 遍历
        if (isEmpty()) &#123;
            System.out.println(&quot;队列空的，没有数据~~&quot;);
            return;
        &#125;
        for (int i = 0; i &lt; front + size(); i++) &#123;
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i%maxsize, arr[i%maxsize]);
        &#125;
    &#125;
    public int size()&#123;
        return (rear + maxsize -front)%maxsize;
    &#125;
    //显示队列头信息
    public int headQueue()&#123;
        if (isEmpty())&#123;
            throw new RuntimeException(&quot;队列为空&quot;);
        &#125;
        return arr[front];
    &#125;

    public static void main(String[] args) &#123;
       var a = new CircleArrayQueue(10);
    &#125;
&#125;

</code></pre>
<h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><h3 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h3><pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue2&lt;T&gt;implements Iterable&lt;T&gt;&#123;
    /**双向队列不带头结点
     */
    private int length;
    private Node head,tail;

    /*节点类*/
    private class Node&lt;T&gt;&#123;
        private T data;
        private Node next;
        private Node prev;

        Node(T data) &#123;
            this.data = data;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;Node&#123;&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &quot;, prev=&quot; + prev +
                    &#39;&#125;&#39;;
        &#125;
    &#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&#123;
//        return length==0;也可以哦
        return head == null;
    &#125;
    /*队头添加元素*/
    private void addHead(T x)&#123;
        if (isEmpty())&#123;
            tail = head = new Node(x);
            length++;
            &#125;
        else &#123;
            Node newNode = head;//指向原head指向的首结点
            head = new Node(x);//将head指向添加的新结点
            //head.prev=null;类中的成员字段会自动初始化为null，故不必设置新首结点prev=null
            head.next = newNode;//将新结点的next指向原首节点
            newNode.prev = head;//原首结点的prev指向新结点
            length++;//队列长度+1
        &#125;
    &#125;
    /*队尾添加元素*/
    private void addTail(T x)&#123;
        if (isEmpty())&#123;
            tail = head = new Node(x);
            length++;
        &#125;
        else &#123;
            Node newNode = tail;
            tail = new Node(x);
            //tail.next=null;类中的成员字段会自动初始化为null，故不必设置新尾结点next=null
            newNode.next = tail;//原尾结点的next指向新结点
            tail.prev=newNode;//新结点的prev指向原尾结点
            length++;
        &#125;
    &#125;

    /*队头删除元素*/
    public T removeHead()&#123;
        if (isEmpty())&#123;//队列无元素抛出异常
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &#125;else&#123;
            T returnValue = (T) head.data;
            head = head.next;
            length--;
            //如果删除时队列中只存在一个元素则head=null，否则令首节点的prev=null
            if (length==0)&#123;
                tail=head=null;
            &#125;else &#123;
                head.prev=null;
            &#125;
            return returnValue;
        &#125;
    &#125;
    /*队尾删除元素*/
    public T removeTail()&#123;
        if (isEmpty())&#123;
            throw new UnsupportedOperationException(&quot;队列无数据&quot;);
        &#125;else&#123;
            T returnValue = (T) tail.data;
            tail = tail.prev;
            length--;
            if (length==0)&#123;
                tail=head=null;
            &#125;else &#123;
                tail.next=null;
            &#125;
            return returnValue;//返回被删除结点的值
        &#125;
    &#125;
    /*清空队列*/
    public void makeEmpty()&#123;
        head=tail=null;
        length=0;
    &#125;

    /*返回头元素*/
    public T getHead() throws Exception &#123;
        if (isEmpty())&#123;
            throw new Exception(&quot;队列无数据&quot;);
        &#125;else&#123;
            return (T) head.data;
        &#125;
    &#125;
    /*查看队列中所有元素*/
    public void showQueue()&#123;
        Node head =this.head;//引用head便于进行遍历
        while (head.next!=null)&#123;
            System.out.println(head.data);
            head=head.next;
        &#125;
        System.out.println(head.data);

    &#125;
    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&#123;
        private ListQueue2.Node current = head;//指向首结点
        public boolean hasNext() &#123;
            return current != null;
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &#125;

        public T next() &#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;//存储当前结点中的值
            current = current.next;//更新指针，指向下一个结点
            return item;//返回当前结点中的值
        &#125;

    &#125;

    @Override
    public String toString() &#123;
        return &quot;ListQueue&#123;&quot; +
                &quot;length=&quot; + length +
                &quot;, head=&quot; + head +
                &quot;, tail=&quot; + tail +
                &#39;&#125;&#39;;
    &#125;

    /*测试*/
    public static void main(String[] args) throws Exception &#123;
        var a = new ListQueue2&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &#123;//添加元素
            a.addHead(i);
            a.removeTail();
        &#125;a.removeTail();
        for (int i: a) &#123;
            System.out.println(i);

        &#125;
      //覆盖toString只为了更直观的查看队列
        System.out.println(a+&quot;&quot;);
    &#125;
&#125;

</code></pre>
<p>###带头结点</p>
<pre><code class="java">package cn.three.cloth.queue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListQueue3&lt;T&gt;implements Iterable&lt;T&gt;&#123;
    /**双向队列带头结点的
     * 引入一个头结点nil， 初始化时nil的prev和next分别指向自身。用于判断队列是否为空
     * 加入新元素以后只需要操作新增节点，nil 和 nil的下一个节点。
     */
    private int length;
    private Node headNode;


    /*节点类*/
    private class Node&lt;T&gt;&#123;
        private T data;
        private Node next;
        private Node prev;
        //使用了默认结点构造器

        @Override
        public String toString() &#123;
            return &quot;Node&#123;&quot; +
                    &quot;data=&quot; + data +
                    &quot;, next=&quot; + next +
                    &quot;, prev=&quot; + prev +
                    &#39;&#125;&#39;;
        &#125;
    &#125;
    public ListQueue3()&#123;
        headNode = new Node();
        headNode.next = headNode;
        headNode.prev = headNode;
    &#125;
    /*判断队列是否为空*/
    private boolean isEmpty()&#123;
//        return length==0;也可以哦
        return headNode.next == headNode;
    &#125;
    /*队头添加元素
    * 添加的所有元素都将位于头结点之后*/
    private void addHead(T x)&#123;
            Node newNode = new Node();//创建新结点
            newNode.data=x;
            //以下操作顺序不能颠倒
            //先将新结点的前驱为头结点，后继为头结点的原后继
            newNode.prev=headNode;
            newNode.next=headNode.next;
            //再将头结点的原后继的前驱、改为新结点
            headNode.next.prev=newNode;
            headNode.next=newNode;//最后将头结点的后继为新结点

            length++;//队列长度+1

    &#125;
    /*队尾添加元素
    * 添加的所有元素都将位于头结点之前*/
    private void addTail(T x)&#123;
        Node newNode = new Node();//创建新结点
        newNode.data=x;
        newNode.next=headNode;//新结点的后继为头结点
        //以下操作顺序不能颠倒
        newNode.prev=headNode.prev;//现将新结点的前驱为头结点的前驱
        headNode.prev.next=newNode;//再将头结点前驱的后继为新结点
        headNode.prev=newNode;//最后将头结点前驱改为新结点
        length++;//队列长度+1

    &#125;

    /*队头删除元素*/
    public T removeHead()&#123;
        if (isEmpty())
            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);
        Node del = headNode.next;//指向将要删除的结点
        T retunValue = (T) del.data;
        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点
        del.next.prev = headNode;
        headNode.next = del.next;
        length--;
        return retunValue;
    &#125;
    /*队尾删除元素*/
    public T removeTail()&#123;
        if (isEmpty())
            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);
        Node del = headNode.prev;//指向将要删除的结点
        T retunValue = (T) del.data;
        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点
        del.prev.next=headNode;
        headNode.prev=del.prev;
        length--;
        return retunValue;
    &#125;
    /*清空队列*/
    public void makeEmpty()&#123;
        headNode.next=null;
        length=0;
    &#125;

    /*迭代器*/
    @Override
    public Iterator&lt;T&gt; iterator() &#123;
        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象
    &#125;
    private class DequeueIterator implements Iterator&lt;T&gt;&#123;
        private ListQueue3.Node current = headNode.next;//指向头结点
        public boolean hasNext() &#123;
            return current != headNode;
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException(
                    &quot;remove is not supported!&quot;);
        &#125;

        public T next() &#123;
            if (!hasNext())
                throw new NoSuchElementException();
            T item = (T) current.data;//存储当前结点中的值
            current = current.next;//更新指针，指向下一个结点
            return item;//返回当前结点中的值
        &#125;

    &#125;





    /*测试*/
    public static void main(String[] args) throws Exception &#123;
        var a = new ListQueue3&lt;Integer&gt;();//创建队列
        for (int i = 0; i &lt; 10; i++) &#123;
            a.addTail(i);
        &#125;a.removeHead();
        for (int i: a) &#123;
            System.out.println(i);

        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树结点类：</p>
<pre><code class="java">package cn.three.cloth.Tree;
/**
 * 二叉树结点类*/
public class Node&lt;T&gt;&#123;
    private int no;
    private T element;
    private Node left;
    private Node right;

    public Node(int no, T element) &#123;
        this.no = no;
        this.element = element;
    &#125;

    public int getNo() &#123;
        return no;
    &#125;

    public T getElement() &#123;
        return element;
    &#125;

    public Node getLeft() &#123;
        return left;
    &#125;

    public Node getRight() &#123;
        return right;
    &#125;

    public void setNo(int no) &#123;
        this.no = no;
    &#125;

    public void setElement(T element) &#123;
        this.element = element;
    &#125;

    public void setLeft(Node left) &#123;
        this.left = left;
    &#125;

    public void setRight(Node right) &#123;
        this.right = right;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Node&#123;&quot; +
                &quot;no=&quot; + no +
                &quot;, element=&quot; + element +&quot;&#125;&quot;;
    &#125;

    /*前、中、后序遍历开始*/
    //前序遍历
    public void preOrder()&#123;
        System.out.println(this);
        if (this.left != null)&#123;
            this.left.preOrder();
        &#125;
        if (this.right != null)&#123;
            this.right.preOrder();
        &#125;
    &#125;
    //中序遍历
    public void infixOrder()&#123;
        if (this.left != null)&#123;
            this.left.infixOrder();
        &#125;
        System.out.println(this);
        if (this.right != null)&#123;
            this.right.infixOrder();
        &#125;
    &#125;
    //后序遍历
    public void postOrder()&#123;
        if (this.left != null)&#123;
            this.left.postOrder();
        &#125;
        if (this.right != null)&#123;
            this.right.postOrder();
        &#125;
        System.out.println(this);
    &#125;

    /*前、中、后序查找开始*/
    //前序查找、
    public Node preOrderSearch(int no)&#123;
        if (this.no == no)&#123;
            return this;
        &#125;
        Node resNode = null;
        if (this.left != null)&#123;
            resNode = this.left.preOrderSearch(no);
        &#125;
        if (resNode != null)&#123;
            return resNode;
        &#125;
        if (this.right != null)&#123;
            resNode = this.right.preOrderSearch(no);
        &#125;
        return resNode;
    &#125;
    //中序查找
    public Node infixOrderSearch(int no)&#123;
        Node resNode = null;
        if (this.left != null)&#123;
            resNode = this.left.infixOrderSearch(no);
        &#125;
        if (resNode != null)&#123;
            return resNode;
        &#125;
        if (this.no == no)&#123;
            return this;
        &#125;
        if (this.right != null)&#123;
            resNode = this.right.infixOrderSearch(no);
        &#125;
        return resNode;
    &#125;
    //后序查找
    public Node postOrderSearch(int no)&#123;
        Node resNode = null;
        if (this.left != null)&#123;
            resNode = this.left.postOrderSearch(no);
        &#125;
        if (resNode != null)&#123;
            return resNode;
        &#125;
        if (this.right != null)&#123;
            resNode = this.right.postOrderSearch(no);
        &#125;
        if (this.no == no)&#123;
            return this;
        &#125;
        return resNode;
    &#125;
    /*删除结点*/
    public void delNode(int no)&#123;
        //判断当前结点的左、右结点是否为要删除结点
        if (this.left !=null &amp;&amp; this.left.no == no)&#123;
            this.left = null;
            return;
        &#125;
        if (this.right !=null &amp;&amp; this.right.no == no)&#123;
            this.right = null;
            return;
        &#125;
        //··左、右递归删除
        if (this.left != null)&#123;
            this.left.delNode(no);
        &#125;;
        if (this.right != null)&#123;
            this.right.delNode(no);
        &#125;;


    &#125;

&#125;
</code></pre>
<p>二叉树：</p>
<pre><code class="java">
package cn.three.cloth.Tree;
/**
 * 二叉树*/
public class BinaryTree1 &#123;
    private Node root;

    public void setRoot(Node root) &#123;
        this.root = root;
    &#125;
/*前、中、后序遍历*/
    public void preOrder()&#123;
        if (this.root != null)&#123;
            this.root.preOrder();
        &#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &#125;

    public void infixOrder()&#123;
        if (this.root != null)&#123;
            this.root.infixOrder();
        &#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &#125;

    public void postOrder()&#123;
        if (this.root != null)&#123;
            this.root.postOrder();
        &#125;else System.out.println(&quot;当前二叉树为空&quot;);
    &#125;
    /*前、中、后序遍历*/
    public Node preOrderSearch(int no)&#123;
        if (root != null)&#123;
            return root.preOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    public Node infixOrderSearch(int no)&#123;
        if (root != null)&#123;
            return root.infixOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    public Node postOrderSearch(int no)&#123;
        if (root != null)&#123;
            return root.postOrderSearch(no);
        &#125;else &#123;
            return null;
        &#125;
    &#125;
    public void delNode(int no)&#123;
        if (root != null)&#123;//该树不为空树
            if (root.getNo() == no)&#123;//该树根结点是否为目标结点
                root = null;
            &#125;else &#123;
                root.delNode(no);//递归删除（Node类中的）以此结点为根结点。沿着左结点遍历查询删除，如未找到则再沿着根结点的右结点遍历查询
            &#125;
        &#125;else &#123;
            System.out.println(&quot;该树为空！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组<img src="https://i.loli.net/2020/09/13/qRFTifeoytCw1c6.png"></h1><pre><code class="java">
public class SparseArray &#123;

    public static void main(String[] args) &#123;
        // 创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;
        // 输出原始的二维数组
        System.out.println(&quot;原始的二维数组~~&quot;);
        for (int[] row : chessArr1) &#123;
            for (int data : row) &#123;
                System.out.printf(&quot;%d\t&quot;, data);
            &#125;
            System.out.println();
        &#125;

        // 将二维数组 转 稀疏数组的思路
        // 1. 先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int i = 0; i &lt; 11; i++) &#123;
            for (int j = 0; j &lt; 11; j++) &#123;
                if (chessArr1[i][j] != 0) &#123;
                    sum++;
                &#125;
            &#125;
        &#125;

        // 2. 根据非0数据个数再加一（记录总行、列、有效值个数）创建对应的稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        
        // 遍历二维数组，将非0的值存放到 sparseArr中
        int count = 0; //count 用于记录是第几个非0数据
        for (int i = 0; i &lt; 11; i++) &#123;
            for (int j = 0; j &lt; 11; j++) &#123;
                if (chessArr1[i][j] != 0) &#123;
                    count++;
                    sparseArr[count][0] = i;//行
                    sparseArr[count][1] = j;//列
                    sparseArr[count][2] = chessArr1[i][j];//值
                &#125;
            &#125;
        &#125;
        
        // 输出稀疏数组的形式
        System.out.println();
        System.out.println(&quot;得到稀疏数组为~~~~&quot;);
        for (int i = 0; i &lt; sparseArr.length; i++) &#123;
            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        &#125;
        System.out.println();
        
        //将稀疏数组 --》 恢复成 原始的二维数组
        /*
         *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]
            2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
         */
        
        //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
        
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        
        //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可
        
        for(int i = 1; i &lt; sparseArr.length; i++) &#123;
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        &#125;
        
        // 输出恢复后的二维数组
        System.out.println();
        System.out.println(&quot;恢复后的二维数组&quot;);
        
        for (int[] row : chessArr2) &#123;
            for (int data : row) &#123;
                System.out.printf(&quot;%d\t&quot;, data);
            &#125;
            System.out.println();
        &#125;
    &#125;

&#125;
</code></pre>

    </div>

    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 ITthreeの博客
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @ITthree
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>