<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2022/03/20/PriorityQueue/"/>
      <url>2022/03/20/PriorityQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><p>插入元素</p><pre><code class="java"> //代理方法public boolean add(E e) &#123;        return offer(e);    &#125;//目标方法    public boolean offer(E e) &#123;        //添加元素为null时抛出异常，添加结束        if (e == null)            throw new NullPointerException();        modCount++;        //            int i = size;        //这段扩容代码...        //数组满了便调用grow()扩容，size+1        if (i &gt;= queue.length)            grow(i + 1);        size = i + 1;        //数组为空便直接插入，否则进行上浮操作        if (i == 0)            queue[0] = e;        else            //上浮            siftUp(i, e);        return true;    &#125;private void grow(int minCapacity) &#123;        int oldCapacity = queue.length;        // Double size if small; else grow by 50%        //原数组大小小于64便扩容到其2倍+2，否则扩容百分之50        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?                                         (oldCapacity + 2) :                                         (oldCapacity &gt;&gt; 1));            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)            newCapacity = hugeCapacity(minCapacity);        queue = Arrays.copyOf(queue, newCapacity);    &#125;   private static int hugeCapacity(int minCapacity) &#123;        if (minCapacity &lt; 0) // overflow            throw new OutOfMemoryError();        return (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    &#125;</code></pre><p>曾经的写法</p><pre><code class="java">//siftUp()private void siftUp(int k, E x) &#123;    while (k &gt; 0) &#123;        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2        Object e = queue[parent];        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法            break;        queue[k] = e;        k = parent;    &#125;    queue[k] = x;&#125;</code></pre><p>现在的写法</p><pre><code class="java">  private void siftUp(int k, E x) &#123;        if (comparator != null)            siftUpUsingComparator(k, x);        else            siftUpComparable(k, x);    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    private void siftUpComparable(int k, E x) &#123;        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;        while (k &gt; 0) &#123;            int parent = (k - 1) &gt;&gt;&gt; 1;            Object e = queue[parent];            if (key.compareTo((E) e) &gt;= 0)                break;            queue[k] = e;            k = parent;        &#125;        queue[k] = key;    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    private void siftUpUsingComparator(int k, E x) &#123;        while (k &gt; 0) &#123;            int parent = (k - 1) &gt;&gt;&gt; 1;            Object e = queue[parent];            if (comparator.compare(x, (E) e) &gt;= 0)                break;            queue[k] = e;            k = parent;        &#125;        queue[k] = x;    &#125;</code></pre><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)    public E peek() &#123;        return (size == 0) ? null : (E) queue[0];    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>anaconda入门</title>
      <link href="2022/03/20/Python-1/"/>
      <url>2022/03/20/Python-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>安装不做介绍，下载链接<a href="https://anaconda.en.softonic.com/">https://anaconda.en.softonic.com/</a></p></blockquote><ol><li>环境命令：</li></ol><p>创建一个名称为python37的虚拟环境并指定python版本为3.7 ：</p><pre><code class="python">conda  create -n python37 python=3.7</code></pre><p>查看环境：<code>conda info --envs</code></p><p>激活某个环境：<code>conda activate python34</code></p><ol start="2"><li>包命令</li></ol><p>安装包：<code>conda install package_name</code></p><p>卸载包：<code>conda remove pandas</code></p><p>更新包：<code>conda update package_name</code></p><ol start="3"><li>Pycharm 配置anaconda</li></ol><p>File -&gt; Settings<br><img src="http://img.lbkzw.cn/img/20190105173256159.png" alt="20190105173256159"></p><p><img src="http://img.lbkzw.cn/img/20190105173419992.png" alt="20190105173419992"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/Spring%20Boot%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/"/>
      <url>2022/03/20/Spring%20Boot%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot</p><p>Spring Boot 是一个快速开发框架，可以迅速搭建出一套基于 Spring 框架体系的应用，是 Spring Cloud 的基础。</p><p>Spring Boot 开启了各种自动装配，从而简化代码的开发，不需要编写各种配置文件，只需要引入相关依赖就可以迅速搭建一个应用。</p><ul><li>特点</li></ul><p>1、不需要 web.xml</p><p>2、不需要 springmvc.xml</p><p>3、不需要 tomcat，Spring Boot 内嵌了 tomcat</p><p>4、不需要配置 JSON 解析，支持 REST 架构</p><p>5、个性化配置非常简单</p><ul><li>如何使用</li></ul><p>1、创建 Maven 工程，导入相关依赖。</p><pre><code class="xml">&lt;!-- 继承父包 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;  &lt;!-- web启动jar --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.6&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>2、创建 Student 实体类</p><pre><code class="java">package com.threeit.entity;import lombok.AllArgsConstructor;import lombok.Data;//生成get，set@Data//生成带参构造@AllArgsConstructorpublic class Student &#123;    private long id;    private String name;    private int age;&#125;</code></pre><p>3、StudentRepository</p><pre><code class="java">package com.southwind.repository;import com.southwind.entity.Student;import java.util.Collection;public interface StudentRepository &#123;    public Collection&lt;Student&gt; findAll();    public Student findById(long id);    public void saveOrUpdate(Student student);    public void deleteById(long id);&#125;</code></pre><p>4、StudentRepositoryImpl</p><pre><code class="java">package com.southwind.repository.impl;import com.southwind.entity.Student;import com.southwind.repository.StudentRepository;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.Map;@Repositorypublic class StudentRepositoryImpl implements StudentRepository &#123;    private static Map&lt;Long,Student&gt; studentMap;    static&#123;        studentMap = new HashMap&lt;&gt;();        studentMap.put(1L,new Student(1L,&quot;张三&quot;,22));        studentMap.put(2L,new Student(2L,&quot;李四&quot;,23));        studentMap.put(3L,new Student(3L,&quot;王五&quot;,24));    &#125;    @Override    public Collection&lt;Student&gt; findAll() &#123;        return studentMap.values();    &#125;    @Override    public Student findById(long id) &#123;        return studentMap.get(id);    &#125;    @Override    public void saveOrUpdate(Student student) &#123;        studentMap.put(student.getId(),student);    &#125;    @Override    public void deleteById(long id) &#123;        studentMap.remove(id);    &#125;&#125;</code></pre><p>5、StudentHandler</p><pre><code class="java">package com.threeit.controller;import com.threeit.entity.Student;import com.threeit.repository.StudentRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.Collection;//一个控制器类@RestController//控制器请求路径@RequestMapping(&quot;/student&quot;)public class StudentHandler &#123;    //寻找StudentRepository实现类对象注入    @Autowired    private StudentRepository studentRepository;    @GetMapping(&quot;/findAll&quot;)    public Collection&lt;Student&gt; findAll()&#123;        return studentRepository.findAll();    &#125;    @GetMapping(&quot;findById/&#123;id&#125;&quot;)    public Student findById(@PathVariable(&quot;id&quot;) long id)&#123;        return studentRepository.findById(id);    &#125;    @PostMapping(&quot;/save&quot;)    public void save(@RequestBody Student student)&#123;        studentRepository.saveOrUpdate(student);    &#125;    @PutMapping(&quot;/update&quot;)    public void update(@RequestBody Student student)&#123;        studentRepository.saveOrUpdate(student);    &#125;    @DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)    public void deleteById(@PathVariable(&quot;id&quot;) long id)&#123;        studentRepository.deleteById(id);    &#125;&#125;</code></pre><p>6、application.yml</p><pre><code class="yaml">server:  port: 9090</code></pre><p>7、启动类</p><pre><code class="java">package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class,args);    &#125;&#125;</code></pre><p><code>@SpringBootApplication</code> 表示当前类是 Spring Boot 的入口，Application 类的存放位置必须是其他相关业务类的存放位置的父级。</p><h3 id="Spring-Boot-整合-JSP"><a href="#Spring-Boot-整合-JSP" class="headerlink" title="Spring Boot 整合 JSP"></a>Spring Boot 整合 JSP</h3><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;  &lt;!-- web --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!-- 整合JSP --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!-- JSTL --&gt;  &lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.6&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>创建配置文件 application.yml</li></ul><pre><code class="yaml">server:  port: 8181spring:  mvc:    view:      prefix: /      suffix: .jsp</code></pre><ul><li>创建 Handler</li></ul><pre><code class="java">package com.southwind.controller;import com.southwind.entity.Student;import com.southwind.repository.StudentRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(&quot;/hello&quot;)public class HelloHandler &#123;    @Autowired    private StudentRepository studentRepository;    @GetMapping(&quot;/index&quot;)    public ModelAndView index()&#123;        ModelAndView modelAndView = new ModelAndView();        modelAndView.setViewName(&quot;index&quot;);        modelAndView.addObject(&quot;list&quot;,studentRepository.findAll());        return modelAndView;    &#125;    @GetMapping(&quot;/deleteById/&#123;id&#125;&quot;)    public String deleteById(@PathVariable(&quot;id&quot;) long id)&#123;        studentRepository.deleteById(id);        return &quot;redirect:/hello/index&quot;;    &#125;    @PostMapping(&quot;/save&quot;)    public String save(Student student)&#123;        studentRepository.saveOrUpdate(student);        return &quot;redirect:/hello/index&quot;;    &#125;    @PostMapping(&quot;/update&quot;)    public String update(Student student)&#123;        studentRepository.saveOrUpdate(student);        return &quot;redirect:/hello/index&quot;;    &#125;    @GetMapping(&quot;/findById/&#123;id&#125;&quot;)    public ModelAndView findById(@PathVariable(&quot;id&quot;) long id)&#123;        ModelAndView modelAndView = new ModelAndView();        modelAndView.setViewName(&quot;update&quot;);        modelAndView.addObject(&quot;student&quot;,studentRepository.findById(id));        return modelAndView;    &#125;&#125;</code></pre><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-21  Time: 12:02  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;学生信息&lt;/h1&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;th&gt;学生编号&lt;/th&gt;            &lt;th&gt;学生姓名&lt;/th&gt;            &lt;th&gt;学生年龄&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/tr&gt;        &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;student&quot;&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;student.id&#125;&lt;/td&gt;                &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt;                &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt;                &lt;td&gt;                    &lt;a href=&quot;/hello/findById/$&#123;student.id&#125;&quot;&gt;修改&lt;/a&gt;                    &lt;a href=&quot;/hello/deleteById/$&#123;student.id&#125;&quot;&gt;删除&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/c:forEach&gt;    &lt;/table&gt;    &lt;a href=&quot;/save.jsp&quot;&gt;添加学生&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-21  Time: 12:09  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/hello/save&quot; method=&quot;post&quot;&gt;        ID:&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br/&gt;        name:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt;        age:&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-21  Time: 12:09  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/hello/update&quot; method=&quot;post&quot;&gt;        ID:&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;student.id&#125;&quot; readonly/&gt;&lt;br/&gt;        name:&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;student.name&#125;&quot;/&gt;&lt;br/&gt;        age:&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;student.age&#125;&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Spring-Boot-HTML"><a href="#Spring-Boot-HTML" class="headerlink" title="Spring Boot HTML"></a>Spring Boot HTML</h3><p>Spring Boot 可以结合 Thymeleaf 模版来整合 HTML，使用原生的 HTML 作为视图。</p><p>Thymeleaf 模版是面向 Web 和独立环境的 Java 模版引擎，能够处理 HTML、XML、JavaScript、CSS 等。</p><pre><code>&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt;</code></pre><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;!-- 继承父包 --&gt;&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;  &lt;!-- web启动jar --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.6&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>appliction.yml</li></ul><pre><code class="yaml">server:  port: 9090spring:  thymeleaf:    prefix: classpath:/templates/    suffix: .html    mode: HTML5    encoding: UTF-8</code></pre><ul><li>Handler</li></ul><pre><code class="java">package com.southwind.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/index&quot;)public class IndexHandler &#123;    @GetMapping(&quot;/index&quot;)    public String index()&#123;        System.out.println(&quot;index...&quot;);        return &quot;index&quot;;    &#125;&#125;</code></pre><ul><li>HTML</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>如果希望客户端可以直接访问 HTML 资源，将这些资源放置在 static 路径下即可，否则必须通过 Handler 的后台映射才可以访问静态资源。</p><h3 id="Thymeleaf-常用语法"><a href="#Thymeleaf-常用语法" class="headerlink" title="Thymeleaf 常用语法"></a>Thymeleaf 常用语法</h3><ul><li>赋值、拼接</li></ul><pre><code class="java">@GetMapping(&quot;/index2&quot;)public String index2(Map&lt;String,String&gt; map)&#123;  map.put(&quot;name&quot;,&quot;张三&quot;);  return &quot;index&quot;;&#125;</code></pre><pre><code class="html">&lt;!--字符拼接的两种方式--&gt;&lt;p th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p&gt;&lt;!--方式一：常规拼接--&gt;&lt;p th:text=&quot;&#39;学生姓名是&#39;+$&#123;name&#125;+2&quot;&gt;&lt;/p&gt;&lt;!--方式二：使用||包裹完成拼接--&gt;&lt;p th:text=&quot;|学生姓名是$&#123;name&#125;|&quot;&gt;&lt;/p&gt;</code></pre><ul><li>条件判断：if/unless</li></ul><p>th:if 表示条件成立时显示内容，th:unless 表示条件不成立时显示内容</p><pre><code class="java">@GetMapping(&quot;/if&quot;)public String index3(Map&lt;String,Boolean&gt; map)&#123;    map.put(&quot;flag&quot;,true);    return &quot;index&quot;;&#125;</code></pre><pre><code class="html">&lt;!--条件成立--&gt;&lt;p th:if=&quot;$&#123;flag == true&#125;&quot;  th:text=&quot;条件成立&quot;&gt;&lt;/p&gt;&lt;!--条件不成立--&gt;&lt;p th:unless=&quot;$&#123;flag == true&#125;&quot; th:text=&quot;条件不成立&quot;&gt;&lt;/p&gt;</code></pre><ul><li>循环</li></ul><pre><code class="java">@GetMapping(&quot;/index&quot;)public String index(Model model)&#123;    System.out.println(&quot;index...&quot;);    List&lt;Student&gt; list = new ArrayList&lt;&gt;();    list.add(new Student(1L,&quot;张三&quot;,22));    list.add(new Student(2L,&quot;李四&quot;,23));    list.add(new Student(3L,&quot;王五&quot;,24));    model.addAttribute(&quot;list&quot;,list);    return &quot;index&quot;;&#125;</code></pre><pre><code class="html">&lt;table&gt;  &lt;tr&gt;    &lt;th&gt;index&lt;/th&gt;    &lt;th&gt;count&lt;/th&gt;    &lt;th&gt;学生ID&lt;/th&gt;    &lt;th&gt;学生姓名&lt;/th&gt;    &lt;th&gt;学生年龄&lt;/th&gt;  &lt;/tr&gt;  &lt;tr th:each=&quot;student,stat:$&#123;list&#125;&quot; th:style=&quot;&#39;background-color:&#39;+@&#123;$&#123;stat.odd&#125;?&#39;#F2F2F2&#39;&#125;&quot;&gt;    &lt;td th:text=&quot;$&#123;stat.index&#125;&quot;&gt;&lt;/td&gt;    &lt;td th:text=&quot;$&#123;stat.count&#125;&quot;&gt;&lt;/td&gt;    &lt;td th:text=&quot;$&#123;student.id&#125;&quot;&gt;&lt;/td&gt;    &lt;td th:text=&quot;$&#123;student.name&#125;&quot;&gt;&lt;/td&gt;    &lt;td th:text=&quot;$&#123;student.age&#125;&quot;&gt;&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><p>stat 是状态变量，属性：</p><ul><li>index 集合中元素的index（从0开始）</li><li>count 集合中元素的count（从1开始）</li><li>size 集合的大小</li><li>current 当前迭代变量</li><li>even/odd 当前迭代是否为偶数/奇数（从0开始计算）</li><li>first 当前迭代的元素是否是第一个</li><li>last 当前迭代的元素是否是最后一个</li></ul><ul><li>URL</li></ul><p>Thymeleaf 对于 URL 的处理是通过 <code>@&#123;...&#125;</code> 进行处理，结合 th:href 、th:src</p><pre><code class="html">&lt;h1&gt;Hello World&lt;/h1&gt;&lt;a th:href=&quot;@&#123;http://www.baidu.com&#125;&quot;&gt;跳转&lt;/a&gt;&lt;a th:href=&quot;@&#123;http://localhost:9090/index/url/&#123;na&#125;(na=$&#123;name&#125;)&#125;&quot;&gt;跳转2&lt;/a&gt;&lt;img th:src=&quot;$&#123;src&#125;&quot;&gt;&lt;div th:style=&quot;&#39;background:url(&#39;+ @&#123;$&#123;src&#125;&#125; +&#39;);&#39;&quot;&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/div&gt;</code></pre><ul><li>三元运算</li></ul><pre><code class="java">@GetMapping(&quot;/eq&quot;)public String eq(Model model)&#123;    model.addAttribute(&quot;age&quot;,30);    return &quot;test&quot;;&#125;</code></pre><pre><code class="html">&lt;input th:value=&quot;$&#123;age gt 30?&#39;中年&#39;:&#39;青年&#39;&#125;&quot;/&gt;</code></pre><ul><li>gt great than 大于</li><li>ge great equal 大于等于</li><li>eq equal 等于</li><li>lt less than 小于</li><li>le less equal 小于等于</li><li>ne not equal 不等于</li></ul><ul><li>switch</li></ul><pre><code class="java">@GetMapping(&quot;/switch&quot;)public String switchTest(Model model)&#123;    model.addAttribute(&quot;gender&quot;,&quot;女&quot;);    return &quot;test&quot;;&#125;</code></pre><pre><code class="html">&lt;div th:switch=&quot;$&#123;gender&#125;&quot;&gt;  &lt;p th:case=&quot;女&quot;&gt;女&lt;/p&gt;  &lt;p th:case=&quot;男&quot;&gt;男&lt;/p&gt;  &lt;p th:case=&quot;*&quot;&gt;未知&lt;/p&gt;&lt;/div&gt;</code></pre><ul><li>基本对象<ul><li><code>#ctx</code> ：上下文对象</li><li><code>#vars</code>：上下文变量</li><li><code>#locale</code>：区域对象</li><li><code>#request</code>：HttpServletRequest 对象</li><li><code>#response</code>：HttpServletResponse 对象</li><li><code>#session</code>：HttpSession 对象</li><li><code>#servletContext</code>：ServletContext 对象</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/object&quot;)public String object(HttpServletRequest request)&#123;    request.setAttribute(&quot;request&quot;,&quot;request对象&quot;);    request.getSession().setAttribute(&quot;session&quot;,&quot;session对象&quot;);    return &quot;test&quot;;&#125;</code></pre><pre><code class="html">&lt;p th:text=&quot;$&#123;#request.getAttribute(&#39;request&#39;)&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;#session.getAttribute(&#39;session&#39;)&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;#locale.country&#125;&quot;&gt;&lt;/p&gt;</code></pre><ul><li>内嵌对象</li></ul><p>可以直接通过 # 访问。</p><p>1、dates：java.util.Date 的功能方法</p><p>2、calendars：java.util.Calendar 的功能方法</p><p>3、numbers：格式化数字</p><p>4、strings：java.lang.String 的功能方法</p><p>5、objects：Object 的功能方法</p><p>6、bools：对布尔求值的方法</p><p>7、arrays：操作数组的功能方法</p><p>8、lists：操作集合的功能方法</p><p>9、sets：操作集合的功能方法</p><p>10、maps：操作集合的功能方法</p><pre><code class="java">@GetMapping(&quot;/util&quot;)public String util(Model model)&#123;    model.addAttribute(&quot;name&quot;,&quot;zhangsan&quot;);    model.addAttribute(&quot;users&quot;,new ArrayList&lt;&gt;());    model.addAttribute(&quot;count&quot;,22);    model.addAttribute(&quot;date&quot;,new Date());    return &quot;test&quot;;&#125;</code></pre><pre><code class="html">&lt;!-- 格式化时间 --&gt;&lt;p th:text=&quot;$&#123;#dates.format(date,&#39;yyyy-MM-dd HH:mm:sss&#39;)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 创建当前时间，精确到天 --&gt;&lt;p th:text=&quot;$&#123;#dates.createToday()&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 创建当前时间，精确到秒 --&gt;&lt;p th:text=&quot;$&#123;#dates.createNow()&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 判断是否为空 --&gt;&lt;p th:text=&quot;$&#123;#strings.isEmpty(name)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 判断List是否为空 --&gt;&lt;p th:text=&quot;$&#123;#lists.isEmpty(users)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 输出字符串长度 --&gt;&lt;p th:text=&quot;$&#123;#strings.length(name)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 拼接字符串 --&gt;&lt;p th:text=&quot;$&#123;#strings.concat(name,name,name)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 创建自定义字符串 --&gt;&lt;p th:text=&quot;$&#123;#strings.randomAlphanumeric(count)&#125;&quot;&gt;&lt;/p&gt;</code></pre><h3 id="Spring-Boot-数据校验"><a href="#Spring-Boot-数据校验" class="headerlink" title="Spring Boot 数据校验"></a>Spring Boot 数据校验</h3><pre><code class="java">package com.southwind.entity;import lombok.Data;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.Min;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.NotNull;@Datapublic class User &#123;    @NotNull(message = &quot;id不能为空&quot;)    private Long id;    @NotEmpty(message = &quot;姓名不能为空&quot;)    @Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)    private String name;    @Min(value = 16,message = &quot;年龄必须大于16岁&quot;)    private int age;&#125;</code></pre><pre><code class="java">@GetMapping(&quot;/validator&quot;)public void validatorUser(@Valid User user,BindingResult bindingResult)&#123;  System.out.println(user);  if(bindingResult.hasErrors())&#123;    List&lt;ObjectError&gt; list = bindingResult.getAllErrors();    for(ObjectError objectError:list)&#123;      System.out.println(objectError.getCode()+&quot;-&quot;+objectError.getDefaultMessage());    &#125;  &#125;&#125;</code></pre><h3 id="Spring-Boot-整合-JDBC"><a href="#Spring-Boot-整合-JDBC" class="headerlink" title="Spring Boot 整合 JDBC"></a>Spring Boot 整合 JDBC</h3><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>application.yml</li></ul><pre><code class="yaml">server:  port: 9090spring:  thymeleaf:    prefix: classpath:/templates/    suffix: .html    mode: HTML5    encoding: UTF-8  datasource:    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: root    password: root    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><ul><li>User</li></ul><pre><code class="java">package com.southwind.entity;import lombok.Data;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.Min;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.NotNull;@Datapublic class User &#123;    @NotNull(message = &quot;id不能为空&quot;)    private Long id;    @NotEmpty(message = &quot;姓名不能为空&quot;)    @Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)    private String name;    @Min(value = 60,message = &quot;成绩必须大于60分&quot;)    private double score;&#125;</code></pre><ul><li>UserRepository</li></ul><pre><code class="java">package com.southwind.repository;import com.southwind.entity.User;import java.util.List;public interface UserRepository &#123;    public List&lt;User&gt; findAll();    public User findById(long id);    public void save(User user);    public void update(User user);    public void deleteById(long id);&#125;</code></pre><ul><li>UserRepositoryImpl</li></ul><pre><code class="java">package com.southwind.repository.impl;import com.southwind.entity.User;import com.southwind.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class UserRepositoryImpl implements UserRepository &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public List&lt;User&gt; findAll() &#123;        return jdbcTemplate.query(&quot;select * from user&quot;,new BeanPropertyRowMapper&lt;&gt;(User.class));    &#125;    @Override    public User findById(long id) &#123;        return jdbcTemplate.queryForObject(&quot;select * from user where id = ?&quot;,new Object[]&#123;id&#125;,new BeanPropertyRowMapper&lt;&gt;(User.class));    &#125;    @Override    public void save(User user) &#123;        jdbcTemplate.update(&quot;insert into user(name,score) values(?,?)&quot;,user.getName(),user.getScore());    &#125;    @Override    public void update(User user) &#123;        jdbcTemplate.update(&quot;update user set name = ?,score = ? where id = ?&quot;,user.getName(),user.getScore(),user.getId());    &#125;    @Override    public void deleteById(long id) &#123;        jdbcTemplate.update(&quot;delete from user where id = ?&quot;,id);    &#125;&#125;</code></pre><ul><li>Handler</li></ul><pre><code class="java">package com.southwind.controller;import com.southwind.entity.User;import com.southwind.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/user&quot;)public class UserHandler &#123;    @Autowired    private UserRepository userRepository;    @GetMapping(&quot;/findAll&quot;)    public List&lt;User&gt; findAll()&#123;        return userRepository.findAll();    &#125;    @GetMapping(&quot;/findById/&#123;id&#125;&quot;)    public User findById(@PathVariable(&quot;id&quot;) long id)&#123;        return userRepository.findById(id);    &#125;    @PostMapping(&quot;/save&quot;)    public void save(@RequestBody User user)&#123;        userRepository.save(user);    &#125;    @PutMapping(&quot;/update&quot;)    public void update(@RequestBody User user)&#123;        userRepository.update(user);    &#125;    @DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)    public void deleteById(@PathVariable(&quot;id&quot;) long id)&#123;        userRepository.deleteById(id);    &#125;&#125;</code></pre><h3 id="Spring-Boot-整合-MyBatis"><a href="#Spring-Boot-整合-MyBatis" class="headerlink" title="Spring Boot 整合 MyBatis"></a>Spring Boot 整合 MyBatis</h3><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>application.yml</li></ul><pre><code class="yaml">server:  port: 9090spring:  thymeleaf:    prefix: classpath:/templates/    suffix: .html    mode: HTML5    encoding: UTF-8  datasource:    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: root    password: root    driver-class-name: com.mysql.cj.jdbc.Drivermybatis:  mapper-locations: classpath:/mapping/*.xml  type-aliases-package: com.southwind.entity</code></pre><ul><li>UserRepository</li></ul><pre><code class="java">package com.southwind.mapper;import com.southwind.entity.User;import java.util.List;public interface UserRepository &#123;    public List&lt;User&gt; findAll(int index,int limit);    public User findById(long id);    public void save(User user);    public void update(User user);    public void deleteById(long id);    public int count();&#125;</code></pre><ul><li>UserRepository.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.southwind.mapper.UserRepository&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;User&quot;&gt;        select * from user limit #&#123;param1&#125;,#&#123;param2&#125;    &lt;/select&gt;    &lt;select id=&quot;count&quot; resultType=&quot;int&quot;&gt;        select count(id) from user    &lt;/select&gt;    &lt;select id=&quot;findById&quot; parameterType=&quot;long&quot; resultType=&quot;User&quot;&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;    &lt;insert id=&quot;save&quot; parameterType=&quot;User&quot;&gt;        insert into user(name,score) values(#&#123;name&#125;,#&#123;score&#125;)    &lt;/insert&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;User&quot;&gt;        update user set name = #&#123;name&#125;,score = #&#123;score&#125; where id = #&#123;id&#125;    &lt;/update&gt;    &lt;delete id=&quot;deleteById&quot; parameterType=&quot;long&quot;&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;&lt;/mapper&gt;</code></pre><ul><li>User</li></ul><pre><code class="java">package com.southwind.entity;import lombok.Data;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.Min;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.NotNull;@Datapublic class User &#123;    @NotNull(message = &quot;id不能为空&quot;)    private Long id;    @NotEmpty(message = &quot;姓名不能为空&quot;)    @Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)    private String name;    @Min(value = 60,message = &quot;成绩必须大于60分&quot;)    private double score;&#125;</code></pre><ul><li>Handler</li></ul><pre><code class="java">package com.southwind.controller;import com.southwind.entity.User;import com.southwind.mapper.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(&quot;/mapper&quot;)public class UserMapperHandler &#123;    @Autowired    private UserRepository userRepository;    private int limit = 10;    @GetMapping(&quot;/findAll/&#123;page&#125;&quot;)    public ModelAndView findAll(@PathVariable(&quot;page&quot;) int page)&#123;        ModelAndView modelAndView = new ModelAndView();        int index = (page-1)*limit;        modelAndView.setViewName(&quot;show&quot;);        modelAndView.addObject(&quot;list&quot;,userRepository.findAll(index,limit));        modelAndView.addObject(&quot;page&quot;,page);        //计算总页数        int count = userRepository.count();        int pages = 0;        if(count%limit == 0)&#123;            pages = count/limit;        &#125;else&#123;            pages = count/limit+1;        &#125;        modelAndView.addObject(&quot;pages&quot;,pages);        return modelAndView;    &#125;    @GetMapping(&quot;/deleteById/&#123;id&#125;&quot;)    public String deleteById(@PathVariable(&quot;id&quot;) long id)&#123;        userRepository.deleteById(id);        return &quot;redirect:/mapper/findAll/1&quot;;    &#125;    @GetMapping(&quot;/findById&quot;)    public ModelAndView findById(@RequestParam(&quot;id&quot;) long id)&#123;        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;user&quot;,userRepository.findById(id));        modelAndView.setViewName(&quot;update&quot;);        return modelAndView;    &#125;    @PostMapping(&quot;/update&quot;)    public String update(User user)&#123;        userRepository.update(user);        return &quot;redirect:/mapper/findAll/1&quot;;    &#125;    @PostMapping(&quot;/save&quot;)    public String save(User user)&#123;        userRepository.save(user);        return &quot;redirect:/mapper/findAll/1&quot;;    &#125;    @GetMapping(&quot;/redirect/&#123;name&#125;&quot;)    public String redirect(@PathVariable(&quot;name&quot;) String name)&#123;        return name;    &#125;&#125;</code></pre><ul><li>HTML</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/mapper/save&quot; method=&quot;post&quot;&gt;        用户姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt;        用户成绩：&lt;input type=&quot;text&quot; name=&quot;score&quot; /&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/mapper/update&quot; method=&quot;post&quot;&gt;        用户ID：&lt;input type=&quot;text&quot; name=&quot;id&quot; th:value=&quot;$&#123;user.id&#125;&quot; readonly/&gt;&lt;br/&gt;        用户姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; th:value=&quot;$&#123;user.name&#125;&quot; /&gt;&lt;br/&gt;        用户成绩：&lt;input type=&quot;text&quot; name=&quot;score&quot; th:value=&quot;$&#123;user.score&#125;&quot; /&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/jquery-3.3.1.min.js&#125;&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(function()&#123;            $(&quot;#first&quot;).click(function()&#123;                var page = $(&quot;#page&quot;).text();                page = parseInt(page);                if(page == 1)&#123;                    return false;                &#125;                window.location.href=&quot;/mapper/findAll/1&quot;;            &#125;);            $(&quot;#previous&quot;).click(function()&#123;                var page = $(&quot;#page&quot;).text();                page = parseInt(page);                if(page == 1)&#123;                    return false;                &#125;                page = page-1;                window.location.href=&quot;/mapper/findAll/&quot;+page;            &#125;);            $(&quot;#next&quot;).click(function()&#123;                var page = $(&quot;#page&quot;).text();                var pages = $(&quot;#pages&quot;).text();                if(page == pages)&#123;                    return false;                &#125;                page = parseInt(page);                page = page+1;                window.location.href=&quot;/mapper/findAll/&quot;+page;            &#125;);            $(&quot;#last&quot;).click(function()&#123;                var page = $(&quot;#page&quot;).text();                var pages = $(&quot;#pages&quot;).text();                if(page == pages)&#123;                    return false;                &#125;                window.location.href=&quot;/mapper/findAll/&quot;+pages;            &#125;);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;用户信息&lt;/h1&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;th&gt;用户ID&lt;/th&gt;            &lt;th&gt;用户名&lt;/th&gt;            &lt;th&gt;成绩&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/tr&gt;        &lt;tr th:each=&quot;user:$&#123;list&#125;&quot;&gt;            &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;user.score&#125;&quot;&gt;&lt;/td&gt;            &lt;td&gt;                &lt;a th:href=&quot;@&#123;/mapper/deleteById/&#123;id&#125;(id=$&#123;user.id&#125;)&#125;&quot;&gt;删除&lt;/a&gt;                &lt;a th:href=&quot;@&#123;/mapper/findById(id=$&#123;user.id&#125;)&#125;&quot;&gt;修改&lt;/a&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;a id=&quot;first&quot; href=&quot;javascript:void(0)&quot;&gt;首页&lt;/a&gt;    &lt;a id=&quot;previous&quot; href=&quot;javascript:void(0)&quot;&gt;上一页&lt;/a&gt;    &lt;span id=&quot;page&quot; th:text=&quot;$&#123;page&#125;&quot;&gt;&lt;/span&gt;/&lt;span id=&quot;pages&quot; th:text=&quot;$&#123;pages&#125;&quot;&gt;&lt;/span&gt;    &lt;a id=&quot;next&quot; href=&quot;javascript:void(0)&quot;&gt;下一页&lt;/a&gt;    &lt;a id=&quot;last&quot; href=&quot;javascript:void(0)&quot;&gt;尾页&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;/mapper/redirect/save&quot;&gt;添加用户&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/Stack_c/"/>
      <url>2022/03/20/Stack_c/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><pre><code class="C">/* * @Author: itThree * @Date: 2021-08-27 19:58:17 * @LastEditTime: 2021-08-27 20:21:54 * @Description: * @FilePath: \cpp\datas\stack_arr.cpp * 光阴之逆旅，百代之过客，而已 */#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ArrType int#define Size 10 typedef struct Stack &#123;    ArrType Data[Size];    int top;&#125;Stack;bool isEmpty(Stack* &amp;S) &#123;    if (S-&gt;top == 0) &#123;        return true;    &#125;    return false;&#125;void push(Stack* &amp;S, ArrType x) &#123;    printf(&quot;into push\n&quot;);    S-&gt;Data[S-&gt;top] = x;    S-&gt;top++;&#125;ArrType pop(Stack* &amp;S) &#123;    //pop先判空    if (isEmpty(S)) &#123;        printf(&quot;underflow/n&quot;);        return NULL;    &#125;    //非空先暂存Stack元素索引（返回时用）    int x = S-&gt;top;    //索引减一，下次push时原top指向元素会被覆盖    S-&gt;top--;    return S-&gt;Data[x];&#125;void printStack(Stack* &amp;S) &#123;    printf(&quot;into printStack\n&quot;);    for (int i = 0; i &lt; S-&gt;top; i++)    &#123;        printf(&quot;第%d个=%d\n&quot;, i+1, S-&gt;Data[i]);    &#125;&#125;int main() &#123;    printf(&quot;satrt&quot;);    Stack* S = (Stack*)malloc(sizeof(Stack));    //不要忘记初始化结构体，否则带来意外效果。    S-&gt;top = 0;    push(S, 1);    push(S, 2);    push(S, 3);    printStack(S);    pop(S);    pop(S);    pop(S);    int x = pop(S);    printf(&quot;%d&quot;, x);    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/String.equals()%E2%95%9C%CE%93%E2%95%A2%E2%94%B4/"/>
      <url>2022/03/20/String.equals()%E2%95%9C%CE%93%E2%95%A2%E2%94%B4/</url>
      
        <content type="html"><![CDATA[<p>#String.equals()解读</p><pre><code class="java">    public boolean equals(Object anObject) &#123;        //判断字符        //判断此两字符是否属于同一内存空间，是则必定相同（众所周知字单一符会在常量池中，以后的多次出现即为引用）        if (this == anObject) &#123;            return true;        &#125;        //判断字符串          //对比串中每个字符的地址        if (anObject instanceof String) &#123;            String anotherString = (String)anObject;            int n = value.length;            //如果比较的两个串长度不相等则比较结束返回false            if (n == anotherString.value.length) &#123;                char v1[] = value;                char v2[] = anotherString.value;                int i = 0;                //比较每个字符                while (n-- != 0) &#123;                    if (v1[i] != v2[i])                        return false;                    i++;                &#125;                return true;            &#125;        &#125;        return false;    &#125;</code></pre><p>Integer.compareTo()解读</p><pre><code class="java">public int compareTo(Integer anotherInteger) &#123;        return compare(this.value, anotherInteger.value);    // private final int value;是Integer的一个私有字段    &#125;         public static int compare(int x, int y) &#123;        //妙啊！这三目运算玩的6啊        //x&lt;y返回-1，否则判断x是否等于y是则返回0，否则x必&gt;y返回1        return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>request对象</title>
      <link href="2022/03/20/TomCat-01/"/>
      <url>2022/03/20/TomCat-01/</url>
      
        <content type="html"><![CDATA[<p> request对象和response对象的原理:</p><ol><li>request和response对象是由服务器创建的。我们来使用它们</li><li>request对象是来获取请求消息，response对象是来设置响应消息</li></ol><h1 id="获取请求行信息"><a href="#获取请求行信息" class="headerlink" title="获取请求行信息"></a>获取请求行信息</h1><pre><code class="java">@WebServlet(&quot;/requestDemo&quot;)//注解添加虚拟访问路径public class requestDemo extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;               &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String method = request.getMethod();//获取请求方法        String contextPath = request.getContextPath();//获取虚拟目录        String servletPath = request.getServletPath();//获取servlet路径        String queryString = request.getQueryString();//获取请求参数        String requestURI = request.getRequestURI();//获取url        String protocol = request.getProtocol();//获取访问协议信息        String remoteAddr = request.getRemoteAddr();//获取客户端ip        System.out.println(method);        System.out.println(contextPath);        System.out.println(servletPath);        System.out.println(queryString);        System.out.println(requestURI);        System.out.println(protocol);        System.out.println(remoteAddr);    &#125;    /*运行结果：        GET        /demo1        /requestDemo        null        0:0:0:0:0:0:0:1        /demo1/requestDemo        HTTP/1.1        */&#125;</code></pre><h1 id="获取请求头信息"><a href="#获取请求头信息" class="headerlink" title="获取请求头信息"></a>获取请求头信息</h1><ul><li><code>String getHeader(String name)</code>通过请求头的名称获取请求头</li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code>获取所有的请求头名称</li></ul><pre><code class="java">@WebServlet(&quot;/requestDemo2&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;          &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;//获取请求头        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();//获取全部请求头名称        while (headerNames.hasMoreElements()) &#123;            String name = headerNames.nextElement();//这个方法像迭代器的next()一样            String value = request.getHeader(name);//根据请求头名称获取值            System.out.println(name+&quot;-----&quot;+value);        &#125;    &#125;&#125;</code></pre><h2 id="请求头例子：（判断客户端，设置防盗链等）"><a href="#请求头例子：（判断客户端，设置防盗链等）" class="headerlink" title="请求头例子：（判断客户端，设置防盗链等）"></a>请求头例子：（判断客户端，设置防盗链等）</h2><pre><code class="java">@WebServlet(&quot;/requestDemo2&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;          &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //防盗链例子：         String referer = request.getHeader(&quot;referer&quot;);         System.out.println(referer);         if (referer!=null)&#123;             if (referer.contains(&quot;/demo&quot;))&#123;                 response.setContentType(&quot;text/html;charset=utf-8&quot;);                 response.getWriter().write(&quot;播放电影....&quot;);             &#125;else &#123;                 response.setContentType(&quot;text/html;charset=utf-8&quot;);                 response.getWriter().write(&quot;想看电影吗？来优酷吧...&quot;);             &#125;         &#125;        //判断客户端//        String agent = request.getHeader(&quot;user-agent&quot;);//        if (agent.contains(&quot;Chrome&quot;)) System.out.println(&quot;谷歌浏览器~~~&quot;);//判断客户端是否为谷歌浏览器    &#125;&#125;        </code></pre><h1 id="获取请求体信息"><a href="#获取请求体信息" class="headerlink" title="获取请求体信息"></a>获取请求体信息</h1><p>POST请求方式才有请求体，请求体中封装了POST请求参数。</p><ul><li> <code>BufferedReader getReader()</code>获取字符输入流，只能操作字符数据</li><li> <code>ServletInputStream getInputStream()</code>获取字节输入流，可以操作所有类型数据</li></ul><pre><code class="java">     @WebServlet(&quot;/requestDemo2&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                  &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125; //以字节流形式读取请求信息 BufferedReader br = request.getReader();//获取字节流         String line = null;         while ((line = br.readLine())!=null)&#123;//读取             System.out.println(line);</code></pre><h2 id="POST方式乱码问题"><a href="#POST方式乱码问题" class="headerlink" title="POST方式乱码问题"></a>POST方式乱码问题</h2><p>GET方式的乱码已由Tomcat解决，仅有POST方式存在乱码</p><pre><code class="java">       @WebServlet(&quot;/requestDemo2&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                  &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;     request.setCharacterEncoding(&quot;utf-8&quot;);//设置流编码，指定名称获取值是通过流的形式进行的，故会存在编码问题。        String username = request.getParameter(&quot;username&quot;);//获取指定名称参数值        Map&lt;String ,String[]&gt; parameterMap = request.getParameterMap();//获取所有参数并装入map集合        Set&lt;String&gt; keyset = parameterMap.keySet();//将值存入视图进行遍历准备        for (String s : keyset) &#123;            String[] values = parameterMap.get(s);            for (String value:values)&#123;                System.out.println(value);            &#125;        &#125;        System.out.println(username);&#125;    </code></pre><h1 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h1><p>转发是指在服务器内部资源间跳转；</p><p>即使跳转到多个资源也仅仅是在一个请求的范围内；</p><p>跳转时地址栏地址不变。</p><pre><code class="java">@WebServlet(&quot;/requestDemo&quot;)public class requestDemo extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                 //转发        request.getRequestDispatcher(&quot;/requestDemo1&quot;).forward(request,response);        //getRequestDispatcher(&quot;/requestDemo1&quot;)获取转发对象        //forward(request,response)进行转发操作        System.out.println(&quot;requestDemo被访问&quot;);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request,response);        //因为访问页面默认为GET访问，提交表单多为POST访问;        //所以此处需调用doPost方法并传入参数    &#125;&#125;</code></pre><pre><code class="java">@WebServlet(&quot;/requestDemo1&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;requestDemo1被访问&quot;);        &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            this.doPost(request,response);    &#125;&#125;</code></pre><h1 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h1><ul><li><code>void setAttribute(String name,Object obj)</code>:存储数据</li><li><code>Object getAttitude(String name)</code>:通过键获取值</li><li><code>void removeAttribute(String name)</code>:通过键移除键值对</li></ul><pre><code class="java">@WebServlet(&quot;/requestDemo1&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        Object hello = request.getAttribute(&quot;hello&quot;);//通过键糊获取值        System.out.println(hello);        &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            this.doPost(request,response);    &#125;&#125;</code></pre><pre><code class="java">       @WebServlet(&quot;/requestDemo1&quot;)public class requestDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       request.setAttribute(&quot;hello&quot;,&quot;hello world!&quot;);//存储数据(键值)        request.getRequestDispatcher(&quot;/requestDemo1&quot;).forward(request,response);        &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            this.doPost(request,response);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/Tree/"/>
      <url>2022/03/20/Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="递归生成二叉树"><a href="#递归生成二叉树" class="headerlink" title="递归生成二叉树"></a>递归生成二叉树</h3><p>结点结构：</p><pre><code class="C++">#define TYPE char typedef struct biTNode&#123;    TYPE data;    struct biTNode* lchild, * rchild;&#125;biTNode, * biTree;</code></pre><pre><code class="C++">//前序生成树void CreateTree(biTree&amp; T) &#123;    TYPE data;    cin&gt;&gt;data;    if (data==&#39;#&#39;) &#123;        T = NULL;    &#125;    else &#123;        T = new biTNode;        T-&gt;data = data;        CreateTree(T-&gt;lchild);        CreateTree(T-&gt;rchild);    &#125;&#125;</code></pre><p>前序遍历树：</p><pre><code class="c++">void PrePrintTree(biTree&amp; T) &#123;    if (T == NULL)return;    printf(&quot;%c\t&quot;, T-&gt;data);    PrePrintTree(T-&gt;lchild);    PrePrintTree(T-&gt;rchild);&#125;</code></pre><p>输入：<code> 123###45##</code></p><p>生成二叉树如下图：</p><p>结点#等同无，画出来是为了更好的展示与输入对应。</p><p><img src="http://img.lbkzw.cn/img/tree_210925.svg" alt="image-20210925163559886"></p><p>标红的结点是输入#的顺序，1#，2#分别对应于输入的第一个、第二个#…以此类推。</p><p><img src="http://img.lbkzw.cn/img/tree210925_1.svg" alt="tree210925_1"></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="后继和前驱"><a href="#后继和前驱" class="headerlink" title="后继和前驱"></a>后继和前驱</h3><p><strong>定义：</strong>结点的<strong>后继</strong>，是大于x.key的最小关键字的结点——即<code>&gt;=X.key</code>的结点。</p><p>​      结点的<strong>前驱</strong>，是小于x.key的最大关键字的结点——即<code>&lt;=X.key</code>的结点。</p><p>如图所示:</p><p><img src="http://img.lbkzw.cn/img/1335276-20180909095736739-497790387.png" alt="1335276-20180909095736739-497790387"></p><p>寻找后继：</p><p>规定：若<strong>查找点X的后继</strong>,那么X父母的父母的…父母我们称之为<strong>祖先</strong>，若<strong>X</strong>为其父母的左子树，我们称X的父母为<strong>右父母</strong>，反之为<strong>左父母</strong>；如图中X的左右父母分别为LP,RP;</p><p>那么分以下3种情况，除此之外X便无后继</p><ol><li>X右子树存在：右子树中取最小一点便是X的后继</li><li>X无右子树且无右父母（有左父母），X左祖先的第一个右父母便为X后继</li><li>X无右子树且无左父母（有右父母），X右父母便为X后继</li></ol><pre><code class="c++">BST* successor(BST* &amp;T,BST *X)&#123;    //1.存在右子树    if(X-&gt;rchild != NULL)&#123;        return minElenment(X-&gt;rchild);    &#125;    //无右子树：     BST* Y = searchP(T,X-&gt;data);    //2.无右子树且无右父母    while (Y!=NULL &amp;&amp; X == Y-&gt;rchild)    &#123;        //自下而上，寻找左祖先的（第一个）右父母        X = Y;        Y = searchP(T,Y-&gt;data);    &#125;    //3.无右子树且无左父母    return Y;&#125;</code></pre><p><img src="http://img.lbkzw.cn/img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20(1).svg" alt="二叉搜索树 (1)"></p><p>寻找前驱：</p><p>若存在左子树（LS）则：前驱 = 左子树中的最大值；</p><p>若仅有左父母(LP)，无左子树(LS)则：前驱 = 左父母的值；</p><p>若左子树和左父母均无，则：前驱 = 右父母的左父母，以此类推。</p><h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><p><strong>递归删除</strong></p><pre><code class="c">BST* delNode(BST* T,TYPE x)&#123;    //终止条件    if(T==NULL)&#123;        return NULL;    &#125;    //查找值为x的结点    if(x &lt; T-&gt;data)&#123;        T-&gt;lchild = delNode(T-&gt;lchild,x);    &#125;else if(x &gt; T-&gt;data)&#123;        T-&gt;rchild = delNode(T-&gt;rchild,x);    &#125;else&#123;        //此时一定找到了x结点        if(T-&gt;lchild &amp;&amp; T-&gt;rchild)&#123;            BST* p = minElenment(T-&gt;rchild);            //这里直接改变将删除结点的data，即间接“删除”。            T-&gt;data = p-&gt;data;            T-&gt;rchild = delNode(T-&gt;rchild,p-&gt;data);        &#125;else if(!(T-&gt;rchild &amp;&amp; T-&gt;lchild))&#123;            T = NULL;        &#125;else if(T-&gt;rchild)&#123;            T = T-&gt;rchild;        &#125;else if(T-&gt;lchild)&#123;            T = T-&gt;lchild;        &#125;    &#125;    return T;&#125;</code></pre><p><strong>非递归删除</strong></p><pre><code class="c++">/** * 非递归删除结点，借助辅助函数transplant(T,u,v) */void delNode(BST* &amp;T, TYPE x)&#123;    //1.2.待删除结点仅有lchild或rchild、    BST* z = search(T,x);    if(z-&gt;lchild == NULL)&#123;        transplant(T,z,z-&gt;rchild);    &#125;else if(z-&gt;rchild == NULL)&#123;        transplant(T,z,z-&gt;lchild);    &#125;else&#123;    //3.左右结点均存在    //寻找z的后继y：        //a.若y是z的rchild,则y必定无lchild(由寻找后继的规律可知：仅z.rchild.lchild=NULL时，y=z.rchild),此时直接以y替换z,并将y.lchild=z.lchild        //b.若y不是z的rchild（y必定无lchild），则用y.rchild替换y,再以y替换z,并将y.lchild=z.lchild    BST* y = minElenment(z-&gt;rchild);    // BST* z = searchP(T,y-&gt;data);    //b    if(z-&gt;rchild != y)&#123;        //将y.p指向y.rchild        transplant(T,y,y-&gt;rchild);        y-&gt;rchild = z-&gt;rchild;    &#125;        //a.也是b的后半部分——用y替换z    transplant(T,z,y);    y-&gt;lchild = z-&gt;lchild;    &#125;&#125;</code></pre><p>辅助函数transplant(T,u,v)</p><pre><code class="c++">/** * 用结点v替换u * 这里仅仅改变u.p的指向 */void transplant(BST* &amp;T,BST* u, BST* &amp;v)&#123;    //u.p    BST* p = searchP(T,u-&gt;data);    if(p == NULL)&#123;        T = v;        //我们需要的是将T指向V，而不是用V替代T并抹除T        // (*T) = (*v);这将导致树残缺为一半    &#125;else if(u == p-&gt;rchild)&#123;        p-&gt;rchild = v;    &#125;else&#123;        p-&gt;lchild = v;    &#125;&#125;</code></pre><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><pre><code class="c">//层次遍历——使用队列void levelOrder(BST* T)&#123;    //思路：1.从根结点起，依次将其本身并左结点，右结点入队直到所有结点都入队    //2.pop，front配合进行遍历即可    //使用c++提供的queue    queue&lt;BST*&gt; Q;    Q.push(T);    cout&lt;&lt;Q.empty();    while (!Q.empty())    &#123;    //使用p = Q.front()代替p = Q.pop(),盲猜：可能出队后内存就注销了吧。        BST* p = Q.front();         cout&lt;&lt;p-&gt;data&lt;&lt;endl;        //比较cd的地方是这个pop的的类型为void,且无法通过强制类型转换引用。        Q.pop();        if(p-&gt;lchild)&#123;            Q.push(p-&gt;lchild);        &#125;        if(p-&gt;rchild)&#123;            Q.push(p-&gt;rchild);        &#125;    &#125;    &#125;</code></pre><h3 id="中序遍历——Stack模拟"><a href="#中序遍历——Stack模拟" class="headerlink" title="中序遍历——Stack模拟"></a>中序遍历——Stack模拟</h3><pre><code class="c">//Stack遍历——中序遍历void stackInmid(BST* T)&#123;    //思路：沿根节点将所有左结点push入Stack,直到触底（即这条线上再无其它左结点，其它线上还有哦）    //pop(p) ，访问p, set p = p.rchild继续遍历    //如此反复，直到Stack空    stack&lt;BST*&gt; S;    //T=NULL可能访问了叶结点的子结点    while (T || !(S.empty()))    &#123;                    if(T)&#123;            S.push(T);            T = T-&gt;lchild;        &#125;else&#123;             T = S.top();             cout&lt;&lt;T-&gt;data&lt;&lt;&quot; &quot;;             S.pop();             T = T-&gt;rchild;        &#125;    &#125;&#125;</code></pre><h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>非递归插入</p><pre><code class="c">//非递归——插入void insert(BST* &amp;T, BST* &amp;X) &#123;    //p1负责指向插入位置的父节点    BST* p1 = NULL;    //p2负责找到插入的位置    BST* p2 = T;    while (p2 != NULL)    &#123;            //p1始终指向p2的上一个指针        p1 = p2;        if (X-&gt;data &lt; p2-&gt;data)        &#123;            p2 = p2-&gt;lchild;        &#125;        else        &#123;            p2 = p2-&gt;rchild;        &#125;    &#125;    //如果p1循环结束仍为空，即T为空树    if (p1 == NULL) &#123;        T = X;    &#125;    else if (p1-&gt;data &gt; X-&gt;data) &#123;        p1-&gt;lchild = X;    &#125;    else    &#123;        p1-&gt;rchild = X;    &#125;&#125;</code></pre><p>递归插入</p><pre><code class="c">//递归——插入BST* insertRecursion(BST*&amp; T, BST*&amp; X) &#123;    if (T == NULL) &#123;        T = X;    &#125;    else if(X-&gt;data &lt; T-&gt;data)    &#123;        T-&gt;lchild = insertRecursion(T-&gt;lchild, X);    &#125;else if(X-&gt;data &gt; T-&gt;data)    &#123;        T-&gt;rchild = insertRecursion(T-&gt;rchild,X);    &#125;    return T;&#125;</code></pre><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>参考：<a href="https://www.cnblogs.com/jasontodd/p/9613836.html">二叉搜索树的前驱和后继详细推导</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>追踪式垃圾回收算法</title>
      <link href="2022/03/20/jvm-02/"/>
      <url>2022/03/20/jvm-02/</url>
      
        <content type="html"><![CDATA[<h1 id="四种引用："><a href="#四种引用：" class="headerlink" title="四种引用："></a>四种引用：</h1><ol><li>强引用：指程序中普遍存在的引用赋值；被强引用关联的对象<strong>只要强引用关系存在</strong>，被引用的对象就不会被回收</li><li>软引用：指有用而非必须的对象；被软引用关联的对象在<strong>系统发生内存溢出之前</strong>会将其回收</li><li>弱引用：指非必须的对象（比软引用弱）；被弱引用关联的对象<strong>在下一次垃圾回收前无论内存是否足够</strong>，均将其回收</li><li>虚引用：无法通过此引用来取得对象实例，使用此引用<strong>只是为了在对象被回收时收到一个系统通知</strong></li></ol><h1 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h1><ul><li>分代假说</li></ul><ol><li>弱分代假说（新生代）：大多数对象都是朝生夕灭</li><li>强分代假说（老年代）：对象熬过的收集次数越多就越难被回收</li><li>跨代引用假说：跨代引用相对于同代引用仅占少数</li></ol><ul><li>垃圾分类：根据强、弱分代假说，将<strong>Java堆</strong>分为两个内存区域分别<strong>存储新生代与老年代</strong>，每次回收后存活的新生代对象将逐步晋升到老年代中。</li><li>老年代引用新生代：相互引用的两个对象应<strong>同生同灭</strong>，所以该<strong>新生代会逐步晋升</strong>到老年代中从而<strong>消除跨代引用</strong></li><li>根据跨带引用假说，在新生代上建立全局数据结构“记忆集”，这个集合中标记存在<strong>跨代引用</strong>的老年代，收集扫描时仅扫描此集合中标识的老年代</li></ul><h1 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h1><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><ul><li><p>标记需要<strong>回收</strong>的对象，清除所有<strong>标记</strong>的对象</p></li><li><p>标记需要<strong>保</strong>存的对象，清除所有<strong>未标记</strong>的对象</p></li><li><p>缺点：<strong>标记清除算法</strong>需要大量的标记、清除动作，且清除后会产生大量不连续的内存空间（可能导致无法为大的对象分配内存）</p></li></ul><img src="https://i.loli.net/2020/08/19/3yCNL6twl1xVYFd.jpg" alt="screenshot_2020_07_31T12_32_20+0800" style="zoom:50%;" /><h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><ul><li>标记过程与<strong>标记清除算法</strong>相同，但并不直接对可回收对象进行回收，而是让所有存活对象向内存空间一端移动，然后直接清除另外一端</li><li>缺点：移动对象操作时需全程暂停用户应用程序</li><li>和稀泥式解决方案：令虚拟机使用<strong>标记清除算法</strong>直到内存碎片化程度影响到对象内存分配，再使用<strong>标记整理算法</strong></li></ul><img src="https://i.loli.net/2020/08/19/Pyc8XSEThekfHAI.jpg" alt="screenshot_2020_07_31T12_359+0800" style="zoom:50%;" /><h2 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h2><ul><li><p>将内存分为两块，每次只使用一块，当这块内存满时将其中存活的对象复制到另一块内存中，并自我清除。</p></li><li><p>缺点：<strong>标记复制算法</strong>需要大量的内存空间，且内存中回收对象的数量直接影响着此算法的效率。</p></li><li><p>此算法常用于<strong>新生代</strong>回收</p><img src="https://i.loli.net/2020/08/19/PSIqUYjOnxXaJcs.jpg" alt="screenshot_2020_07_31T12_35_49+0800" style="zoom:50%;" /></li></ul><h2 id="Appel式回收（标记复制算法的改进）"><a href="#Appel式回收（标记复制算法的改进）" class="headerlink" title="Appel式回收（标记复制算法的改进）"></a>Appel式回收（标记复制算法的改进）</h2><ul><li>将新生代分为一块较大的Eden空间与两块较小的Survivor空间。</li><li>分配内存时使用Eden与一块Survivor，回收时将使用的Eden与Survivor上存活的对象复制到另一块Survivor上，并自我清除。</li><li>当另一块Survivor空间装不下<strong>已使用</strong>的Eden与Survivor中的存活对象时，就会发生<strong>分配担保</strong>（装不下的存活对象直接晋升至老年代）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class文件结构</title>
      <link href="2022/03/20/jvm-03/"/>
      <url>2022/03/20/jvm-03/</url>
      
        <content type="html"><![CDATA[<p>class文件是以8个字节为基础的二进制流；</p><p>class文件中存在表、无符号数这两种数据结构，同时每个class文件均可视为一张表；</p><p>无符号数以<strong>u1、u2、u3、u4</strong>分别指代<strong>1、2、4、8字节</strong>，而所有表均以<code>_info</code>结尾</p><h1 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h1><p>class文件开头的4个字节<code>CA FE BA BE</code>被称为魔数，用以区分该文件是否为class文件</p><h1 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h1><p>第5、6个字节是次版本号，第7、8个字节是主版本号；</p><p>虚拟机无法执行超过其版本号的class文件。</p><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><blockquote><p>常量池中主要存放字面量、符号引用；为第9到第30个字节</p></blockquote><img src="http://img.lbkzw.cn/img/20200830120618.png" alt="screenshot_2020_08_25T09_29_24+0800" style="zoom:50%;" /><p>常量池入口有一项u2数据用来保存常量池的容量大小，即容量计数值；</p><p>容量计数值从1开始（计数范围1-21），不引用任何一个常量池项目时为0，而集合类型的容量计数从0开始；</p><p>虚拟机加载类时，首先从常量池获得对应的符号引用，并选择在类创建或运行时解析、翻译到具体内存地址中；</p><p>常量池中所有常量都是一个表；</p><p>tag（标志位）用于区分常量类型，name_index是常量池的索引值。</p><img src="http://img.lbkzw.cn/img/20200830122133.png" alt="screenshot_2020_08_26T14_57_26+0800" style="zoom:50%;" /><img src="http://img.lbkzw.cn/img/20200830122149.png" alt="screenshot_2020_08_26T14_58_20+0800" style="zoom:50%;" /><img src="http://img.lbkzw.cn/img/20200830122202.png" alt="screenshot_2020_08_26T14_58_24+0800" style="zoom:50%;" /><h1 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h1><p>紧接着常量池后的两个字节便是<strong>访问标志</strong>，用来识别信息如：这是个接口、模块，这是个public访问修饰类型等；</p><p>两个为真的地址做<strong>并运算</strong>结果即为<strong>访问标识符</strong>（access_flags）的值。</p><img src="http://img.lbkzw.cn/img/20200830122241.png" alt="screenshot_2020_08_26T14_59_01+0800" style="zoom:50%;" /><img src="http://img.lbkzw.cn/img/20200830122305.png" alt="screenshot_2020_08_28T13_14_28+0800" style="zoom:50%;" /><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>类索引、父类索引均为u2类型数据而接口索引为u2类型集合；</p><p>类索引、父类索引均指向一个类型为<strong>CONSTANT_Class_info</strong>的类型描述符常量，通过此常量中的索引值可以找到定义在<strong>CONSTANT_Utf-8_info</strong>类型中的全限定名字符串；</p><p>除java.lang.Object类外其他类的父类索引均不为0；</p><p>如图：<img src="http://img.lbkzw.cn/img/20200830122523.png" alt="screenshot_2020_08_28T15_30_58+0800" style="zoom:50%;" /></p><p>从0x000000F1开始的3个u2类型数据分别为0x0001、0x0003、0x0000，即类索引为1，父类索引为3，接口索引集合大小为0</p><h1 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h1><p>仅包含类的字段变量，从0x000000F8开始，而不包含方法内部的局部变量、继承来的字段。</p><p>如图：<img src="http://img.lbkzw.cn/img/20200830122328.png" alt="screenshot_2020_08_28T14_53_43+0800" style="zoom:50%;" /></p><p><strong>fields_count</strong>的值说明这个类仅有一个字段表数据；</p><p><strong>access_flags</strong>的值0x0002代表访问修饰符private为真；</p><p>字段名称即<strong>name_index</strong>值为0x0005在常量表中对应值为“m”；</p><p>字段描述符即<strong>descriptor_index</strong>值为0x0006指向常量池字符串“I”，至此我们可以推断出该字段为<code> private int m</code></p><h1 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h1><p>与字段表集合相似，方法表集合也依次采用了：访问标志<strong>access_flags</strong>、名称索引<strong>name_index</strong>、描述符索引<strong>descriptor_index</strong>、属性表集合<strong>attributes</strong>；</p><p>方法中的代码编译为字节码后存放在<strong>方法属性表集合</strong>的Code属性中</p><p>如图：</p><p>第一个u2类型数据表示集合中有两个方法；</p><p>第一个方法的访问标志值为0x0001，即public；</p><p>名称索引值为0x0007，对应常量池方法名为<int>；</p><p>描述索引值为0x0008，对应常量为（）v；</p><p>属性表计数器值为0x0001，表示此方法仅有1个属性，属性名为索引值0x0009对应的常量</p><img src="http://img.lbkzw.cn/img/20200830122620.png" alt="screenshot_2020_08_28T15_59_53+0800" style="zoom:50%;" /><img src="http://img.lbkzw.cn/img/20200830122704.png" alt="screenshot_2020_08_28T16_00_05+0800" style="zoom:50%;" /><h1 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h1><p>class文件、字段表、方法表都有自己的属性表集合；</p><p>虚拟机规范预定义属性：</p><p>对于每个属性，它的名称都要从常量池中引用一个<strong>CONSTANT_Utf-8_info</strong>类型常量来表示；</p><p>属性值的结构是完全自定义的，仅需通过一个u4说明属性值占有位数即可</p><h2 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h2><p>接口与抽象类中不存在Code属性，</p><p>如图：<img src="http://img.lbkzw.cn/img/20200830122905.png" alt="screenshot_2020_08_28T17_43_41+0800" style="zoom:50%;" /></p><p><strong>attribute_name_index</strong>代表该属性的名称，它指向了<strong>CONSTANT_Utf-8_info</strong>类型常量“Code”；</p><p><strong>attribute_length</strong>表示属性值长度，属性值长度为属性表长度减去6个字节（<strong>attribute_name_index</strong>与<strong>attribute_length</strong>共占6个字节）；</p><p><strong>max_stack</strong>表示操作栈的最大深度值，虚拟机需要根据这个值来确定栈帧中操作栈的深度；</p><p><strong>max_locals</strong>表示局部变量需要的存储空间，单位为变量槽即分配局部变量时的最小单位，32位数据类型用1个变量槽，64位数据类型用2个变量槽如double、long；</p><ol><li><strong>变量槽重用：</strong>当执行的代码超过一个变量的作用域时，此变量的变量槽可被其它局部变量<strong>重用</strong>；</li><li><strong>max_locals的大小：</strong>javac编译器将根据变量作用域大小分配变量槽给各个变量，根据同时存在的最大局部变量数量和类型计算出max_locals的大小</li></ol><p>code_length用于存储编译后所得字节码的长度，code用于存储编译后所得的字节码指令；</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql for cmd</title>
      <link href="2022/03/20/mysql-00/"/>
      <url>2022/03/20/mysql-00/</url>
      
        <content type="html"><![CDATA[<p>初始化数据库：<code>mysqld --initialize --console</code></p><p>安装数据库：<code>mysqld install</code></p><p>启动mysql服务：<code>net start mysql</code></p><p>终止mysql服务：<code>net stop mysql</code></p><p>创建数据库到创建表：</p><p><img src="http://img.lbkzw.cn/img/20200917142838.png" alt="image-20200917142838617"></p><p>创建了一个名为db4的数据库，并选择数据库db4，在其中创建一个装有数据名为user的表。</p><h2 id="MySQL提示使用ALTERUSER语句修改密码"><a href="#MySQL提示使用ALTERUSER语句修改密码" class="headerlink" title="MySQL提示使用ALTERUSER语句修改密码"></a>MySQL提示使用ALTERUSER语句修改密码</h2><p>安装mysql 登陆后，添加数据库时提示：<code>ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</code></p><p>解决方式如下：</p><p>MySQL版本5.7.6版本以前用户可以使用如下命令：</p><p> <code>SET PASSWORD = PASSWORD(&#39;新密码&#39;); </code></p><p>MySQL版本5.7.6版本开始的用户可以使用如下命令：</p><p><code> ALTER USER USER() IDENTIFIED BY &#39;新密码&#39;;</code></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell入门</title>
      <link href="2022/03/20/shell-01/"/>
      <url>2022/03/20/shell-01/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>变量分为用户变量与系统变量</li><li>为变量赋值时“=”号两边不能有空格</li><li>可在``中写入命令，并将其交给变量引用，也可采用：       变量=$(命令 )     达到相同的效果</li></ul><pre><code class="shell">#!/bin/bash  #头文件，表明此脚本使用bash shell编写echo &quot;hello,world!&quot; #打印字符串echo &quot;PATH=$PATH&quot; #$表示变量引用，此处引用的是系统变量echo &quot;user=$USER&quot;A=100echo &quot;A=$A&quot; #打印用户定义的变量unset#扰乱，就是删除前一个变量的值echo &quot;A=$A&quot;RESULT=`ls -l /home`#这个变量引用一个命令ls -l /homeecho $RESULT #打印这个变量（命令运行的结果）echo &quot;&quot;MY_DATE=$(date)#这个变量引用一个命令dateecho &quot;data=$MY_DATE&quot;</code></pre><h3 id="环境变量（全局变量）"><a href="#环境变量（全局变量）" class="headerlink" title="环境变量（全局变量）"></a>环境变量（全局变量）</h3><ul><li>在/etc/profile 文件中定义环境变量<code>TOMCAT_HOME=/opt/tomcat export TOMCAT_HOME</code>export将 shell 变量输出为环境变量</li><li>定义环境变量后使用<code>source /etc/profile</code>让其生效</li></ul><pre><code class="shell">#!/bin/bash:&lt;&lt;!注释代码块使用:&lt;&lt;!将要被注释的代码块!echo &quot;hello,world!&quot;echo &quot;PATH=$PATH&quot;echo &quot;user=$USER&quot;a=100echo &quot;a=$a&quot;unsetecho &quot;a=$a&quot;RESULT=`ls -l /home`echo $RESULTecho &quot;&quot;MY_DATE=$(date)echo &quot;data=$MY_DATE&quot;!echo $TOMCAT_HOMEreadonly B=10#静态变量无视unsetunsetecho $B       </code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/28/ZEUp9VBFqQoKJGW.png" alt="image-20200728224210596"  /></p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><pre><code class="shell">#!/bin/bashecho $$#当前进程的进程号(PID)./a.sh &amp; #执行此脚本，后台运行echo $! #后台运行的进程号echo $? #上一次执行命令返回的状态（0为正常，否则上一个命令没有正确执行）~        </code></pre><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><pre><code class="shell">#!/bin/bashecho &quot;$0 $1 $2&quot; #分别对应第 0 1 2个位置参数 ，0对应命令本身，如下图 参数1对应4、参数2对应5 echo $* #所有位置参数（不包括位置0），将其作为整体对待echo $@  #所有位置参数（不包括位置0），将其分别对待echo $#    #所有位置参数个数（不包括位置0）</code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/QHgrA1v4Y5lCZjT.png"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>3种书写形式：<ol><li><code>$((运算式))</code></li><li><code>$[运算式]</code></li><li><code>expr m + n</code> <code>expr m - n</code>   注意 expr 运算符间要有空格<br>  乘,除,取余：<code>expr \*, /, %</code></li></ol></li></ul><pre><code class="shell">#!/bin/bash#注意运算符前后的空格，必须有哦A=$((4 + 8))B=$[4 * 8]C=`expr 4 \* 8`echo &quot;$A&quot;echo &quot;$B&quot;echo &quot;$C&quot;</code></pre><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>常用判断条件<ol><li>两个整数的比较<br>= 字符串比较<br>-lt 小于<br>-le 小于等于<br>-eq 等于<br>-gt 大于<br>-ge 大于等于-ne 不等于</li><li>按照文件权限进行判断<br>-r 有读的权限 [ -r 文件 ]<br>-w 有写的权限<br>-x 有执行的权限</li><li>按照文件类型进行判断<br>-f 文件存在并且是一个常规的文件<br>-e 文件存在<br>-d 文件存在并是一个目录</li></ol></li></ul><pre><code class="shell">#!/bin/bash#比较字符串if [ &quot;b&quot; = &quot;b&quot; ]then        echo &quot;Yes&quot;fi#比较数值if [ 4 -eq 4 ]then        echo &quot;Yes&quot;fi#判断文件if [ -d /home ]then#满足条件执行：        echo &quot;Yes&quot;       fi #if反过来结尾</code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul><li>if elif </li></ul><pre><code class="shell">#!/bin/bashif [ $0 = &quot;./a.sh&quot; ]#注意[ 之间的 ]空格then        echo &quot;Yes&quot;elif [ $1 -eq 4 ]then        echo &quot;Yes&quot;elif [ $2 = &quot;b&quot; ]then        echo &quot;Yes&quot;fi              </code></pre><p>运行结果：</p><p><img src="https://i.loli.net/2020/07/30/PoYBhMnImCUqXJc.png"></p><ul><li>case</li></ul><pre><code class="shell">#!/bin/bashcase $1 in&quot;1&quot;)echo &quot;Yes&quot;;;&quot;2&quot;)#位置参数1的值为2时执行echo &quot;No&quot;;;*)#以上所有条件都不满足则执行echo &quot;All&quot;;;esac#case反写作结尾                                                                                    </code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/6OljZLWC3aex4tc.png"></p><ul><li><p>for</p><ol><li><p>for in</p><pre><code class="shell">#!/bin/bashfor i in &quot;$@&quot;doecho &quot;对单个进行处理=$i&quot;doneecho &quot;&quot;for i in &quot;$*&quot;doecho &quot;作为整体对待=$i&quot;done#表示循环结束~           </code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/zZ9bsm1BAxUaDpg.png"></p></li><li><p>for常规</p><pre><code class="shell">#!/bin/bashSUM=0#赋值运算符前后不能有空格for((i=1;i&lt;=10000;i++))#for循环（（））中运算符的空格可有可无doSUM=$[$SUM+$i]#像这样两个变量与运算符直接有无空格均可doneecho &quot;sum=$SUM&quot;</code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/V9IDSofWYpbBCx4.png"></p></li></ol></li><li><p>while</p></li></ul><pre><code class="shell">#!/bin/bashSUM=0i=0while [ $i -lt $1 ]#[]内外两边均有空格，需要注意。doSUM=$[$SUM+$i]i=$[$i+1]doneecho &quot;sum=$SUM&quot;                      </code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/2aT39NuVMWvfQsw.png"></p><h2 id="从控制台读入"><a href="#从控制台读入" class="headerlink" title="从控制台读入"></a>从控制台读入</h2><pre><code class="shell">#!/bin/bashread -p &quot;你是一个哈皮（Yes/No）?&quot; WHY#-p即附带提示，WHY保存输入值echo &quot;$WHY&quot;read -t 10 -p &quot;你是一个哈皮（Yes/No）?&quot; WHY#-t计时，超过定义的10s即停止输入echo &quot;$WHY&quot;</code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/aBqlR1KXzOfinP2.png"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>系统函数</p><ol><li><p>basename [string] [suffix]<br>删掉所有的前缀包括最后一个(‘/’)字符,然后将余下的字符串显示出来。<br>指定了suffix,basename命令会将指定的后缀也去掉</p></li><li><p>dirname<br>返回完整路径最后 / 的前面的部分</p></li></ol></li></ul><p>运行结果：<img src="https://i.loli.net/2020/07/30/dieGZhJHgxpIqoW.png"></p><ul><li>自定义函数</li></ul><pre><code>#!/bin/bashfunction getSum()&#123;#不用写参数SUM=$[$2 + $1]echo &quot;sum=$SUM&quot;&#125;getSum $1 $2#方法名后面是传入的参数~                  </code></pre><p>运行结果：<img src="https://i.loli.net/2020/07/30/i6Vl2WEH9ro31qS.png"></p><h2 id="GitHub自动提交远程库实例"><a href="#GitHub自动提交远程库实例" class="headerlink" title="GitHub自动提交远程库实例"></a>GitHub自动提交远程库实例</h2><p>shell的内容：</p><pre><code class="shell">#!/bin/bashGITPATH=/home/garfield/文档 #本地仓库路径ADD=$(git add .) #添加所有文件到暂存区DATE=$(date +%y%m%d)GITPUSH=$(git push blog master)#推送到远程库GITPULL=$(git pull blog master)#同步远程库到本地（防止冲突）cd $GITPATH$ADDgit commit -m &quot;$DATE&quot;#提交到版本库并备注时间$GITPULL$GITPUSH~         ~                </code></pre><p>运行结果<img src="https://i.loli.net/2020/07/30/v6ble3USd8YIgpk.png"></p><p>定时任务内容：</p><pre><code>*20*** /home/garfield/文档/git_push.sh</code></pre><p><img src="https://i.loli.net/2020/07/30/4okIgw3ZSYuJ7s8.png"> </p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础</title>
      <link href="2022/03/20/sql-01/"/>
      <url>2022/03/20/sql-01/</url>
      
        <content type="html"><![CDATA[<h1 id="常见注释"><a href="#常见注释" class="headerlink" title="常见注释"></a>常见注释</h1><ul><li>– 很少支持</li><li>#行内注释</li><li>/**/段落注释</li></ul><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><table><thead><tr><th align="center">语法</th><th align="center">作用</th><th align="center">例子</th><th>释义</th></tr></thead><tbody><tr><td align="center">select</td><td align="center">查找列，并返回行</td><td align="center">select prod_name from products；<br/>#可使用,分隔列名来查找多个列。</td><td>查找prod_name列，并返回其下的所有行，在products表中。</td></tr><tr><td align="center">*</td><td align="center">通配符</td><td align="center">select * from products；</td><td>查找所有列并返回所有行，在products表中。</td></tr><tr><td align="center">distinct</td><td align="center">返回不重复的值</td><td align="center">select  distinct vend_id from products；<br/>#不可配合通配符使用除非所有列完全相同</td><td>查找vend_id列并返回其下所有行中不重复的值，在products表中。</td></tr><tr><td align="center">limit</td><td align="center">限制</td><td align="center">select prod_name from products limit 5,5;</td><td>查找prod_name列并返回其下第5行起5行的值，在products表中。</td></tr></tbody></table><h3 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h3><table><thead><tr><th>语法</th><th>作用</th><th>例子</th><th>释义</th></tr></thead><tbody><tr><td>order by</td><td>排序</td><td>select prod_id,prod_price,prod_name<br/>from Products<br/>order by 2;<br/>#默认升序（ASC）排列<br/>#指定按多个列排列时：仅当指定的第一列中有重复元素时，才对其（存在重复值的）按指定的下一列进行排序。</td><td>即按照查找的第二个列进行排序，也可指定列名（prod_price）</td></tr><tr><td>desc</td><td>降序</td><td>select prod_id,prod_price,prod_name<br/>from Products<br/>order by 2 DESC,3 desc;</td><td>即按照查找的第二个列进行降序排序，desc仅对其前的列有效；</td></tr></tbody></table><h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><table><thead><tr><th>语法</th><th>作用</th><th>例子</th><th>释义</th></tr></thead><tbody><tr><td>where</td><td>在客户端过滤数据</td><td>select *<br/>from Products<br/>where prod_price &gt;= 5.99<br/>order by prod_price desc;<br/>#同排序操作一同使用时，不得位于排序操作之前#支持&lt;&gt;=!=等操作，其中&lt;&gt;操作等同于!=<br/>例：<br/>select *<br/>from Products<br/>where prod_id &lt;&gt;’fc’<br/>order by prod_price desc;<br/>#过滤字符串不区分大小写</td><td>1.查找所有列，在Products表中，并返回prod_price &gt;=5.99的所有行<br/>2.查找所有列，在Products表中，并返回除prod_id = “fc”之外的所有行</td></tr><tr><td>between</td><td>值的范围过滤</td><td>select  prod_name,prod_price<br/>from Products<br/>where prod_price between 4 and 10</td><td>查找prod_name,prod_price两列在Products表中，并返回prod_price值为4-10范围内的的的所有行</td></tr><tr><td>is</td><td>可用来检查null（空值）</td><td>select  prod_name,prod_price<br/>from Products<br/>where prod_price is null</td><td>返回所有没有价格的商品</td></tr><tr><td>and,or</td><td>逻辑操作符<br/>and且<br/>or与，这里是短路的</td><td>select  *<br/>from Products<br/>where vend_vend_id =’1001’ and prod_price &lt;=4;<br/>#and的优先级比or要高，and，or共同使用时为避免错误应用（）明确分组，<br/>#也可使用in代替or，例：<br/>select prod_name,prod_price from products where vend_id in(‘1001’,’1002’)<br/>order by prod_name<br/>等同于：<br/>select prod_name,prod_price from products where vend_id = ‘1001’ or vend_id = ‘1002’<br/>order by prod_name</td><td>返回所有vend_vend_id =’1001’ 且 prod_price &lt;=4;的行</td></tr><tr><td>not</td><td>否定其后的条件</td><td>select prod_name,prod_price from products where not vend_id in(‘1001’,’1002’)<br/>order by prod_name</td><td>可与in连用，返回vend_id=1001 vend_id=1002外的所有行</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="通配符搜索"><a href="#通配符搜索" class="headerlink" title="通配符搜索"></a>通配符搜索</h3><table><thead><tr><th align="center">语法</th><th align="center">作用</th><th>例子</th></tr></thead><tbody><tr><td align="center">%</td><td align="center">匹配0、1或多个字符包含空格。不会匹配到null</td><td>select prod_name<br/>from products<br/>where prod_name like ‘f%%’</td></tr><tr><td align="center">_</td><td align="center">匹配单个字符，包含空格</td><td>select prod_name<br/>from products<br/>where prod_name like ‘fuse_’</td></tr><tr><td align="center">rtrim（）ltrim（）</td><td align="center">去除右边、左边空格</td><td></td></tr></tbody></table><blockquote><h4 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h4></blockquote><pre><code class="mysql">select prod_id ,quantity,item_price,quantity*item_price as expanded_pricefrom orderitemswhere order_num = 20008;#如上创建了一个expanded_price字段（quantity*item_price的结果的别名），其仅在此时有效而不会存放到表中。</code></pre><blockquote><h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4></blockquote><pre><code class="mysql">select vend_name, upper(vend_name) as vend_name_upcasefrom vendors#将vend_name列下的所有行以大写形式返回select avg(prod_price) as avg_peice from products where vend_id =&#39;1001&#39;#返回平均值select count(*) as num_cust from customers#返回长度（数目），也可对列表中特定值进行计数</code></pre><blockquote><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4></blockquote><pre><code class="mysql">select  vend_id,count(*) as num_prods from  products #对vend_id每行进行计数group by vend_id;#按照vend_id排序并分组select cust_id,count(*) as ordersfrom orders group by cust_id having count(*)&gt;=2#过滤分组中&gt;=2的，having支持where的所有操作select order_num,count(*) as itemsfrom orderitems group by order_numhaving count(*) &gt;=3order by items,order_num desc#对分组依照选定的列进行排序</code></pre><blockquote><h4 id="子句查询"><a href="#子句查询" class="headerlink" title="子句查询"></a>子句查询</h4></blockquote><pre><code class="mysql">select cust_name,cust_contact from customers where cust_id =(select cust_id from orderswhere order_num = (select order_num from orderitems where prod_id = &#39;jp2000&#39;));#由内而外，哈哈等效于：select order_num from orderitemswhere prod_id = &#39;jp2000&#39;；select cust_id from orderswhere order_num =20006select cust_name,cust_contact from customers where cust_id =10003</code></pre><h3 id="联结（返回不在同一个表中的行）"><a href="#联结（返回不在同一个表中的行）" class="headerlink" title="联结（返回不在同一个表中的行）"></a>联结（返回不在同一个表中的行）</h3><pre><code class="mysql">/*等值语法*/select vend_name, prod_name,prod_pricefrom vendors,productswhere vendors.vend_id=products.vend_id;#此处过滤联结条件。#如没有联结条件过滤，将检索出“笛卡尔积”：表1行数*表2行数/*规范语法*/select vend_name, prod_name,prod_pricefrom vendors inner join productson vendors.vend_id=products.vend_id</code></pre><h3 id="自联结（比子查询更快）"><a href="#自联结（比子查询更快）" class="headerlink" title="自联结（比子查询更快）"></a>自联结（比子查询更快）</h3><pre><code class="mysql">/*子查询*/select cust_id, cust_name, cust_contactfrom customerswhere cust_name = (select cust_name from customers where cust_contact =&#39;jim jones&#39;);/*自联结*/select c1.cust_id, c1.cust_name,c1.cust_contactfrom customers as c1,customers as c2#不以别名进行会引发错误where c1.cust_name=c2.cust_name and c2.cust_contact=&#39;jim jones&#39;#联结cust_name与c2.cust_name ，并过滤cust_contact=&#39;jim jones&#39;的行/*（c1的cust_name同c2相同，找到了c2的cust_contact=&#39;jim jones&#39;也就相当于找到了c1cust_contact=&#39;jim jones&#39;，知道了cust_contact=&#39;jim jones&#39;就可知道cust_id）*/</code></pre><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><pre><code class="mysql">select cust_name,cust_contact,cust_email,cust_statefrom customerswhere cust_state in(&#39;il&#39;,&#39;in&#39;,&#39;mi&#39;)union  #组合上下select多个select之间需要多个union分隔，union默认排除重复，union all则不排除select cust_name,cust_contact,cust_email,cust_state#union中每个查询必须包含相同的列、表达式、或聚集函数from customerswhere cust_name =&#39;wascals&#39;order by cust_name;#不能分别对每条union指定不同的排序</code></pre><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><h3 id="依赖于次序的插入"><a href="#依赖于次序的插入" class="headerlink" title="依赖于次序的插入"></a>依赖于次序的插入</h3><pre><code class="mysql">/*在得知列的次序后才可使用此方式添加，若发生了列的次序变动此添加方式将不安全*/insert into customersvalues(&#39;1000000006&#39;,&#39;toy land&#39;,&#39;123 any street&#39;,&#39;new york&#39;,&#39;ny&#39;, &#39;11111&#39;,&#39;usa&#39;,null, null);#依赖于次序的插入，必须为每一列提供一个值，如某列无添加则应写上null</code></pre><h3 id="提供列名的插入"><a href="#提供列名的插入" class="headerlink" title="提供列名的插入"></a>提供列名的插入</h3><pre><code class="mysql">insert into customers(cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip)#必须为提供了列名的列给出一个值values(null, null,&#39;1000000006&#39;,&#39;toy land&#39;,&#39;123 any street&#39;,&#39;new york&#39;,&#39;ny&#39;, &#39;11111&#39;);</code></pre><h3 id="从另一个表插入"><a href="#从另一个表插入" class="headerlink" title="从另一个表插入"></a>从另一个表插入</h3><pre><code class="mysql">insert into 表名（列名）select 列名from 表名where 过滤</code></pre><blockquote><h4 id="复制一个表"><a href="#复制一个表" class="headerlink" title="复制一个表"></a>复制一个表</h4></blockquote><pre><code class="mysql">/*sql*/select * into custcopy from customers;/* mysql*/create table custcopy asselect * from customers;</code></pre><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><pre><code class="mysql">update customersset cust_email = &#39;kim@@thetoystore.com&#39;where cust_id = &#39;100000000005&#39;#如不指定，将更新customers表cust_email列下的所有行</code></pre><h3 id="更新多个列"><a href="#更新多个列" class="headerlink" title="更新多个列"></a>更新多个列</h3><pre><code class="mysql">update customersset cust_email = &#39;kim@@thetoystore.com&#39;,cust_contact=&#39;sam roberts&#39;where cust_id = &#39;100000000006&#39;</code></pre><h2 id="DELLETE"><a href="#DELLETE" class="headerlink" title="DELLETE"></a>DELLETE</h2><pre><code class="mysql">delete from customerswhere cust_id = &#39;1000000006&#39;#删除此行，不过滤则删除所有行#update删除列#truncate删除表</code></pre><h2 id="添加删除列-amp-amp-表"><a href="#添加删除列-amp-amp-表" class="headerlink" title="添加删除列&amp;&amp;表"></a>添加删除列&amp;&amp;表</h2><pre><code class="mysql">/*添加表时为防止覆盖，应删除表后再进行添加*/create table orderitems(order_num integer not null,order_item integer not null,prod_id char(10) not null,quantity integer not null default 1,#设置quantity列下的行默认值为1item_price decimal(8,2) not null);#not null即不允许填入null，默认可填入null，只有为 not null的列方可为主键及唯一标识</code></pre><pre><code class="mysql">/*add列*/alter table vendorsadd vend_phone char (20);/*del列*/alter table vendorsdrop column vend_phone;#此操作不可逆/*删除表*/drop table custcopy;#此操作不可逆</code></pre><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><pre><code class="mysql">create view#创建视图drop view 视图名#删除视图/*以视图简化联结，创建视图*/create view productcustomers asselect cust_name , cust_contact,prod_idfrom customers,orders,orderitemswhere customers.cust_id=orders.cust_idand orderitems.order_num=orders.order_num;/*可对视图采取与表相同的查询操作*/select *from productcustomers;/*一个视图过滤查询例子*/create view customeremaillist asselect cust_id, cust_name,cust_emailfrom customerswhere cust_email is not null;#返回查询中所有cust_email不为空的，并将其添加到视图中/*视图计算字段例子*/create view orderitemsexpanded as select order_num,prod_id,quantity,item_price,quantity*item_price,quantity*item_price asexpanded_pricefrom orderitems</code></pre><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><pre><code>/*撤销整体*/start transaction ;-- 标识事务处理块,块中内容未执行完则整体撤销/*撤销部分操作*/savepoint delete1;#标识rollback to delete1;返回标识delete1</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程方法</title>
      <link href="2022/03/20/thread-01/"/>
      <url>2022/03/20/thread-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现多线程必须继承<strong>Thread</strong>类，已有父类的类可通过实现<strong>Runnable</strong>实现多线程</p><p><strong>Thread</strong>也实现了<strong>Runnable</strong>接口，<strong>Runnable</strong>接口实现的多线程步骤比<strong>Thread</strong>更为繁琐</p></blockquote><h1 id="线程安全共享变量"><a href="#线程安全共享变量" class="headerlink" title="线程安全共享变量"></a>线程安全共享变量</h1><ul><li>这是一个不共享变量的线程：</li></ul><pre><code class="java">package cn.day.b2;public class MyThread extends Thread &#123;    private int count = 5;    public MyThread(String name)&#123;        super();        this.setName(name);    &#125;    @Override    public void run()&#123;        super.run();        while (count &gt; 0)&#123;            count--;            System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot;计算， count =&quot; + count);        &#125;    &#125;        public static void main(String[] args) &#123;        MyThread a = new MyThread(&quot;A&quot;);        MyThread b = new MyThread(&quot;B&quot;);        MyThread c = new MyThread(&quot;C&quot;);        a.start();        b.start();        c.start();    &#125;&#125;</code></pre><ul><li>可能出现多个线程同时修改变量（不安全）的情况</li></ul><pre><code class="java">package cn.day.b2;public class MyThread extends Thread &#123;    private int count = 5;    @Override    public void run()&#123;        super.run();            count--;            System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot;计算， count =&quot; + count);    &#125;    public static void main(String[] args) &#123;        var mythread = new MyThread();        var a = new Thread(mythread,&quot;A&quot;);        var b = new Thread(mythread,&quot;B&quot;);        var c = new Thread(mythread,&quot;C&quot;);        var d = new Thread(mythread,&quot;D&quot;);        var e = new Thread(mythread,&quot;E&quot;);//分配新的 Thread 对象，以便将 mythread 作为其运行对象，将指定的 E 作为其名称        a.start();        b.start();        c.start();        d.start();        e.start();    &#125;&#125;</code></pre><ul><li>安全的共享变量（添加互斥区）</li></ul><pre><code class="java">package cn.day.b2;public class MyThread extends Thread &#123;    private int count = 5;    @Override    synchronized public void run()&#123;//加入锁，只有等一个线程停止后另一个线程才能调用run（）方法        super.run();            count--;            System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot;计算， count =&quot; + count);    &#125;    public static void main(String[] args) &#123;        var mythread = new MyThread();        var a = new Thread(mythread,&quot;A&quot;);        var b = new Thread(mythread,&quot;B&quot;);        var c = new Thread(mythread,&quot;C&quot;);        var d = new Thread(mythread,&quot;D&quot;);        var e = new Thread(mythread,&quot;E&quot;);        a.start();        b.start();        c.start();        d.start();        e.start();    &#125;&#125;</code></pre><h1 id="run-与start"><a href="#run-与start" class="headerlink" title="run( )与start( )"></a>run( )与start( )</h1><ul><li>**run( )**立即执行，不创建新的线程。</li><li><strong>start( )</strong>,创建新线程并用其执行。</li><li><strong>run( )**的执行顺序与</strong>start( )**顺序无关</li></ul><h1 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h1><ul><li>返回对当前正在执行的线程对象的引用</li></ul><pre><code class="java">package cn.day.b2.currentThreadExt;public class CountOperate extends Thread &#123;    public CountOperate()&#123;        System.out.println(&quot;CountOperate---begin&quot;);        System.out.println(&quot;Thread.currentThread().getName()=&quot; + Thread.currentThread().getName());//返回对当前正在执行的线程对象的引用        System.out.println(&quot;this.getName()= &quot; +  this.getName());//this指代带CountOperate对象，CountOperate对象的名字并未发生改变，故默认线程名为Thread-0        System.out.println(&quot;CountOperate---end&quot;);    &#125;    @Override    public void run()&#123;        System.out.println(&quot;run---begin&quot;);        System.out.println(&quot;Thread.currentThread.getName()=&quot;+ Thread.currentThread().getName());        System.out.println(&quot;this.getName() =&quot; + this.getName());//此时线程名为“B”        System.out.println(&quot;run---end&quot;);    &#125;&#125;package cn.day.b2.currentThreadExt;public class Run &#123;    public static void main(String[] args) &#123;        var c = new CountOperate();        c.setName(&quot;B&quot;);//调用构造器之前并未指定线程名称        var t1 = new Thread(c);        t1.setName(&quot;A&quot;);        t1.start();    &#125;&#125;/*运行结果*CountOperate---beginThread.currentThread().getName()=mainthis.getName()= Thread-0CountOperate---endrun---beginThread.currentThread.getName()=Athis.getName() =Brun---end*/</code></pre><h1 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive( )"></a>isAlive( )</h1><ul><li>判断线程是否存活</li></ul><pre><code class="java">package cn.day.b3;public class CountOperate extends Thread &#123;    public CountOperate()&#123;//构造函数时主线程main确认存活        System.out.println(&quot;CountOperate---begin&quot;);        System.out.println(&quot;Thread.currentThread().getName()= &quot; + Thread.currentThread().getName());        System.out.println(&quot;Thread.currentThread().isAlive()= &quot; + Thread.currentThread().isAlive());        System.out.println(&quot;this.getName() =&quot; + this.getName());        System.out.println(&quot;this.isAlive() =&quot; + this.isAlive());        System.out.println(&quot;CountOpreate---end&quot;);    &#125;    @Override    public void run()&#123;        System.out.println(&quot;run---begin&quot;);        System.out.println(&quot;Thread.currentThread().getName() =&quot; + Thread.currentThread().getName());        System.out.println(&quot;Thread.currentThread().isAlive() =&quot; + Thread.currentThread().isAlive());        System.out.println(&quot;this.getName() =&quot; + this.getName());        System.out.println(&quot;this.isAlive() =&quot; + this.isAlive());//为false，而重命名的A线程存活        System.out.println(&quot;run---end&quot;);    &#125;    public static void main(String[] args) &#123;        var c = new CountOperate();//构造完对象后，main线程失活为false        var t1 = new Thread(c);//main线程又存活了        System.out.println(&quot;main begin t1 isAlive=&quot; + t1.isAlive());//isAlive()判断该线程是否存活        t1.setName(&quot;A&quot;);        t1.start();        System.out.println(&quot;main end t1 isAlive=&quot; + t1.isAlive());    &#125;&#125;</code></pre><h1 id="sleep（）"><a href="#sleep（）" class="headerlink" title="sleep（）"></a>sleep（）</h1><ul><li>使线程休眠</li></ul><pre><code class="java">package cn.day.b3;public class MyThread2 extends Thread &#123;    @Override    public void run()&#123;        try &#123;            System.out.println(&quot;run threadName=&quot; + this.currentThread().getName() + &quot;begin =&quot; + System.currentTimeMillis());            //currentTimeMillis()返回以毫秒为单位的当前时间            Thread.sleep(2000);//线程休眠2s            System.out.println(&quot;run threadName=&quot; + this.currentThread().getName() + &quot;end =&quot; + System.currentTimeMillis() );        &#125;catch (InterruptedException e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        var mythread = new MyThread2();        System.out.println(&quot;begin =&quot; + System.currentTimeMillis());        mythread.start();        System.out.println(&quot;end =&quot; + System.currentTimeMillis());        /*begin =1594439524699  main线程执行100多毫秒            end =1594439524710            run threadName=Thread-0begin =1594439524710 Thread线程执行2s多            run threadName=Thread-0end =1594439526721*/    &#125;&#125;</code></pre><h1 id="线程堆栈方法"><a href="#线程堆栈方法" class="headerlink" title="线程堆栈方法"></a>线程堆栈方法</h1><h2 id="StackTraceElement-getStackTrace"><a href="#StackTraceElement-getStackTrace" class="headerlink" title="StackTraceElement[] getStackTrace( )"></a>StackTraceElement[] getStackTrace( )</h2><ul><li>返回一个表示该线程堆栈跟踪元素的数组。（线程未启动或终止则返回length为0的数组即null）</li></ul><pre><code class="java">package cn.day.b3;public class Test &#123;    public void a()&#123;        b();    &#125;    public void b()&#123;        c();    &#125;public void c()&#123;        d();    &#125;public void d()&#123;        e();    &#125;    public void e()&#123;        StackTraceElement[] array = Thread.currentThread().getStackTrace();        if (array != null)&#123;            for (int i = 0; i &lt; array.length; i++)&#123;                var eachElement = array[i];                System.out.println(&quot;className=&quot; + eachElement.getClassName() + &quot; methodName=&quot; + eachElement.getMethodName() + &quot; fileName=&quot;                + eachElement.getFileName() + &quot; lineNumber=&quot;+eachElement.getLineNumber());                //eachElement.getClassName()返回包含由该堆栈跟踪元素表示的执行点的类的全限定名。                //eachElement.getMethodName()返回包含由该堆栈跟踪元素所表示的执行点的方法的名称                //eachElement.getLineNumber()返回包含由该堆栈跟踪元素表示的执行点源极线的行号            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        var test = new Test();        test.a();    &#125;&#125;/*结果：className=java.lang.Thread methodName=getStackTrace fileName=Thread.java lineNumber=1598className=cn.day.b3.Test methodName=e fileName=Test.java lineNumber=15 // 最后（最新）调用的为栈顶className=cn.day.b3.Test methodName=d fileName=Test.java lineNumber=12className=cn.day.b3.Test methodName=c fileName=Test.java lineNumber=10className=cn.day.b3.Test methodName=b fileName=Test.java lineNumber=8className=cn.day.b3.Test methodName=a fileName=Test.java lineNumber=5//最先的调用为栈底className=cn.day.b3.Test methodName=main fileName=Test.java lineNumber=27*/</code></pre><h2 id="dumpStack"><a href="#dumpStack" class="headerlink" title="dumpStack( )"></a>dumpStack( )</h2><ul><li>将当前线程堆栈跟踪信息输出至标准错误流</li></ul><pre><code class="java">package cn.day.b3;public class Test &#123;    public void a()&#123;        b();    &#125;    public void b()&#123;        c();    &#125;public void c()&#123;        d();    &#125;public void d()&#123;        e();    &#125;    public void e()&#123;       int age = 0;       age = 100;       if (age == 100)&#123;           Thread.dumpStack();//将当前线程堆栈跟踪信息输出至标准错误流       &#125;    &#125;    public static void main(String[] args) &#123;        var test = new Test();        test.a();    &#125;&#125;/*结果java.lang.Exception: Stack trace    at java.base/java.lang.Thread.dumpStack(Thread.java:1379)    at cn.day.b3.Test.e(Test.java:18)    at cn.day.b3.Test.d(Test.java:12)    at cn.day.b3.Test.c(Test.java:10)    at cn.day.b3.Test.b(Test.java:8)    at cn.day.b3.Test.a(Test.java:5)    at cn.day.b3.Test.main(Test.java:24)    */</code></pre><h2 id="staric-Map-lt-Thread-StackTraceElement-gt-getAllStackTraces"><a href="#staric-Map-lt-Thread-StackTraceElement-gt-getAllStackTraces" class="headerlink" title="staric Map&lt;Thread,StackTraceElement[]&gt; getAllStackTraces( )"></a>staric Map&lt;Thread,StackTraceElement[]&gt; getAllStackTraces( )</h2><ul><li>返回所有活动线程的堆栈跟踪（映射）信息</li><li>映射的键即线程，而每个值都是一个StackTraceElement数组</li></ul><pre><code class="java">package cn.day.b3;import java.util.Iterator;import java.util.Map;public class Test &#123;    public void a()&#123;        b();    &#125;    public void b()&#123;        c();    &#125;public void c()&#123;        d();    &#125;public void d()&#123;        e();    &#125;        public void e()&#123;       Map&lt;Thread,StackTraceElement[]&gt; map = Thread.currentThread().getAllStackTraces();       if (map != null &amp;&amp; map.size() != 0)&#123;           Iterator keyIterator = map.keySet().iterator();           while (keyIterator.hasNext())&#123;               Thread eachThread = (Thread) keyIterator.next();//键即线程               StackTraceElement[] array = map.get(eachThread);//返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。               System.out.println(&quot;------每个线程的基本信息&quot;);               System.out.println(&quot;  线程名称：&quot; + eachThread.getName());               System.out.println(&quot;StackTraceElement[].length=&quot; + array.length);               System.out.println(&quot;  线程状态：&quot; + eachThread.getState());               if (array.length != 0)&#123;                   System.out.println(&quot;输出stackTraceElement[] 数组具体信息：&quot;);                   for (int i = 0; i &lt; array.length; i++) &#123;                       StackTraceElement eachElement = array[i];                       System.out.println(&quot; &quot;+ eachElement.getClassName() + &quot; &quot; +eachElement.getMethodName() +                               &quot; &quot; + eachElement.getFileName() + &quot; &quot; + eachElement.getLineNumber());                   &#125;               &#125;               else &#123;                   System.out.println(&quot;没有StackTraceElement[]信息，因为线程&quot; + eachThread.getName() + &quot;中的StackTraceElement[].length==0&quot;);               &#125;               System.out.println();               System.out.println();           &#125;       &#125;    &#125;    public static void main(String[] args) &#123;        var test = new Test();        test.a();    &#125;&#125;</code></pre><h1 id="getId"><a href="#getId" class="headerlink" title="getId( )"></a>getId( )</h1><ul><li>获取线程Id</li></ul><h1 id="interrupted-、isinterrupted"><a href="#interrupted-、isinterrupted" class="headerlink" title="interrupted( )、isinterrupted( )"></a>interrupted( )、isinterrupted( )</h1><ul><li>**interrupted( )**测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。 </li><li><strong>isinterrupted( )</strong> 测试线程对象是否为中断状态且不清除状态标志。</li></ul><h1 id="interrupt-、中断处理"><a href="#interrupt-、中断处理" class="headerlink" title="interrupt( )、中断处理"></a>interrupt( )、中断处理</h1><ul><li><p>在线程中做一个停止标记，配合异常或<strong>return</strong>终止线程</p></li><li><p><strong>return</strong>中断法</p><pre><code class="java">package cn.day.b4;public class MyThread1 extends Thread &#123;    @Override    public void run( ) &#123;        System.out.println(&quot;线程开始&quot;);        super.run();        if (Thread.interrupted()) &#123;//检测线程状态            System.out.println(&quot;已经停止状态了！&quot;);            return;        &#125;    &#125;    public static void main(String[] args) &#123;            var thread = new MyThread1();            thread.start();            thread.interrupt();//中断该线程    &#125;&#125;</code></pre></li><li><p>异常中断法（一般采用）：可在<strong>catch</strong>块中对异常信息进行统一处理。</p><pre><code class="java">package cn.day.b4;public class MyThread extends Thread &#123;    @Override    public void run( )&#123;        super.run();        try&#123;            for (int i = 0; i &lt; 50000000; i++) &#123;//此循环数值要足够大，否则在main中方法标记中断线程之前循环就结束了//                 if (this.interrupted())&#123;//检测线程状态                 if (Thread.interrupted())&#123;//检测线程状态//                 if (this.isInterrupted())&#123;//检测线程状态                     System.out.println(&quot;已经停止状态了！&quot;);                     throw new InterruptedException();                 &#125;                System.out.println(&quot;i=&quot;+(i + 1));            &#125;        &#125;catch (InterruptedException e)&#123;            System.out.println(&quot;进MyThread.java类run方法中的catch了&quot;);            e.printStackTrace();//打印此throwable及其追踪到标准错误流,错误的栈轨迹等        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            var thread = new MyThread();            thread.start();            Thread.sleep(2000);            thread.interrupt();//中断该线程        &#125;catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;end&quot;);        System.out.println(Thread.interrupted());    &#125;&#125;</code></pre><p><strong>interrupt方法遇到sleep方法（wait也一样）同样会发生异常(中断线程)</strong></p><pre><code class="java">package cn.day.b4;public class MyThread extends Thread &#123;    @Override    public void run() &#123;        super.run();        try &#123;            for (int i = 0; i &lt; 50000; i++) &#123;                System.out.println(&quot;i=&quot; + (i + 1));            &#125;            System.out.println(&quot;run begin&quot;);            Thread.sleep(200000);            System.out.println(&quot;run end&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;进MyThread.java类run方法中的catch了&quot;);            e.printStackTrace();//打印此throwable及其追踪到标准错误流,错误的栈轨迹等        &#125;    &#125;    public static void main(String[] args) &#123;        var thread = new MyThread();        thread.start();        thread.interrupt();//中断该线程        System.out.println(&quot;end&quot;);    &#125;&#125;</code></pre></li></ul><h1 id="其它中断线程的方法（已废弃）"><a href="#其它中断线程的方法（已废弃）" class="headerlink" title="其它中断线程的方法（已废弃）"></a>其它中断线程的方法（已废弃）</h1><p><strong>stop（）</strong></p><ul><li><strong>Stop（）</strong>对线程的停止具有不确定性，如线程在添加元素而不知道添加到哪里就被中断了</li><li>此方法抛出的<strong>ThreadDeath</strong>异常不需要显式捕捉</li><li>此方法用于销毁线程对象，如想重启线程，需使用<strong>Start（）</strong>方法</li></ul><p><strong>suspend( )、resume（）</strong></p><ul><li>**suspend( )**暂停线程，</li><li><strong>resume（）</strong>恢复线程</li><li>易独占公共同步对象，导致其它线程无法访问公共同步对象</li><li>易导致数据不完整</li></ul><p><strong>yield（）</strong></p><ul><li>放弃产品CPU资源，让与其它任务（线程）</li><li>时间不确定：如刚放弃又拾起</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全与通信</title>
      <link href="2022/03/20/thread-02/"/>
      <url>2022/03/20/thread-02/</url>
      
        <content type="html"><![CDATA[<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul><li><p>线程优先级具有可继承性</p></li><li><p>cpu将资源让与优先级更高的线程（运行更快）</p></li><li><p>随机性：并不是执行完高优先级线程再执行低优先级线程，只是说首先执行高优先级线程的概率更大一点</p></li><li><p>可使用**setPriority( )**设置优先级（范围：0-10）</p></li><li><p>Jdk预设了3个优先级值： </p><pre><code>MIN_PRIORITY = 1NORM_PRIORITY = 5MAX_PRIORITY = 10</code></pre></li></ul><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><ul><li>Java中存在<strong>用户线程</strong>、<strong>守护线程</strong>两种线程</li><li>守护线程为其它线程运行提供便利，如GC</li><li>最后一个用户线程、守护线程退出，进程也就结束了（只要有一个用户进程在运行，那么这个进程就不会结束）               </li></ul><pre><code class="java">package cn.day.b4;public class MyThread2 extends Thread &#123;    private int i = 1;    @Override    public void run()&#123;        try &#123;            while (true)&#123;//死循环                System.out.println(&quot;i&quot; + (i));                Thread.sleep(1000);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            var thread = new MyThread2();            thread.setDaemon(false);//这是个用户线程，此进程将不停的执行下去//            thread.setDaemon(false);这是个守护线程，它将随着用户进程（main）的结束而结束            //setDaemon() 将线程标记为守护线程(true)或用户线程(false)。            thread.start();            Thread.sleep(5000);            System.out.println(&quot;end&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><ul><li>对象、变量的并发访问：A线程获得了X对象的锁，此时B线程只能调用X对象中没有synchronized标记的方法</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><ul><li><p>方法中的变量不受线程安全影响，而实例字段（变量）将受到非线程安全的影响</p></li><li><p>当多个线程执行同一个业务对象中的方法时，线程与业务属于多对以一的关系，会产生非线程<strong>安全问题</strong></p><ol><li>可使用synchronized关键词实现同步执行。</li><li>可分别创建两个对象实例（线程与对象方法就是一对一啦），实现异步执行。</li></ol></li><li><p>在方法声明处添加synchronized是锁对象而非锁方法（Java没有锁方法一说）</p></li><li><p>Java中，<strong>锁</strong> 就是<strong>对象</strong>， <strong>对象</strong>可以<strong>映射</strong>为<strong>锁</strong>。线程拿到锁就可以执行对象中的synchronized同步方法</p></li><li><p>线程发生异常时将释放对象锁</p></li></ul><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><ul><li>比如：在main主线程中，一个其它线程正在执行( 原想在结束后main线程再调用某个方法（属性）)，结果main在未结束的线程前调用了（属性）方法，产生了不理想的结果，这就是导致脏读。</li><li>解决方法：对该（属性）方法使用synchronized上锁。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><ul><li><p>已知线程获取了某个对象锁，则其在线程未结束（对象锁未释放）前仍可获取该对象锁（）</p><pre><code class="java">package cn.day.b5;public class Service &#123;    synchronized public void service1()&#123;        System.out.println(&quot;service1&quot;);        service2();    &#125;    synchronized public void service2()&#123;        System.out.println(&quot;service2&quot;);        service3();    &#125;    synchronized public void service3()&#123;        System.out.println(&quot;service3&quot;);    &#125;    public static void main(String[] args) &#123;        var t = new MyThread();        t.start();//在此线程运行时：service1可调用上锁的service2，service2可调用上锁的service3，而不会被线程t2干扰        var t2 = new MyThread1();        t2.start();    &#125;&#125;class MyThread extends Thread&#123;    @Override    public void run()&#123;        Service service = new Service();        service.service1();    &#125;&#125;class MyThread1 extends Thread&#123;    @Override    public void run()&#123;        Service service = new Service();        service.service2();    &#125;&#125;</code></pre></li><li><p>继承状态下，线程还可重入调用父类的（同步）方法</p></li></ul><h2 id="holdsLock（）"><a href="#holdsLock（）" class="headerlink" title="holdsLock（）"></a>holdsLock（）</h2><ul><li>对象持有锁时返回True</li></ul><pre><code class="java">package cn.day.b5;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;A &quot;+Thread.currentThread().holdsLock(Test.class));        synchronized (Test.class)&#123;//synchronized块            System.out.println(&quot;B &quot;+Thread.currentThread().holdsLock(Test.class));        &#125;    &#125;&#125;</code></pre><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><ul><li><p>当某个对象的<strong>synchronized</strong>代码块（this）被某个线程访问时，其它线程将被阻塞，并且不能访问该对象的其它同步代码块</p></li><li><p><strong>synchronized</strong>代码块（）内写入一个类的Class对象，那么这个锁对所有该类实例有效</p></li><li><p>使用同步代码块时：一般不使用String作为对象锁如，而使用Object。</p><pre><code class="java">package cn.day.b5;public class String1 &#123;    public static void print(String t)&#123;        try &#123;            synchronized (t)&#123;//锁的是变量T的值                while (true)&#123;                    System.out.println(Thread.currentThread().getName());                    Thread.sleep(1000);//两个线程传入相同的String值会导致一个线程休眠时另一个线程仍无法执行                &#125;            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        var string1 = new String1();        var a = new Thread1(string1);        a.setName(&quot;A&quot;);        a.start();        var b = new Thread2(string1);        b.setName(&quot;B&quot;);        b.start();    &#125;&#125;class Thread1 extends Thread&#123;    private String1 string1;    public Thread1(String1 string1)&#123;        super();        this.string1 =string1;    &#125;    @Override    public void run()&#123;        string1.print(&quot;AA&quot;);    &#125;&#125;class Thread2 extends Thread&#123;    private String1 string2;    public Thread2(String1 string1)&#123;        super();        this.string2 =string1;    &#125;    @Override    public void run()&#123;        string2.print(&quot;AA&quot;);//两个线程传入相同的String值会导致一个线程休眠时另一个线程仍无法执行    &#125;&#125;</code></pre></li></ul><h2 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h2><ul><li><p>锁对象改变则异步执行，否则依旧同步执行(只要锁对象相同就同步执行 )</p><pre><code class="java">package cn.day.b5;public class String2 &#123;    private String lock = &quot;123&quot;;    public void testMethod()&#123;        try &#123;            synchronized (lock)&#123;                System.out.println(Thread.currentThread().getName()+&quot;begin &quot;+System.currentTimeMillis());                lock =&quot;456&quot;;//改变锁对象                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;end &quot;+ System.currentTimeMillis());            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        var string2 = new String2();        Thread1 a = new Thread1(string2);        a.setName(&quot;A&quot;);        Thread2 b = new Thread2(string2);        a.setName(&quot;B&quot;);        a.start();        Thread.sleep(50);        b.start();    &#125;&#125;class Thread1 extends Thread&#123;    private String2 string1;    public Thread1(String2 string1)&#123;        super();        this.string1 =string1;    &#125;    @Override    public void run()&#123;        string1.testMethod();    &#125;&#125;class Thread2 extends Thread&#123;    private String2 string2;    public Thread2(String2 string1)&#123;        super();        this.string2 =string1;    &#125;    @Override    public void run()&#123;        string2.testMethod();    &#125;&#125;</code></pre></li></ul><h2 id="静态方法的锁"><a href="#静态方法的锁" class="headerlink" title="静态方法的锁"></a>静态方法的锁</h2><ul><li><strong>synchronized</strong>加到<strong>静态方法</strong>是将<strong>Class类</strong>对象作为锁（而<strong>synchronized</strong>加到<strong>非静态</strong>是将方法所在类的对象作为锁）</li><li>如果A类中方法都是静态方法且加锁，那么即使创建两个A类实例对象仍无法实现异步。（静态方法可直接导入类再调用:A.方法名;实现异步）</li></ul><h2 id="volatile（synchronized也可）"><a href="#volatile（synchronized也可）" class="headerlink" title="volatile（synchronized也可）"></a>volatile（<strong>synchronized</strong>也可）</h2><ul><li>让B线程立刻看见A线程更改的数据</li><li>禁止代码重排序</li></ul><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><ul><li>解决资源浪费</li></ul><pre><code class="java">package cn.day.b6;import java.util.ArrayList;import java.util.List;/**线程 Thread2 （B）一直监视list.size造成了资源浪费*/public class MyList &#123;    volatile private List list = new ArrayList();//实现多线程之间的可视性，不然线程B将一直执行    public void add()&#123;        list.add(&quot;1&quot;);    &#125;    public int size()&#123;        return list.size();    &#125;    public static void main(String[] args) &#123;        var service = new MyList();        var a = new Thread1(service);        a.setName(&quot;A&quot;);        a.start();        var b = new Thread2(service);        b.setName(&quot;B&quot;);        b.start();    &#125;&#125;class Thread1 extends Thread&#123;    private MyList list;    public Thread1 (MyList list)&#123;        super();        this.list = list;    &#125;    @Override    public void run()&#123;        try&#123;            for (int i = 0; i &lt; 10; i++)&#123;                list.add();                System.out.println(&quot;添加了&quot;+(i + 1)+&quot;个元素&quot;);                Thread.sleep(1000);            &#125;            &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Thread2 extends Thread&#123;    private MyList list;    public Thread2 (MyList list)&#123;        super();        this.list = list;    &#125;    @Override    public void run()&#123;        try&#123;            while (true)&#123;                //Thread.sleep(2000);//B线程将因错过list.size==5而不会终止。                if (list.size()==5)&#123;                    System.out.println(&quot;==5了，b线程退出&quot;);                    throw new InterruptedException();                &#125;            &#125;            &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="wait"><a href="#wait" class="headerlink" title="wait( )"></a>wait( )</h2><ul><li><p>暂停当前线程并等待被唤醒</p></li><li><p><strong>wait(1000 )</strong> ,在1s后如无**notify( )**唤醒，则自动唤醒（持有锁后继续执行）</p><pre><code class="java">package cn.day.b6;public class Thread_A extends Thread &#123;    private Object lock;    public Thread_A(Object lock)&#123;        super();        this.lock = lock;    &#125;    @Override    public void run()&#123;        try &#123;            synchronized (lock)&#123;                System.out.println(&quot;我跳出来了&quot;);                lock.wait(1000);                System.out.println(&quot;打我啊笨蛋&quot;);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Thread_B extends Thread &#123;    private Object lock;    public Thread_B(Object lock)&#123;        super();        this.lock = lock;    &#125;    @Override    public void run()&#123;            synchronized (lock)&#123;               while (true)&#123;//B线程执行完毕后，A线程自动唤醒                   System.out.println(&quot;停不下来&quot;);                   try &#123;                       Thread.sleep(1000);                   &#125; catch (InterruptedException e) &#123;                       e.printStackTrace();                   &#125;               &#125;            &#125;        &#125;    &#125;class TestRun&#123;    public static void main(String[] args) &#123;            Object lock = new Object();            var t1 = new Thread_A(lock);            var t2 = new Thread_B(lock);            t1.start();            t2.start();        &#125;    &#125;</code></pre></li></ul><h2 id="notify"><a href="#notify" class="headerlink" title="notify( )"></a><strong>notify( )</strong></h2><ul><li>执行完当前同步代码块内代码后，选择同一个（唤醒多个需要多次调用）锁的等待线程**wait( )**将其唤醒（按照执行wait的顺序）</li></ul><h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll( )"></a>notifyAll( )</h2><ul><li>（倒序）唤醒全部等待线程<strong>wait( )</strong></li></ul><pre><code class="java">package cn.day.b6;public class Thread_A extends Thread &#123;    private Object lock;    public Thread_A(Object lock)&#123;        super();        this.lock = lock;    &#125;    @Override    public void run()&#123;        try &#123;            synchronized (lock)&#123;                System.out.println(&quot;Start wait time= &quot;+System.currentTimeMillis());                lock.wait();//暂停并等待被唤醒                System.out.println(&quot;End wait time= &quot;+System.currentTimeMillis());            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Thread_B extends Thread &#123;    private Object lock;    public Thread_B(Object lock)&#123;        super();        this.lock = lock;    &#125;    @Override    public void run()&#123;            synchronized (lock)&#123;                System.out.println(&quot;Start notify time= &quot;+System.currentTimeMillis());               // lock.notify();//选择同一个锁的等待线程将其唤醒（按照执行wait的顺序，依次唤醒）                lock.notifyAll()//同notify()，但按相反的顺序唤醒                System.out.println(&quot;End notify time= &quot;+System.currentTimeMillis());            &#125;        &#125;    &#125;class TestRun&#123;    public static void main(String[] args) &#123;        try &#123;            Object lock = new Object();//同一个对象同一个梦想，哈哈            var t1 = new Thread_A(lock);            t1.start();            Thread.sleep(3000);            var t2 = new Thread_B(lock);            t2.start();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h1 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h1><ul><li><p>共享变量+<strong>notifyAll( )</strong>+while+<strong>synchronized</strong>+volatile实现交叉执行</p><pre><code class="java">package cn.day.b6;public class MyThread &#123;    volatile private boolean prevIsA = false;//volatile，修改值时其它线程均可知晓    synchronized public void backupA()&#123;        try&#123;            while (prevIsA == true)&#123;//全场依据PrevIsA的值判断该线程是否该休息（释放锁）                wait();            &#125;            for (int i = 0;i &lt; 5;i++)&#123;                System.out.println(&quot;++++++&quot;);            &#125;            prevIsA = true;//此线程主要步骤执行完后再修改prevIsA值            notifyAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    synchronized public void backupB()&#123;        try&#123;            while (prevIsA == false) &#123;////全场依据PrevIsA的值判断该线程是否该休息（释放锁）                wait();            &#125;                for (int i = 0;i &lt; 5; i++)&#123;                    System.out.println(&quot;------&quot;);                &#125;                prevIsA = false;////全场依据PrevIsA的值判断该线程是否该休息（释放锁）                notifyAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Thread1 extends Thread&#123;    private MyThread dbTools;    public Thread1(MyThread dbTools)&#123;        super();        this.dbTools = dbTools;    &#125;    @Override    public void run()&#123;        dbTools.backupA();    &#125;&#125;class Thread2 extends Thread&#123;    private MyThread dbTools;    public Thread2(MyThread dbTools)&#123;        super();        this.dbTools = dbTools;    &#125;    @Override    public void run()&#123;        dbTools.backupB();    &#125;&#125;class MyRun&#123;    public static void main(String[] args) &#123;        var dbtools = new MyThread();        for (int i = 0; i &lt; 20; i++)&#123;//循环20波，100行            var output = new Thread2(dbtools);            output.start();            var input = new Thread1(dbtools);            input.start();        &#125;    &#125;&#125;</code></pre></li></ul><h2 id="join"><a href="#join" class="headerlink" title="join( )"></a>join( )</h2><ul><li>当前线程释放锁并进入无休止的等待状态，等其它线程结束再执行</li><li>join( 2000)，当前线程释放锁，2s后如获得锁，继续执行（无法获得锁，则一直尝试获得锁）</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul><li>将数据放于map中<ol><li>Map中的key存储ThreadLocal对象，value存储值</li><li>每个线程的value仅对此线程可见</li><li>当线程销毁时，map也随之销毁，如map的数据没有被引用则随时未GC回收</li></ol></li></ul><pre><code class="java">package cn.day.b7;public class Tools &#123;    public static ThreadLocal t1 = new ThreadLocal();&#125;class MyThreadA extends Thread&#123;    @Override    public void run()&#123;        try &#123;            for (int i = 0; i &lt; 10; i++)&#123;                Tools.t1.set(&quot;A&quot;+(i++));                System.out.println(&quot;A get &quot;+ Tools.t1.get());                int sleepValue = (int)(Math.random()*1000);                Thread.sleep(sleepValue);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class MyThreadB extends Thread&#123;    @Override    public void run()&#123;        try &#123;            for (int i = 0; i &lt; 10; i++)&#123;                Tools.t1.set(&quot;B&quot;+(i++));                System.out.println(&quot;B get &quot;+ Tools.t1.get());                int sleepValue = (int)(Math.random()*1000);                Thread.sleep(sleepValue);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Test&#123;    public static void main(String[] args) throws InterruptedException &#123;        var a = new MyThreadA();        var b = new MyThreadB();        a.start();        b.start();        for (int i = 0; i &lt; 10; i++)&#123;            Tools.t1.set(&quot;main&quot;+(i+1));            System.out.println(&quot;main get &quot;+ Tools.t1.get());            int sleepValue = (int)(Math.random()*1000);            try &#123;                Thread.sleep(sleepValue);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><ul><li>可通过重写initialValue( )方法，改变map中无值时get（）返回的数据（null）</li></ul><pre><code class="java">package cn.day.b7;public class ThreadLocalExt extends ThreadLocal &#123;    @Override    protected Object initialValue()&#123;        return &quot;改变&quot;;    &#125;&#125;class Run&#123;    public static  ThreadLocalExt t1= new ThreadLocalExt();    public static void main(String[] args) &#123;        System.out.println(t1.get());    &#125;&#125;</code></pre><h2 id="inheritableThreadLocal"><a href="#inheritableThreadLocal" class="headerlink" title="inheritableThreadLocal"></a>inheritableThreadLocal</h2><ul><li>从创建这个线程对象的线程继承map值(继承后并不随着map值的更新而更新)</li></ul><pre><code class="java">package cn.day.b7;public class TestInheritableThreadLocal extends Thread&#123;    public void run()&#123;        try &#123;            for (int i = 0; i&lt;10; i++)&#123;                System.out.println(&quot;在ThreadA线程中取值=&quot;+Tools1.t1.get());                Thread.sleep(100);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            for (int i = 0; i &lt;10; i++)&#123;                if (Tools1.t1.get() == null)&#123;                    Tools1.t1.set(&quot;此值是main&quot;);                &#125;                System.out.println(&quot;在main线程中取值=&quot; + Tools1.t1.get());                Thread.sleep(100);            &#125;            Thread.sleep(5000);            var a = new TestInheritableThreadLocal();            a.start();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Tools1&#123;    public static InheritableThreadLocal t1 = new InheritableThreadLocal();&#125;</code></pre><p>重写childValue( )方法可对继承的值进行“加工”。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lock对象</title>
      <link href="2022/03/20/thread-03/"/>
      <url>2022/03/20/thread-03/</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantLockTest"><a href="#ReentrantLockTest" class="headerlink" title="ReentrantLockTest"></a>ReentrantLockTest</h1><p>jdk5加入的，<strong>synchronized</strong>增强版</p><h2 id="lock-unlock-condition-await-condition-signal-等"><a href="#lock-unlock-condition-await-condition-signal-等" class="headerlink" title="lock( ) unlock( )  condition.await( ) **condition.signal( )**等"></a>lock( ) unlock( )  condition.await( ) **condition.signal( )**等</h2><ul><li><strong>lock( )**获取锁，</strong>unlock**释放锁（同步代码处在lock、unlock之间）</li><li><strong>condition.await( )**效果同</strong>wait( )**,调用此方法前，该线程必须获得锁</li><li><strong>condition.signal( )</strong>,唤醒线程，效果同<strong>notify（）</strong>。</li><li><strong>condition.signalAll( )**，唤醒所有线程（倒序）效果同</strong>notifyAll（）**</li></ul><pre><code class="java">package cn.day.b7;import cn.day.b6.MyThread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/*3个线程同步知晓，均不打印B*/public class MyService &#123;    private ReentrantLock lock = new ReentrantLock();//创建此对象用于获取锁、释放锁等操作    //new ReentrantLock(true);当设置为 true 时，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。//未定时的 tryLock 方法并没有使用公平设置。    private Condition condition = lock.newCondition();//用以使线程等待、唤醒等操作    public void waitMethod()&#123;        try &#123;            lock.lock();            System.out.println(&quot;A&quot;);            condition.await();//等待唤醒            System.out.println(&quot;B&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();            System.out.println(&quot;释放锁&quot;);        &#125;    &#125;&#125;class MyThreadA extends Thread&#123;    private MyService myService;    public MyThreadA(MyService myService)&#123;        super();        this.myService =  myService;    &#125;    @Override    public void run()&#123;        myService.waitMethod();    &#125;&#125;class TestMyService &#123;    public static void main(String[] args) &#123;        MyService myService = new MyService();        MyThreadA a1 = new MyThreadA(myService);        a1.start();        MyThreadA a2 = new MyThreadA(myService);        a2.start();        MyThreadA a3 = new MyThreadA(myService);        a3.start();    &#125;&#125;</code></pre><h2 id="唤醒部分线程"><a href="#唤醒部分线程" class="headerlink" title="唤醒部分线程"></a>唤醒部分线程</h2><pre><code class="java">package cn.day.b7;import cn.day.b6.MyThread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class MyService &#123;    private ReentrantLock lock = new ReentrantLock();    /*创建两个Condition对象，分别用来唤醒A、B线程*/    private Condition conditionA = lock.newCondition();    private Condition conditionB = lock.newCondition();        public void awaitA()&#123;        try &#123;            lock.lock();            System.out.println(&quot;A&quot;);            conditionA.await();//等待唤醒            System.out.println(&quot;A被唤醒&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();            System.out.println(&quot;释放锁&quot;);        &#125;    &#125;    public void awaitB()&#123;        try &#123;            lock.lock();            System.out.println(&quot;B&quot;);            conditionB.await();//等待唤醒            System.out.println(&quot;B被唤醒&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();            System.out.println(&quot;释放锁&quot;);        &#125;    &#125;            public void signalAll_B()&#123;        lock.lock();        System.out.println(&quot;唤醒B线程&quot;);        conditionB.signalAll();//仅唤醒全部B种线程（相同锁）        lock.unlock();    &#125;    public void signalAll_A()&#123;        lock.lock();        System.out.println(&quot;唤醒A线程&quot;);////仅唤醒全部A种线程（相同锁）        conditionA.signalAll();        lock.unlock();    &#125;&#125;class MyThreadA extends Thread&#123;    private MyService myService;    public MyThreadA(MyService myService)&#123;        super();        this.myService =  myService;    &#125;    @Override    public void run()&#123;        myService.awaitA();    &#125;&#125;class MyThreadB extends Thread&#123;    private MyService myService;    public MyThreadB(MyService myService)&#123;        super();        this.myService =  myService;    &#125;    @Override    public void run()&#123;        myService.awaitB();    &#125;&#125;class TestMyService &#123;    public static void main(String[] args) throws InterruptedException &#123;        MyService myService = new MyService();        MyThreadA a1 = new MyThreadA(myService);        MyThreadA a2 = new MyThreadA(myService);        MyThreadB b1 = new MyThreadB(myService);        a1.setName(&quot;A1&quot;);        a2.setName(&quot;A2&quot;);        b1.setName(&quot;B&quot;);        a1.start();        a2.start();        b1.start();        System.out.println(&quot;等待3s&quot;);        Thread.sleep(3000);        myService.signalAll_A();//仅唤醒A种线程    &#125;&#125;</code></pre><h1 id="生产者、消费者"><a href="#生产者、消费者" class="headerlink" title="生产者、消费者"></a>生产者、消费者</h1><p>1V1(生产、消费一对一)、多对多5V5</p><pre><code class="java">package cn.day.b7.ConditionTest;import cn.day.b6.MyThread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class MyService &#123;    private ReentrantLock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    private boolean hasValue = false;    public void set()&#123;        try &#123;            lock.lock();            if (hasValue == true) &#123;                condition.await();            &#125;            System.out.println(&quot;生产者&quot;);            hasValue = true;            condition.signalAll();        &#125;catch (InterruptedException e)&#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    public void get()&#123;        try &#123;            lock.lock();            if (hasValue == false) &#123;                condition.await();            &#125;            System.out.println(&quot;消费者&quot;);            hasValue = false;            condition.signalAll();        &#125;catch (InterruptedException e)&#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();        &#125;    &#125;&#125;class MyThreadA extends Thread&#123;    private MyService myService;    public MyThreadA(MyService myService)&#123;        super();        this.myService = myService;    &#125;    @Override    public void run()&#123;        for (int i =0; i &lt; Integer.MAX_VALUE;i++)&#123;            myService.set();        &#125;    &#125;&#125;class MyThreadB extends Thread&#123;    private MyService myService;    public MyThreadB(MyService myService)&#123;        super();        this.myService = myService;    &#125;    @Override    public void run()&#123;        for (int i =0; i &lt; Integer.MAX_VALUE;i++)&#123;//Integer.MAX_VALUE常量的最大值            myService.get();        &#125;    &#125;&#125;class Run&#123;    public static void main(String[] args) &#123;        MyService myService = new MyService();        MyThreadA a = new MyThreadA(myService);        a.start();        MyThreadB b = new MyThreadB(myService);        b.start();    &#125;&#125;/*多对多*/class Run1&#123;    public static void main(String[] args) &#123;        MyService Service = new MyService();        MyThreadA[] threadA = new MyThreadA[5];        MyThreadB[] threadB = new MyThreadB[5];        for (int i = 0; i &lt; 5; i++)&#123;            threadA[i] = new MyThreadA(Service);            threadB[i] = new MyThreadB(Service);            threadA[i].start();            threadB[i].start();        &#125;    &#125;&#125;</code></pre><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><ul><li><p>共享锁（只读）</p><p>共享锁使只读的线程可异步执行；与写操作的线程同步执行</p></li></ul><pre><code class="java">public class MyService &#123;    private ReentrantLock lock = new ReentrantReadWriteLock();//共享、排他锁    private String name = &quot;张三&quot;    public void get()&#123;        try &#123;            lock.readlock();//共享锁（异步，只读）            System.out.println(name);            Thread.sleep(4000);            lock.readLock().unlock();//释放共享锁                  &#125;catch (InterruptedException e)&#123;            e.printStackTrace();        &#125;    &#125;</code></pre><ul><li><p>排他锁（写）</p><p>与其它锁同步执行</p></li></ul><pre><code class="java">public class MyService &#123;    private ReentrantLock lock = new ReentrantReadWriteLock();//共享、排他锁    private String name = &quot;张三&quot;    public void set(String name)&#123;        try &#123;            lock.writelock();//排他锁（同步，只写）            System.out.println(name);            this.name = name;            Thread.sleep(4000);            lock.writeLock().unlock();//释放排他锁                  &#125;catch (InterruptedException e)&#123;            e.printStackTrace();        &#125;    &#125;</code></pre><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="一个定时任务实例"><a href="#一个定时任务实例" class="headerlink" title="一个定时任务实例"></a>一个定时任务实例</h2><pre><code class="java">package cn.day.b8;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class MyTask extends TimerTask &#123;//注意其父类哦    @Override    public void run() &#123;        System.out.println(&quot;start Time：&quot; + System.currentTimeMillis());    &#125;&#125;class Test&#123;    public static void main(String[] args) throws InterruptedException &#123;        long nowTime = System.currentTimeMillis();        System.out.println(&quot;当前时间为： &quot;+ nowTime );        long scheduleTime = (nowTime +10000);        System.out.println(&quot;计划时间为： &quot;+ scheduleTime);        MyTask task = new MyTask();        Timer timer = new Timer();//创建一个新计时器        Thread.sleep(1000);        timer.schedule(task,new Date(scheduleTime));        //在指定的时间执行任务，如指定时间早于当前时间则立即执行任务        Thread.sleep(Integer.MAX_VALUE);    &#125;&#125;</code></pre><ul><li><p>创建一个Timer对象时，内部就创建了一个新线程（TimerTread）</p></li><li><p>TimerTread线程管理一个队列，队列按顺序执行Task任务</p></li><li><p>定时任务可由于当前任务的复杂度而导致下个任务延期执行</p></li></ul><h2 id="执行多个定时任务实例"><a href="#执行多个定时任务实例" class="headerlink" title="执行多个定时任务实例"></a>执行多个定时任务实例</h2><ul><li>任务执行算法每次将最后一个任务放入队头（第一次仍保持原序列）</li></ul><pre><code class="java">/*省略代码同上*/class DoubleTest&#123;    public static void main(String[] args) throws InterruptedException &#123;        long nowTime = System.currentTimeMillis();        System.out.println(&quot;当前时间为： &quot;+ nowTime );        long scheduleTime1 = (nowTime +5000);        long scheduleTime2 = (nowTime +6000);        System.out.println(&quot;A计划时间为： &quot;+ scheduleTime1);        System.out.println(&quot;B计划时间为： &quot;+ scheduleTime2);        MyTask task1 = new MyTask();        MyTask task2 = new MyTask();        Timer timer = new Timer();//只用一个新计时器        timer.schedule(task1,new Date(scheduleTime1));        timer.schedule(task2,new Date(scheduleTime2));    &#125;&#125;</code></pre><h2 id="定时间隔执行任务"><a href="#定时间隔执行任务" class="headerlink" title="定时间隔执行任务"></a>定时间隔执行任务</h2><ul><li>任务间隔也会因当前任务的复杂度而延期执行，也会因为任务中的Thread.sleep( 50000)而改变任务执行的间隔时间</li></ul><pre><code class="java">class Test&#123;    public static void main(String[] args) throws InterruptedException &#123;        long nowTime = System.currentTimeMillis();        System.out.println(&quot;当前时间为： &quot;+ nowTime );        long scheduleTime = (nowTime +10000);        System.out.println(&quot;计划时间为： &quot;+ scheduleTime);        MyTask task = new MyTask();        Timer timer = new Timer();        timer.schedule(task,new Date(scheduleTime),4000);        //在指定时间执行任务（计划时间早于当前时间则立刻执行），且每间隔4s再次执行任务        //timer.schedule(task,4000)则是延迟4s执行        //timer.schedule(task,4000，2000)则是延迟4s执行并间隔2s无限执行此任务            &#125;&#125;</code></pre><h2 id="移除TimerTread线程队列任务"><a href="#移除TimerTread线程队列任务" class="headerlink" title="移除TimerTread线程队列任务"></a>移除TimerTread线程队列任务</h2><ul><li><p>定时任务执行完毕后，进程也不会被销毁</p></li><li><p>TimerTask.cancel 移除当前任务</p></li><li><p>Timer.cancel 移除全部任务</p></li></ul><pre><code class="java">package cn.day.b8;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class MyTask1 extends TimerTask &#123;    @Override    public void run() &#123;        System.out.println(&quot;A run Timer &quot;+ System.currentTimeMillis());        this.cancel();//将此任务移除TimerTread线程队列（不会中断本次任务）        System.out.println(&quot;A任务移除&quot;);    &#125;&#125;class MyTask2 extends TimerTask &#123;    @Override    public void run() &#123;        System.out.println(&quot;B run Timer &quot;+ System.currentTimeMillis());    &#125;&#125;class Test&#123;    public static void main(String[] args) throws InterruptedException &#123;        long nowTime = System.currentTimeMillis();        System.out.println(&quot;当前时间为： &quot;+ nowTime );        MyTask1 task1 = new MyTask1();        MyTask2 task2 = new MyTask2();        Timer timer = new Timer();        timer.schedule(task1,new Date(nowTime),2000);        timer.schedule(task2,new Date(nowTime),2000);        Thread.sleep(5000);        /*如 timer.cancel();前有死循环，则无法执行到 timer.cancel();这行；         timer.cancel()将无法获得队列锁，更无法移除队列中任务        while(true)&#123;            int i ++;        &#125;*/        timer.cancel();//移除TimerTread线程队列中所有任务    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程加载与线程组</title>
      <link href="2022/03/20/thread-04/"/>
      <url>2022/03/20/thread-04/</url>
      
        <content type="html"><![CDATA[<h1 id="饿汉模式-立即加载"><a href="#饿汉模式-立即加载" class="headerlink" title="饿汉模式(立即加载)"></a>饿汉模式(立即加载)</h1><ul><li>使用类时已创建对象</li></ul><pre><code class="java">package cn.day.b8;public class MyObject &#123;    private static MyObject myObject = new MyObject();//使用类时已创建对象    public static MyObject getInstance()&#123;        return myObject;    &#125;&#125;class Thread1 extends Thread &#123;    @Override    public void run()&#123;        System.out.println(MyObject.getInstance().hashCode());    &#125;&#125;class Run&#123;    public static void main(String[] args) &#123;        var t1 = new Thread1();        var t2 = new Thread1();        var t3 = new Thread1();        t1.start();        t2.start();        t3.start();    &#125;&#125;</code></pre><h1 id="懒汉模式（延迟加载）"><a href="#懒汉模式（延迟加载）" class="headerlink" title="懒汉模式（延迟加载）"></a>懒汉模式（延迟加载）</h1><ul><li>在属性方法（get方法）中实例化对象</li><li>双检查锁实现懒汉单例模式</li></ul><pre><code class="java">package cn.day.b8;public class MyObject &#123;    private  volatile static MyObject myObject ;// volatile增加了可见性，阻止了创建MyObject时的代码重排    public static MyObject getInstance()&#123;        try &#123;            if (myObject != null)&#123;            &#125;else &#123;                Thread.sleep(3000);                synchronized (MyObject.class)&#123;                    if (myObject == null)&#123;                        myObject = new MyObject();                    &#125;                &#125;            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return myObject;    &#125;&#125;class Thread1 extends Thread &#123;    @Override    public void run()&#123;        System.out.println(MyObject.getInstance().hashCode());    &#125;&#125;class Run&#123;    public static void main(String[] args) &#123;        var t1 = new Thread1();        var t2 = new Thread1();        var t3 = new Thread1();        t1.start();        t2.start();        t3.start();    &#125;&#125;</code></pre><ul><li>静态内部类实现懒汉模式</li></ul><pre><code class="java">package cn.day.b8;public class MyObject &#123;    /*静态代码块实现懒汉模式        private static MyObject myObject = null;        static&#123;            myObject = new MyObject();        &#125;    */    private static class MyObjectHandler &#123;        private volatile static MyObject myObject = new MyObject();    &#125;    public static MyObject getInstance() &#123;        return MyObjectHandler.myObject;    &#125;&#125;class Thread1 extends Thread &#123;    @Override    public void run()&#123;        System.out.println(MyObject.getInstance().hashCode());    &#125;&#125;class Run&#123;    public static void main(String[] args) &#123;        var t1 = new Thread1();        var t2 = new Thread1();        var t3 = new Thread1();        t1.start();        t2.start();        t3.start();    &#125;&#125;</code></pre><h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><ul><li>一级关联：组中有线程而无线程下的线程</li></ul><pre><code class="java">package cn.day.b8;public class MyThread &#123;    public static void main(String[] args) &#123;        ThreadA aRunnable = new ThreadA();        ThreadB bRunnable = new ThreadB();        ThreadGroup group = new ThreadGroup(&quot;一级关联组&quot;);//构造一个新线程组。        Thread aThread = new Thread(group,aRunnable);//加入线程组        Thread bThread = new Thread(group,bRunnable);        aThread.start();        bThread.start();        System.out.println(&quot;线组中线程程数 &quot;+ group.activeCount());//返回该线程组及其子组的数量的估计值        System.out.println(&quot;线程组名 &quot;+ group.getName());//返回该线程组的名称        Thread.sleep(3000);        group.interrupt();//停止此线程组中所有线程        Thread.enumerate(group);//将当前线程的线程组整体复制到指定线程组    &#125;&#125;class ThreadA extends Thread&#123;    @Override    public void run()&#123;        try &#123;            while (!Thread.currentThread().isInterrupted())&#123;                System.out.println(&quot;ThreadName &quot;+ Thread.currentThread().getName());                Thread.sleep(3000);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class ThreadB extends Thread&#123;    @Override    public void run()&#123;        try &#123;            while (!Thread.currentThread().isInterrupted())&#123;                System.out.println(&quot;ThreadName &quot;+ Thread.currentThread().getName());                Thread.sleep(3000);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread与Runable</title>
      <link href="2022/03/20/thread-05/"/>
      <url>2022/03/20/thread-05/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">import java.io.*;import java.lang.Thread;/** * 多个线程加载同一个Runnable可实现共享数据*/class MyThread extends Thread&#123;    public int x = 0;    public void run()&#123;        System.out.println(++x);    &#125;&#125;class RThread implements Runnable&#123;    private int x = 0;    public void run()&#123;        System.out.println(++x);    &#125;&#125;public class Java_3 &#123;    public static void main(String[] args) throws Exception&#123;        for(int i=0;i&lt;5;i++)&#123;            Thread t = new MyThread();            t.start();        &#125;        Thread.sleep(1000);        System.out.println();        RThread r = new RThread();        for(int i=0;i&lt;5;i++)&#123;            Thread t = new Thread(r);//多个线程同时加载一个Runnable            t.start();        &#125;    &#125;&#125;/**运行结果：1111112345*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/%E2%94%82%E2%8C%A1%E2%95%A9%E2%95%A2Spring/"/>
      <url>2022/03/20/%E2%94%82%E2%8C%A1%E2%95%A9%E2%95%A2Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h1><h2 id="IOC反转"><a href="#IOC反转" class="headerlink" title="IOC反转"></a>IOC反转</h2><p>由容器管理对象，将对象之间的依赖解耦</p><h3 id="基于XML的注入"><a href="#基于XML的注入" class="headerlink" title="基于XML的注入"></a>基于XML的注入</h3><p>####Set注入</p><p>spring调用类的set方法进行属性操作</p><p>两个实例类：</p><ul><li>User.java</li></ul><pre><code class="java">public class User &#123;    private String name;    private int age;    private Company company;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Company getCompany() &#123;        return company;    &#125;    public void setCompany(Company company) &#123;        this.company = company;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, company=&quot; + company +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><ul><li>Company.java</li></ul><pre><code class="java">public class Company &#123;    private String name;    private String address;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;Company&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><ul><li>applicationContext.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;myUser&quot; class=&quot;cn.itthree.spring.bean2.User&quot;&gt;        &lt;!--    set注入，即调用set方法对属性进行设置--&gt;        &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;            &lt;!--当指定 bean 的某属性值为另一 bean 的实例时，通过 ref 指定它们间的引用关系。ref的值必须为某 bean 的 id 值。--&gt;        &lt;property name=&quot;company&quot; ref=&quot;myCompany&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    在加载配置文件applicationContext.xml时spring会此xml将所有bean标签中的类均加载一遍，所以不用在意bean标签的书写顺序--&gt;    &lt;bean id=&quot;myCompany&quot; class=&quot;cn.itthree.spring.bean2.Company&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Alibaba&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>####构造器注入</p><p>spring调用有参构造器构造实例并为属性赋值</p><ul><li>User</li></ul><pre><code class="java">//为User类添加一个有参构造器    public User(String name, int age, Company company) &#123;        this.name = name;        this.age = age;        this.company = company;    &#125;</code></pre><ul><li>applicationContext.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;myUser&quot; class=&quot;cn.itthree.spring.bean3.User&quot;&gt;        &lt;!--构造器注入spring调用有参构造器为属性赋值--&gt;&lt;!--        name属性构造(可以乱序即不用在意属性的位置)--&gt;        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;company&quot; ref=&quot;myCompany&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;&lt;!--        index索引构造(0-1-2分别对应着该类构造器的参数位置)--&gt;        &lt;constructor-arg index=&quot;0&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg index=&quot;2&quot; ref=&quot;myCompany&quot;&gt;&lt;/constructor-arg&gt;&lt;!--  省略index（不能乱序，必须按构造器的参数顺序进行传值）      --&gt;        &lt;constructor-arg value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg value=&quot;21&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg ref=&quot;myCompany&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;!--    在加载配置文件applicationContext.xml时spring会此xml将所有bean标签中的类均加载一遍，    所以不用在意bean标签的书写顺序--&gt;    &lt;bean id=&quot;myCompany&quot; class=&quot;cn.itthree.spring.bean3.Company&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Alibaba&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="模块化管理xml"><a href="#模块化管理xml" class="headerlink" title="模块化管理xml"></a>模块化管理xml</h4><p>将原applicationContext.xml按功能及其所需，划分为若个xml每个xml指代一个功能或模块</p><ul><li>spring-company.xml（公司模块）</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;company&quot; class=&quot;cn.itthree.spring.bean5.Company&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Alibaba&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li>spring-user.xml(用户模块)</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--   引用类型自动注入      1.byName(按名称注入) ： 根据类的引用类型的属性名在bean中寻找有相同的bean id且类型相同的bean实现自动注入--&gt;    &lt;bean id=&quot;myUser&quot; class=&quot;cn.itthree.spring.bean5.User&quot; autowire=&quot;byName&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li>total.xml(指定所有功能模块的spring.xml的位置)</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    在spring的配置文件中要指定其他文件的位置， 需要使用classpath，告诉spring到哪去加载读取文件。--&gt;&lt;!-- 使用通配符加载bean6下所有文件名为spring-开头的xml--&gt;&lt;import resource=&quot;classpath:bean5/spring-*.xml&quot;/&gt;&lt;/beans&gt;</code></pre><ul><li>一个测试类</li></ul><pre><code class="java">package itthree.spring.bean5;import cn.itthree.spring.bean5.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AppTest &#123;    @Test    public void TestMyUser()&#123;        //1.加载配置文件(注意applicationContext.xml的路径)        String config = &quot;bean5/total.xml&quot;;        //spring会在加载配置文件时生成对象        ApplicationContext ac = new ClassPathXmlApplicationContext(config);        User user = (User) ac.getBean(&quot;myUser&quot;);        System.out.println(&quot; &quot;+user);    &#125;&#125;</code></pre><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><p>首先需要在spring配置文件中配置扫描器，写明注解所在包的基本信息</p><ul><li>applicationContext.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--    base-package：指定注解在项目中的包名。        spring会扫描遍历base-package指定的包，将包中和子包中的所有类中的注解，按照注解的功能创建对象，或给属性赋值。--&gt;&lt;context:component-scan base-package=&quot;cn.itthree.spring.ba01&quot;/&gt;&lt;/beans&gt;</code></pre><p><strong>注解分类</strong>：</p><ul><li>对象注解</li></ul><p>@Component: 等同于spring配置文件中的<bean></p><p><code>@Component(value = &quot;myStudent&quot;)</code>等同于</p><p><code>&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.ba01.Student&quot; /&gt; </code></p><ul><li>分层注解</li></ul><p>@Repository，@Service，@Controller是给项目的对象分层的,使用语法和@Component相同。</p><p>1.@Repository（用在持久层类的上面） : 放在dao的实现类上面，表示创建dao对象，dao对象是能访问数据库的。</p><p>2.@Service(用在业务层类的上面)：放在service的实现类上面，创建service对象，service对象是做业务处理，可以有事务等功能的。</p><p>3.@Controller(用在控制器的上面)：放在控制器（处理器）类的上面，创建控制器对象的，控制器对象，能够接受用户提交的参数，显示请求的处理结果。</p><ul><li>属性注解</li></ul><p>以下注解均可以在不包含set方法的类中使用，如果写在set方法上，那么就调用set方法进行属性设置</p><p> <strong>简单类型的属性赋值注解</strong>：</p><p> @Value:，在属性定义的上面，无需set方法。</p><p><strong>引用类型注解</strong>：</p><ol><li><p>@Autowired: 实现引用类型的赋值，持byName, byType，默认使用的是byType自动注入，此注解由spring框架提供。</p><p>如果要使用byName方式，需要在属性上面加入@Autowired再将@Qualifier(value=”bean的id”) 写到属性上面：表示使用指定名称的bean完成赋值。</p></li></ol><p>2.@Resource: 来自jdk中的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值，使用的也是自动注入原理，支持byName， byType .默认是byName（当byName失败时使用byType）</p><ul><li>User.java</li></ul><pre><code class="java">package cn.itthree.spring.ba01;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import javax.annotation.Resource;//实例化一个名为myUser的对象@Component(&quot;myUser&quot;)public class User &#123;    @Value(&quot;王魏振&quot;)    private String name;    @Value(&quot;32&quot;)    private Integer age;    //byName自动注入    //@Autowired(required = false)时如找不到指定bean id则不报错，默认为@Autowired(required = true)    @Autowired    @Qualifier(&quot;company&quot;)    private Company company;    //默认是byName： 先使用byName自动注入，如果byName赋值失败，再使用byType    @Resource    private Car car;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, company=&quot; + company +                &quot;, car=&quot; + car +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><ul><li>Company.java</li></ul><pre><code class="java">package cn.itthree.spring.ba01;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;//不指定对象名称，由spring提供默认名称: 类名的首字母小写,即此类对象名称为company@Componentpublic class Company &#123;    public Company() &#123;    &#125;    @Value(&quot;Alibaba&quot;)    private String name;    @Value(&quot;北京&quot;)    private String address;    @Override    public String toString() &#123;        return &quot;Company&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>测试类</p><pre><code class="java">package org.example;import static org.junit.Assert.assertTrue;import cn.itthree.spring.ba01.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Unit test for simple App. */public class AppTest &#123;    /**     * Rigorous Test :-)     */    @Test    public void testDiA()&#123;        String config = &quot;applicationContext.xml&quot;;        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);        User user = (User) ctx.getBean(&quot;myUser&quot;);        System.out.println(&quot; &quot;+ user);    &#125;&#125;</code></pre><p>Car.java</p><pre><code class="java">package cn.itthree.spring.ba01;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Car &#123;    private String name;    @Value(&quot;五菱宏光&quot;)    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Car&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><h3 id="AspectJ-面向切面编程的实现"><a href="#AspectJ-面向切面编程的实现" class="headerlink" title="AspectJ 面向切面编程的实现"></a>AspectJ 面向切面编程的实现</h3><p>AspectJ 中常用的通知有五种类型： （1）<strong>前置通知</strong> （2）<strong>后置通知 **（3）</strong>环绕通知 **（4）异常通知 （5）最终通知</p><p>AspectJ切入点表达式：</p><p>表达式的原型是：<code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</code></p><p>其中：modifiers-pattern] 访问权限类型；</p><p> ret-type-pattern 返回值类型 ；</p><p>declaring-type-pattern 包名类名；</p><p> name-pattern(param-pattern) 方法名(参数类型和参数个数)；</p><p> throws-pattern 抛出异常类型 ；</p><p>带？的表示可选部分</p><p>表达式中可使用以下字符：</p><p><img src="C:\Users\17630\AppData\Roaming\Typora\typora-user-images\image-20201219212752592.png" alt="image-20201219212752592"></p><p>目标类</p><pre><code class="java">package cn.itthree.aop.ba01;public class SomeServiceImpl implements SomeService&#123;    @Override    public void doSome(String name, Integer age) &#123;        System.out.println(&quot;目标方法doSome&quot;+name+age);    &#125;    @Override    public String doOther(String name, int age) &#123;        System.out.println(&quot;doOther已执行&quot;);        return &quot;123&quot;;    &#125;    @Override    public String doFirst(String name, Integer age) &#123;        System.out.println(&quot;====业务方法doFirst()====&quot;);        return &quot;doFirst&quot;;    &#125;&#125;</code></pre><p>目标类实现接口</p><pre><code class="java">package cn.itthree.aop.ba01;public interface SomeService &#123;    void doSome(String name,Integer age);    String doOther(String name, int age);    String doFirst(String name,Integer age);&#125;</code></pre><p><strong>JoinPoint</strong>类型参数可获取切入点表达式、方法签名、目标对象等，所有通知方法均可使用，<strong>JoinPoint</strong>类型参数必须写在方法内第一个参数的位置。</p><h3 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h3><p>@Before</p><p>在目标方法之前执行</p><h3 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h3><p> @AfterReturning</p><p>在目标方法执行之后执行，可以获取到目标方法的返回 值。</p><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><ol><li>在目标方法的前后进行功能增强。</li><li>控制目标方法是否被调用执行</li><li>修改原来的目标方法的执行结果。 影响最后的调用结果     </li></ol><pre><code class="java">package cn.itthree.aop.ba01;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.beans.factory.annotation.Qualifier;import java.util.Date;@Aspectpublic class MyAspect &#123;//    @Before(value = &quot;execution(void *..SomeServiceImpl.doSome(String,Integer))&quot;)//    public void myBefore()&#123;//        System.out.println(&quot;Start&quot;+new Date());//    &#125;        //@Before: 前置通知注解,value 是切入点表达式，指定切面的功能执行的位置    @Before(value = &quot;execution(* do*(..))&quot;)    public void myBefore(JoinPoint jp)&#123;    //JoinPoint参数，可获取切入点表达式、方法签名、目标对象等。    //所有通知方法均可使用JoinPoint 类型参数，        System.out.println(&quot;Start Time \n&quot;+new Date());        for (Object arg:jp.getArgs()) &#123;            System.out.println(&quot;前置参数= &quot;+arg);        &#125;        System.out.println();    &#125;                //后置通知    @AfterReturning(value = &quot;execution(* doSome(..))&quot;)    public void myAfter()&#123;        System.out.println(&quot;End Time \n&quot;+new Date());    &#125;    // 注解的 returning 属性就是用于指定接收方法返回值的变量名的    @AfterReturning(value = &quot;execution(* doOther(..))&quot;,returning = &quot;result&quot;)    public Object myAfterR(Object result)&#123;        Object return1 =  &quot;&quot;;        if (result != null)&#123;            String s = (String)result;            result = s.indexOf(1);            return1 =  result;        &#125;        System.out.println(&quot;后置通知时改变返回值为： &quot;+result);        return return1;    &#125;    //环绕通知必须有一个返回值，一般使用Object//环绕通知的参数类型固定为 ProceedingJoinPoint，用于接收（调用.proceed方法后）执行目标类方法的返回值 @Around(value = &quot;myPt()&quot;)    public Object myAround(ProceedingJoinPoint pjp) throws Throwable &#123;        String name = &quot;&quot;;        //目标方法前从参数中取值        Object args[] =pjp.getArgs();        if (args!=null &amp;&amp; args.length &gt;1)&#123;            Object arg = args[0];            name = (String)arg;        &#125;        Object result = null;        System.out.println(&quot;已获取目标方法参数，在目标方法前\n&quot;+new Date());        //调用目标方法        if (&quot;李四&quot;.equals(name))&#123;            //proceed方法执行返回的值就是result的值            result = pjp.proceed();        &#125;        System.out.println(&quot;在目标方法后，添加功能\n&quot;+new Date());        if (result!=null)&#123;            result = &quot;editTime: &quot;+new Date();        &#125;        return result;    &#125;    //指定SomeServiceImpl.doFirst方法的别名为myPt,可在其他切面方法的切面表达式中使用别名代替原目标方法名    @Pointcut(value = &quot;execution(* *..SomeServiceImpl.doFirst(..))&quot;)    private void myPt()&#123;    &#125;&#125;</code></pre><p>测试类</p><pre><code class="java">package org.example;import static org.junit.Assert.assertTrue;import cn.itthree.aop.ba01.SomeService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Unit test for simple App. */public class AppTest &#123;    @Test    public void shouldAnswerWithTrue()    &#123;        String config=&quot;applicationContext.xml&quot;;        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);        //从容器中获取目标对象,此处用到了JDK动态代理        SomeService proxy = (SomeService) ctx.getBean(&quot;someService&quot;);        System.out.println(&quot;proxy&quot;+proxy.getClass().getName());//        proxy.doSome(&quot;李四&quot;,3);//        String return1 = proxy.doOther(&quot;李四&quot;,3);        String return2 = proxy.doFirst(&quot;李四&quot;,9);        System.out.println(return2);        //此时值仍为123    &#125;&#125;</code></pre><p>applicationContext.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!--    目标类--&gt;    &lt;bean id=&quot;someService&quot; class=&quot;cn.itthree.aop.ba01.SomeServiceImpl&quot;/&gt;&lt;!--    切面类--&gt;    &lt;bean id=&quot;myAspect&quot; class=&quot;cn.itthree.aop.ba01.MyAspect&quot;/&gt;    &lt;!--    使用cglib动态代理--&gt;    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;&lt;/beans&gt;</code></pre><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/util&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/util       https://www.springframework.org/schema/util/spring-util.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!--1、声明数据源DataSource, 作用是连接数据库的--&gt;    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;          init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;&lt;!--setUrl()--&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;    &lt;/bean&gt;    &lt;!--2、声明的是mybatis中提供的SqlSessionFactoryBean类--&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;        &lt;!--mybatis主配置文件的位置           configLocation属性是Resource类型，读取配置文件           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置        --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt;    &lt;/bean&gt;    &lt;!--3、创建dao对象，使用SqlSession的getMapper（StudentDao.class）        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。    --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!--指定SqlSessionFactory对象的id--&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;        &lt;!--指定包名， 包名是dao接口所在的包名。            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行            一次getMapper()方法，得到每个接口的dao对象。            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写        --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;cn.itthree.spring.dao&quot;/&gt;    &lt;/bean&gt;    &lt;!--声明service--&gt;    &lt;bean id=&quot;buyService&quot; class=&quot;cn.itthree.spring.service.Impl.BuyGoodsServiceImpl&quot;&gt;        &lt;property name=&quot;goodsDao&quot; ref=&quot;goodsDao&quot; /&gt;        &lt;property name=&quot;saleDao&quot; ref=&quot;saleDao&quot; /&gt;    &lt;/bean&gt;    &lt;!--使用spring的事务处理--&gt;    &lt;!--1. 声明事务管理器--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!--连接的数据库， 指定数据源--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;    &lt;/bean&gt;    &lt;!--2. 开启事务注解驱动，告诉spring使用注解管理事务，创建代理对象           transaction-manager:事务管理器对象的id    --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;&lt;/beans&gt;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--设置别名--&gt;    &lt;typeAliases&gt;        &lt;!--name:实体类所在的包名        --&gt;        &lt;package name=&quot;cn.itthree.spring.domain&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!-- sql mapper(sql映射文件)的位置--&gt;    &lt;mappers&gt;        &lt;!--       name：是包名， 这个包中的所有mapper.xml一次都能加载        --&gt;        &lt;package name=&quot;cn.itthree.spring.dao&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/%E2%94%A4%C2%AB%E2%95%9E%C3%91%E2%94%BC%CE%A3/"/>
      <url>2022/03/20/%E2%94%A4%C2%AB%E2%95%9E%C3%91%E2%94%BC%CE%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="串匹配"><a href="#串匹配" class="headerlink" title="串匹配"></a>串匹配</h1><h2 id="串的链式存储与朴素-简单-匹配"><a href="#串的链式存储与朴素-简单-匹配" class="headerlink" title="串的链式存储与朴素(简单)匹配"></a>串的链式存储与朴素(简单)匹配</h2><pre><code class="c">/* * @Author: itThree * @Date: 2021-09-17 16:46:14 * @LastEditTime: 2021-09-19 15:59:37 * @Description:  * @FilePath: \cpp\datas\myString.cpp * 光阴之逆旅，百代之过客，而已 */#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;//定长的串#define MAXSIZE 255typedef struct &#123;   char ch[MAXSIZE];   int length;&#125;limString;//动态分配的串typedef struct&#123;    char* ch;    int lenght;&#125;dyString;//简单匹配int simple(limString* n, limString* m);//创建一个串void createString(limString* &amp;S,int type)&#123;    S = (limString*)malloc(sizeof(limString));    char inputC[255];    scanf(&quot;%s&quot;,inputC);    //记录输入串的长度    int i = 0;    while (inputC[i]!=0)    &#123;        S-&gt;ch[i] = inputC[i];        i++;    &#125;    S-&gt;length = i;&#125;//此实现，当T中包含多个P时，仅返回最后一个int simple(limString* T, limString* P)&#123;        int n = T-&gt;length;    int m = P-&gt;length;    //p记录结果的索引    int p = 0;    //s为偏移量    for (int s=0; s&lt;n-m+1; s++)    &#123;        for (int i = 0; i &lt; m; i++)        &#123;            if(P-&gt;ch[i] == T-&gt;ch[s+i])&#123;                //当文本T与模式P相同则记录索引               p = s+i;            &#125;else&#123;                break;            &#125;        &#125;    &#125;    //如果最终记录的索引p,同P中最后一个元素相同，我们认为匹配到了    if (T-&gt;ch[p] == P-&gt;ch[m-1])    &#123;//返回P对应于T的首索引       return p-m+1;    &#125;        return 0;&#125;int main()&#123;    limString* T,*P;    createString(T,1);    createString(P,1);    // printf(&quot;%s\t%d&quot;,S,S-&gt;length);    int p = simple(T,P);    printf(&quot;%d&quot;,p);    return 0;  &#125;</code></pre><h2 id="RKM匹配"><a href="#RKM匹配" class="headerlink" title="RKM匹配"></a>RKM匹配</h2><p>使用函数：</p><pre><code class="c">//判断P是否为T的子串int ifTP(TYPE* T, TYPE* P, int m, int s, int pHash);int simpleComparsion(TYPE* T, TYPE* P, int m);//主程序，计算偏移地址，控制程序整体迭代int intRKM(TYPE* T, TYPE* P, int m, int n, int q);//返回串的Hashint countHash(TYPE* P, int m);</code></pre><p>主体实现：</p><pre><code class="c">/* * @Author: itThree * @Date: 2021-09-28 17:38:05 * @LastEditTime: 2021-09-29 23:08:34 * @Description: 实现基于RKM的字符串匹配。 * 注意关于char转换到int,直接使用了强制类型转换； * 所得的int将对应于ascll表，对于不在表中的元素，那么将无法匹配（异常终止），由于使用c语言，故不作过多处理。 * @FilePath: \cpp\sort\RKM_char.cpp * 光阴之逆旅，百代之过客，而已 */#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define TYPE char#define M 3#define N 10//传入任意串计算hashint countHash(TYPE* P, int m)&#123;    int p = 0;    //计算hash的基准值    int datum = 127;    //首地址下元素乘以基准值    p = ((int)*(P))*datum;    TYPE * I = P;    for (int i = 1; i &lt; m; i++)    &#123;           I = I+i*sizeof(TYPE);        p += ((int)*(I));    // printf(&quot;%d\t%d\n&quot;,p,t);    &#125;    // printf(&quot;p=%d\n&quot;,p);    return p;&#125;int ifTP(TYPE* T, TYPE* P, int m, int s, int pHash)&#123;    //为T加上偏移        T = T+s*sizeof(TYPE);        int tHash = countHash(T,m);    printf(&quot;%d\t%d\n&quot;,pHash,tHash);    printf(&quot;------------------------------------\n&quot;);    //再次判断    if(tHash == pHash)&#123;        //此时的T处理过偏移，故无需传入偏移        return simpleComparsion(T,P,m);    &#125;    return 0;&#125;//对hash值相等的串，进行二次检查。//这将逐个检查每个元素。int simpleComparsion(TYPE* T, TYPE* P, int m)&#123;    for (int i = 0; i &lt; m; i++)    &#123;  //直接T+i也是可以的        T = T + (i)*sizeof(TYPE);        P = P + (i)*sizeof(TYPE);        if(*(P) != *(T))&#123;            return 0;        &#125;    &#125;        return 1;&#125;int intRKM(TYPE* T, TYPE* P, int m, int n)&#123;    //先计算P的Hash    int pHash = countHash(P,m);    int z = 0;    //循环计算所有可能的T子串的Hash,并分别与pHash进行比较    for (int i = 0; i &lt; n-m+1; i++)    &#123;   //每次迭代的i即为T的最新偏移地址        //偏移地址即每次循环中最新的T子串的首地址。        //因为数组下标从0而不是1开始，故判断条件为n-m+1        z++;        printf(&quot;第%d次执行\n&quot;,z);       if(ifTP(T,P,m,i,pHash))&#123;           return 1;       &#125;    &#125;        return 0;&#125;int main()&#123;    //P存放匹配串即模式，T存放文本串即被匹配串，从T中找p    TYPE P[M],T[N];    printf(&quot;请输入文本T:\n&quot;);    scanf(&quot;%s&quot;,T);    printf(&quot;请输入匹配P:\n&quot;);    scanf(&quot;%s&quot;,P);    //aBool为1时：T包含P,反之不然    int aBool = intRKM(T,P,M,N);    printf(&quot;%d&quot;,aBool);   &#125;</code></pre><p>测试结果：</p><p><img src="http://img.lbkzw.cn/img/image-20210929231606933.png" alt="image-20210929231606933"></p><p>附初代版本：</p><pre><code class="c">/* * @Author: itThree * @Date: 2021-09-28 17:38:05 * @LastEditTime: 2021-09-29 20:48:02 * @Description: 判断int类型串T中是否包含串P * @FilePath: \cpp\sort\RKM.cpp * 光阴之逆旅，百代之过客，而已 */#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include&lt;math.h&gt;#define TYPE intint ifTP(TYPE* T, TYPE* P, int m, int q, int s);int simpleComparsion(TYPE* T, TYPE* P, int m, int s);int intRKM(TYPE* T, TYPE* P, int m, int n, int q);//判断每次偏移后的T于P是否匹配int ifTP(TYPE* T, TYPE* P, int m, int q, int s)&#123;    int h = 10;    int p = 0;    int t = 0;    for (int i = 0; i &lt; m; i++)    &#123;           int n = pow(h,(m-i-1));        p += *(P+i)*n;        t += *(T+i+s)*n;    // printf(&quot;%d\t%d\n&quot;,p,t);    &#125;    printf(&quot;%d\t%d\n&quot;,p,t);    printf(&quot;------------------------------------\n&quot;);    //再次判断    if((p%q) == (t%q))&#123;        return simpleComparsion(T,P,m,s);    &#125;    return 0;&#125;//对hash值相等的串，进行二次检查。//这将逐个检查每个元素。int simpleComparsion(TYPE* T, TYPE* P, int m, int s)&#123;    for (int i = 0; i &lt; m; i++)    &#123;        if(*(P+i) != *(T+i+s))&#123;            return 0;        &#125;    &#125;        return 1;&#125;/** * @description:  * @param &#123;TYPE*&#125; T * @param &#123;TYPE*&#125; P * @param &#123;int&#125; m为P的长度 * @param &#123;int&#125; n为T的长度 * @param &#123;int&#125; q为mod * @return &#123; *  1:T中包含P; *  0:T中不包含P * &#125; */int intRKM(TYPE* T, TYPE* P, int m, int n, int q)&#123;    //改变基准地址,进行T/P匹配    //因为数组下标从0而不是1开始，故判断条件为n-m+1    for (int i = 0; i &lt; n-m+1; i++)    &#123;          if(ifTP(T,P,m,q,i))&#123;           //如一个T中包含多个P,可在此处改进记录位置           return 1;       &#125;    &#125;        return 0;&#125;int main()&#123;    int P[3] = &#123;1,2,3&#125;;    int T[10] = &#123;4,5,6,3,2,1,3&#125;;    int a = intRKM(T,P,3,10,3);    printf(&quot;%d&quot;,a);&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/%E2%95%A7%C3%AD%E2%95%A9%CE%A6%E2%95%A9%C2%B2%E2%95%AB%CE%98/"/>
      <url>2022/03/20/%E2%95%A7%C3%AD%E2%95%A9%CE%A6%E2%95%A9%C2%B2%E2%95%AB%CE%98/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><pre><code class="c">/* * @Author: itThree * @Date: 2021-09-10 15:48:10 * @LastEditTime: 2021-09-15 15:58:50 * @Description:  * @FilePath: \cpp\datas\sparseArr.cpp * 光阴之逆旅，百代之过客，而已 */#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;void printArr(int *arr, int row, int col);/** * 稀疏数组：将二维数组进行“压缩”； * 使用n+1行3列，其中n为原数组中有效（非零）元素个数，稀疏数组第0行用于存放行、列、元素总数信息故需n+1行*///统计数组中元素的个数，用于确定稀疏数组的行数int countElement(int* &amp;p, int row, int col)&#123;    int sum;    int n = row*col;    for(int i=0; i&lt;n; i++)&#123;        if(*(p+i) != 0)&#123;            sum++;        &#125;    &#125;    printf(&quot;sum:\t%d\n&quot;,sum);    return sum;&#125;//以指针形式接收矩阵（二维数组）void createSparseArr2(int* arr, int row, int col ,int n)&#123;    int sparse[n+1][3];    sparse[0][0] = row;    sparse[0][1] = col;    sparse[0][2] = n;    int sparseRow = 0;    for(int i=0;i&lt;row;i++)&#123;        for(int j=0;j&lt;col;j++)&#123;            if(*(arr+i*col+j)!=0)&#123;               sparseRow++;               sparse[sparseRow][0] = i;               sparse[sparseRow][1] = j;               sparse[sparseRow][2] = *(arr+i*col+j);           &#125;        &#125;                &#125;    printArr((int*)sparse,n+1,3);&#125;//这个稀疏数组的存储算法为n^2，还可用指针实现一个n。//打印二维数组void printArr(int *arr, int row, int col)&#123;//指针指向二维数组首地址，依靠row,col判别边界条件    //遍历行    for(int i=0;i&lt;row;i++)&#123;        //遍历列        for(int j=0;j&lt;col;j++)printf(&quot;%d \t&quot;,*(arr+i*col+j));        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    int source[4][8]&#123;        &#123;1,7,6,5,2,8,2,8&#125;,        &#123;2,7,6,5,2,8,2,8&#125;,        &#123;3,7,6,5,2,8,2,8&#125;,        &#123;4,7,6,5,2,8,2,8&#125;    &#125;;    int* p;    p = source[0];    int n = countElement(p,4,8);    printf(&quot;-------------------------------------------\n&quot;);        createSparseArr2((int*)source,4,8,n);    //int* i[4];    //指针i指向二维数组的一行    //i[0] = source[0];    //i[1] = source [1];    //i[2] = source [2];    //i[3] = source [3];    // createSparseArr1(i,4,8,n);    return 0;&#125;</code></pre><h2 id="使用指针数组方式创建稀疏数组"><a href="#使用指针数组方式创建稀疏数组" class="headerlink" title="使用指针数组方式创建稀疏数组"></a>使用指针数组方式创建稀疏数组</h2><pre><code class="c">//使用指针数组传值void createSparseArr1(int* p1[], int row, int col, int n)&#123;    //需要多一行来存储原数组大小信息    int sparse[n+1][3];    sparse[0][0] = row;    sparse[0][1] = col;    sparse[0][2] = n;    //控制稀疏数组的行号    int sparseRow = 0;    for (int i = 0; i &lt; row; i++)   &#123;       for (int j = 0; j &lt; col; j++)       &#123;    //原数数组索引处有无元素为判断条件，有则放入稀疏数组，无则进行下一次循环           if(p1[i][j]!=0)&#123;               //第0行已存放数据，故先行++               sparseRow++;               sparse[sparseRow][0] = i;               sparse[sparseRow][1] = j;               sparse[sparseRow][2] = p1[i][j];           &#125;       &#125;          &#125;    printArr((int*)sparse,n+1,3);&#125;</code></pre><h1 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h1><h2 id="强制转换数组首地址为指针返回不可行"><a href="#强制转换数组首地址为指针返回不可行" class="headerlink" title="强制转换数组首地址为指针返回不可行"></a>强制转换数组首地址为指针返回不可行</h2><p><img src="http://img.lbkzw.cn/img/image-20210915152000718.png" alt="image-20210915152000718"></p><p>报错的地方：</p><pre><code class="c">int sparse[n+1][3];return (int*) sparse;</code></pre><p><strong>解答</strong>：在函数执行完毕并return后sparse数组将被销毁，故无法将其强制转换为指针类型并返回；</p><p>不过，指定一个指针指向sparse并返回倒不成问题。</p><h2 id="指针与数组地址"><a href="#指针与数组地址" class="headerlink" title="指针与数组地址"></a>指针与数组地址</h2><pre><code class="c">int source[4][8]&#123;        &#123;1,7,6,5,2,8,2,8&#125;,        &#123;2,7,6,5,2,8,2,8&#125;,        &#123;3,7,6,5,2,8,2,8&#125;,        &#123;4,7,6,5,2,8,2,8&#125;    &#125;;    int* p;    p = source[0];    int* i[4];    //指针i指向二维数组的一行    i[0] = source[0];    i[1] = source [1];    i[2] = source [2];    i[3] = source [3];//得出结果    // source[0]，source[0][0]在同一地址下     printf(&quot;p:\t%d\n&quot;, p);    printf(&quot;source[0]:\t%d\n&quot;, source[0]);    printf(&quot;&amp;source[0][0]:\t%d\n&quot;, &amp;source[0][0]);    printf(&quot;source[0][0]:\t%d\n&quot;, source[0][0]);    printf(&quot;*p:\t%d\n&quot;, *p);    //使用指针数组指向二维数组每行首地址可行    printf(&quot;i[1][i]:\t%d\n&quot;, i[1][2]);        printf(&quot;*(p+31)\t%d\n&quot;, *(p+31));    //下标溢出了哦！    printf(&quot;*(p+32)\t%d\n&quot;, *(p+32));</code></pre><p>运行结果：<img src="http://img.lbkzw.cn/img/image-20210915153230219.png" alt="image-20210915153230219"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/20210213/"/>
      <url>2022/03/20/20210213/</url>
      
        <content type="html"><![CDATA[<p>很久没有更新blog了。</p><p>多年以后你会想起么，也会同样哼着这首歌。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>期末作业-数据库mysql</title>
      <link href="2022/03/20/2020-dataB-End/"/>
      <url>2022/03/20/2020-dataB-End/</url>
      
        <content type="html"><![CDATA[<h1 id="原题如下"><a href="#原题如下" class="headerlink" title="原题如下"></a>原题如下</h1><p>设有一个工程供应数据库系统，包括如下四个关系模式： </p><p>S(SNO，SNAME， STATUS，CITY)；（SNO的域为1001-1999） </p><p>P(PNO，PNAME，COLOR，WEIGHT)； （PNO的域为2001-2999）</p><p>J(JNO，JNAME，CITY)；（JNO的域为3001-3999） </p><p>SPJ(SNO，PNO，JNO，QTY)； </p><p>供应商表S由供应商号、供应商名、状态、城市组成； </p><p>零件表P 由零件号、零件名、颜色、重量组成； </p><p>工程项目表J由项目号、项目名、城市组成； </p><p>供应情况表SPJ由供应商号、零件号、项目号、供应数量组成； </p><p>1、创建数据库SPJ；</p><p>2、使用数据库SPJ；</p><p>3、创建4个具体表，分别为供应商表S、零件表P、工程项目表J、供应情况表SPJ；</p><p>4、每个表分别插入2-3条数据（供应商名为自己姓名）；</p><p>5、用SQL查询供应工程J3001零件为红色的工程号JNO；</p><p>6、用SQL查询没有使用天津供应商生产的零件的工程号；</p><p>7、用SQL语句将全部红色零件改为蓝色； </p><p>8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系；</p><p>9、用SQL语句删除供应商表S中SNO为1001的供应商；</p><h1 id="答题操作"><a href="#答题操作" class="headerlink" title="答题操作"></a>答题操作</h1><p>沙雕第一步建库再删库</p><h2 id="1、创建数据库SPJ"><a href="#1、创建数据库SPJ" class="headerlink" title="1、创建数据库SPJ"></a>1、创建数据库SPJ</h2><p><code>CREATE DATABASE SPJ;</code></p><h2 id="2-使用数据库SPJ"><a href="#2-使用数据库SPJ" class="headerlink" title="2.使用数据库SPJ"></a>2.使用数据库SPJ</h2><p><code>USE spj;</code></p><h2 id="3、创建4个具体表"><a href="#3、创建4个具体表" class="headerlink" title="3、创建4个具体表"></a>3、创建4个具体表</h2><p>分别为供应商表S、零件表P、工程项目表J、供应情况表SPJ</p><p><strong>创建供应商表S</strong></p><pre><code class="sql">CREATE TABLE `S`(`SNO` INT NOT NULL AUTO_INCREMENT, -- 不为null 自增长 `SNAME` VARCHAR(100) NOT NULL,`STATUS`VARCHAR(100) NOT NULL,`CITY` VARCHAR(100) NOT NULL,PRIMARY KEY ( `SNO` ),   -- 设置SNO为主键CHECK(`SNO`&gt;=1001 AND `SNO`&lt;1999) -- 设置列范围)ENGINE=INNODB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8;  -- 设置数据库引擎为INNODB 主键自增长从1001开始 默认编码为utf8</code></pre><p><strong>创建零件表P</strong></p><pre><code class="sql">CREATE TABLE `P`(`PNO` INT NOT NULL AUTO_INCREMENT,`PNAME` VARCHAR(100) NOT NULL,`COLOR`VARCHAR(100) NOT NULL,`WEIGHT` VARCHAR(100) NOT NULL,PRIMARY KEY ( `PNO` ),CHECK(`PNO`&gt;=2001 AND `PNO`&lt;2999))ENGINE=INNODB AUTO_INCREMENT=2001 DEFAULT CHARSET=utf8;</code></pre><p><strong>创建工程项目表J</strong></p><pre><code class="sql">CREATE TABLE `J`(`JNO` INT NOT NULL AUTO_INCREMENT,`JNAME` VARCHAR(100) NOT NULL,`CITY`VARCHAR(100) NOT NULL,PRIMARY KEY ( `JNO` ),CHECK(`JNO`&gt;=3001 AND `JNO`&lt;3999))ENGINE=INNODB AUTO_INCREMENT=2001 DEFAULT CHARSET=utf8;</code></pre><p><strong>供应情况表SPJ</strong></p><pre><code class="sql">CREATE TABLE `SPJ`(`SNO` VARCHAR(100) NOT NULL,`PNO` VARCHAR(100) NOT NULL,`JNO` VARCHAR(100) NOT NULL,`QTY` VARCHAR(100) NOT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre><h2 id="4、每个表分别插入2-3条数据（供应商名为自己姓名）"><a href="#4、每个表分别插入2-3条数据（供应商名为自己姓名）" class="headerlink" title="4、每个表分别插入2-3条数据（供应商名为自己姓名）"></a>4、每个表分别插入2-3条数据（供应商名为自己姓名）</h2><p><strong>供应商表S插入数据</strong></p><pre><code class="sql">INSERT INTO `s`VALUES (&#39;1001&#39;,&#39;赵玉豪&#39;,&#39;火爆&#39;,&#39;深圳&#39;);INSERT INTO `s`VALUES (&#39;1002&#39;,&#39;赵玉豪&#39;,&#39;火爆&#39;,&#39;深圳&#39;);</code></pre><p><strong>供零件表S插入数据</strong></p><pre><code class="sql">INSERT INTO `p`VALUES (&#39;2002&#39;,&#39;把手&#39;,&#39;白色&#39;,&#39;5kg&#39;);INSERT INTO `p`VALUES (&#39;2002&#39;,&#39;把手&#39;,&#39;白色&#39;,&#39;5kg&#39;);</code></pre><p><strong>工程项目表S插入数据</strong></p><pre><code class="sql">INSERT INTO `j`VALUES (&#39;3001&#39;,&#39;wwz666&#39;,&#39;深圳&#39;);</code></pre><pre><code class="sql">INSERT INTO `j`VALUES (&#39;3002&#39;,&#39;wwz666666&#39;,&#39;深圳&#39;);</code></pre><p><strong>供应情况表SPJ插入数据</strong></p><pre><code class="sql">INSERT INTO `spj`VALUES (&#39;1001&#39;,&#39;2001&#39;,&#39;3001&#39;,&#39;100&#39;);INSERT INTO `spj`VALUES (&#39;1002&#39;,&#39;2002&#39;,&#39;3002&#39;,&#39;200&#39;);</code></pre><h2 id="5、用SQL查询供应工程J3001零件为红色的工程号JNO；"><a href="#5、用SQL查询供应工程J3001零件为红色的工程号JNO；" class="headerlink" title="5、用SQL查询供应工程J3001零件为红色的工程号JNO；"></a>5、用SQL查询供应工程J3001零件为红色的工程号JNO；</h2><pre><code class="sql">SELECT DISTINCT JNO,COLOR FROM J,PWHERE JNO=&#39;J3001&#39; AND COLOR=&#39;红色&#39;</code></pre><h2 id="6、用SQL查询没有使用天津供应商生产的零件的工程号；"><a href="#6、用SQL查询没有使用天津供应商生产的零件的工程号；" class="headerlink" title="6、用SQL查询没有使用天津供应商生产的零件的工程号；"></a>6、用SQL查询没有使用天津供应商生产的零件的工程号；</h2><pre><code class="sql">SELECT JNO FROM JWHERE NOT CITY IN(&#39;天津&#39;)</code></pre><h2 id="7、用SQL语句将全部红色零件改为蓝色；"><a href="#7、用SQL语句将全部红色零件改为蓝色；" class="headerlink" title="7、用SQL语句将全部红色零件改为蓝色；"></a>7、用SQL语句将全部红色零件改为蓝色；</h2><pre><code class="sql">UPDATE pSET COLOR=&#39;蓝色&#39;;</code></pre><h2 id="8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系"><a href="#8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系" class="headerlink" title="8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系"></a>8、用SQL语句将（S1001，P2001，J3001，400）插入供应情况关系</h2><pre><code class="sql">INSERT INTO `spj`VALUES (&#39;S1001&#39;,&#39;P2001&#39;,&#39;J3001&#39;,&#39;400&#39;);</code></pre><h2 id="9、用SQL语句删除供应商表S中SNO为1001的供应商"><a href="#9、用SQL语句删除供应商表S中SNO为1001的供应商" class="headerlink" title="9、用SQL语句删除供应商表S中SNO为1001的供应商"></a>9、用SQL语句删除供应商表S中SNO为1001的供应商</h2><pre><code class="sql">DELETE FROM sWHERE SNO=&#39;1001&#39;;</code></pre><h1 id="最终效果如下："><a href="#最终效果如下：" class="headerlink" title="最终效果如下："></a>最终效果如下：</h1><p>暂未上传<br><img src="https://img.lbkzw.cn/img/image-20201214090605188.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找回宝塔面板信息|ssh密钥免密登录服务器</title>
      <link href="2022/03/20/20210805/"/>
      <url>2022/03/20/20210805/</url>
      
        <content type="html"><![CDATA[<h1 id="找回宝塔面板信息"><a href="#找回宝塔面板信息" class="headerlink" title="找回宝塔面板信息"></a>找回宝塔面板信息</h1><ol><li>ssh连接服务器</li><li>输入 <code>/etc/init.d/bt default</code></li><li>解决</li></ol><p>补充：</p><ul><li><p>不用使用额外的ssh工具连接服务器，Linux下shell终端即可（win系统使用git终端也可）</p></li><li><p>附ssh常用命令：</p><pre><code class="shell">ssh root@127.0.0.1 #以root用户登入服务器地址为127.0.0.1的服务器ssh root@127.0.0.1 -i id_rsa #使用密钥登录，通常不用输入密码（不过要事先设置，如何设置请看下：）</code></pre><p><strong>前情提示：win系统需要借助git终端</strong></p><p>下面我们三步走：</p><ol><li><p>生成密钥——一路回车</p><p><img src="http://img.lbkzw.cn/img/image-20210805133916778.png"></p></li></ol><ol start="2"><li><p>上传密钥</p><p><img src="http://img.lbkzw.cn/img/image-20210805134301432.png" alt="image-20210805134301432"></p></li><li><p>使用密钥链接</p><p><img src="http://img.lbkzw.cn/img/image-20210805134359023.png" alt="image-20210805134359023"></p></li></ol><ul><li><p>上面操作用到的command</p><pre><code class="ssh">#注意密钥默认存放在.ssh目录（注意你的位置）#生成密钥ssh-keygen -t rsa #上传密钥ssh-copy-id -i id_rsa.pub root@127.0.0.1 -p 22</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="2022/03/20/Ajax-01/"/>
      <url>2022/03/20/Ajax-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用于局部刷新</p></blockquote><h1 id="异步对象-XMLHttpRequest"><a href="#异步对象-XMLHttpRequest" class="headerlink" title="异步对象(XMLHttpRequest)"></a>异步对象(XMLHttpRequest)</h1><p> readyState属性表示异步对象请求的状态变化<br>     0：创建异步对象时， new XMLHttpRequest();<br>     1: 初始异步请求对象， xmlHttp.open()<br>     2：发送请求， xmlHttp.send()<br>     3: 从服务器端获取了数据，此时3， 注意3是异步对象内部使用， 获取了原始的数据。<br>     4：异步对象把接收的数据处理完成后。 此时开发人员在4的时候处理数据。<br>        在4的时候，开发人员更新当前页面。</p><h2 id="计算bmi"><a href="#计算bmi" class="headerlink" title="计算bmi"></a>计算bmi</h2><p>demo全局刷新：</p><pre><code class="java">//servlet部分public class BmiServlet extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String name = request.getParameter(&quot;name&quot;);        String height = request.getParameter(&quot;height&quot;);        String weight = request.getParameter(&quot;weight&quot;);        float h = Float.valueOf(height);        float w = Float.valueOf(weight);        float bmi = w/(h*h);        //判断bmi        String msg = &quot;&quot;;        if( bmi &lt;= 18.5) &#123;            msg = &quot;您比较瘦&quot;;        &#125; else if( bmi &gt; 18.5 &amp;&amp; bmi &lt;= 23.9 )&#123;            msg = &quot;你的bmi是正常的&quot;;        &#125; else if( bmi &gt;24 &amp;&amp; bmi &lt;=27)&#123;            msg = &quot;你的身体比较胖&quot;;        &#125; else &#123;            msg = &quot;你的身体肥胖&quot;;        &#125;        System.out.println(&quot;msg=&quot;+msg);        msg = &quot;你好，&quot;+ name +&quot; &quot;+&quot;你的bim为&quot;+bmi + msg;        //存入bmi数据        request.setAttribute(&quot;msg&quot;,msg);        //这里通过response并以流的方式将数据传输到前端页面           response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter pw = response.getWriter();        pw.println(msg);        pw.flush();        pw.close();        //注意！！！这里使用的是转发来完成前后端交互       // request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(request,response);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;</code></pre><pre><code class="jsp">&lt;%--Jsp提交表单部分--%&gt;&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;全局刷新计算bmi&lt;/p&gt;&lt;%--注意这里使用的是表单，而我们案例中的局部刷新并未使用表单来提交前端数据--%&gt;&lt;form action=&quot;bmiPrintServlet&quot; method=&quot;get&quot;&gt;    姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;    身高：&lt;input type=&quot;text&quot; name=&quot;height&quot;&gt;&lt;br/&gt;    体重：&lt;input type=&quot;text&quot; name=&quot;weight&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="jsp">&lt;%--Jsp显示结果部分--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;显示bmi结果&lt;/h3&gt;&lt;p&gt;$&#123;msg&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>demo局部刷新</p><pre><code class="jsp">&lt;%--Jsp提交并显示结果部分--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;局部刷新-ajax&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //使用内存中的异步对象，代替浏览器发起请求。异步对象使用js创建和管理的。        function  doAjax() &#123;            //1.创建异步对象            var xmlHttp = new XMLHttpRequest();            //2.绑定事件            xmlHttp.onreadystatechange = function () &#123;                //处理服务器端返回的数据，更新当前页面                //alert(&quot;readyState属性值======&quot; + xmlHttp.readyState + &quot;| status:&quot; + xmlHttp.status)                if( xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status ==200)&#123;                    var  data = xmlHttp.responseText;                    //更新dom对象， 更新页面数据                    document.getElementById(&quot;mydata&quot;).innerText = data;                &#125;            &#125;            //3.初始请求数据            //获取dom对象的value属性值            var name = document.getElementById(&quot;name&quot;).value;            var w = document.getElementById(&quot;w&quot;).value;            var h = document.getElementById(&quot;h&quot;).value;            //bmiPrint?name=李四&amp;w=82&amp;h=1.8            var param = &quot;name=&quot;+name + &quot;&amp;w=&quot;+w+&quot;&amp;h=&quot;+h;            //alert(&quot;param=&quot;+param);            xmlHttp.open(&quot;get&quot;,&quot;bmiAjax?&quot;+param,true);            //4.发起请求            xmlHttp.send();        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;局部刷新ajax-计算bmi&lt;/p&gt;&lt;div&gt;    &lt;!-- 没有使用form  --&gt;    姓名：&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; &lt;br/&gt;    体重（公斤）:&lt;input type=&quot;text&quot; id=&quot;w&quot; /&gt; &lt;br/&gt;    身高（米）：&lt;input type=&quot;text&quot; id=&quot;h&quot; /&gt; &lt;br/&gt;    &lt;input type=&quot;button&quot; value=&quot;计算bmi&quot; onclick=&quot;doAjax()&quot;&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;div id=&quot;mydata&quot;&gt;等待加载数据....&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><blockquote><p>将对象转为Json格式的字符串</p></blockquote><p>Servlet:</p><pre><code class="java">package cn.it.three.controller;import cn.it.three.dao.ProvinceDao;import cn.it.three.entity.Province;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class QueryJsonServlet extends HttpServlet &#123;        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String json = &quot;&#123;&#125;&quot;;        String strProid = request.getParameter(&quot;proid&quot;);        if (strProid != null &amp;&amp; strProid.trim().length()&gt;0 )&#123;            //查询数据库            ProvinceDao dao = new ProvinceDao();            Province p = dao.queryProvinceById(Integer.valueOf(strProid));//将以对象的形式返回查询结果            //将对象转换为json数据            ObjectMapper om = new ObjectMapper();            json =om.writeValueAsString(p);        &#125;        //返回数据到前端        response.setContentType(&quot;application/json;charset=utf-8&quot;);//设置json输出编码为utf-8        PrintWriter printWriter = response.getWriter();        printWriter.println(json);        printWriter.flush();        printWriter.close();    &#125;&#125;</code></pre><p>DAO：</p><pre><code class="java">package cn.it.three.dao;import cn.it.three.entity.Province;import java.sql.*;//返回单个数据public class ProvinceDao &#123;    //根据id获取名称    public String queryProvinceNameById(Integer provinceId) &#123;        Connection conn = null;        PreparedStatement pst = null;        ResultSet rs = null;        String sql = &quot;&quot;;        String url = &quot;jdbc:mysql://localhost:3306/springdb&quot;;        String username = &quot;root&quot;;        String password = &quot;root&quot;;        String name = &quot;&quot;;        try &#123;            //加载驱动包            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //建立数据库连接            conn = DriverManager.getConnection(url, username, password);            //创建PreparedStatement            sql = &quot;select  name from province where id=?&quot;;            pst = conn.prepareStatement(sql);            //设置参数值            pst.setInt(1, provinceId);            //执行sql            rs = pst.executeQuery();            //遍历rs            /*while(rs.next())&#123; //当你的rs中有多余一条记录时。               name =  rs.getString(&quot;name&quot;);            &#125;*/            if (rs.next()) &#123;                name = rs.getString(&quot;name&quot;);            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //关闭资源            try &#123;                if (rs != null) &#123;                    rs.close();                &#125;                if (pst != null) &#123;                    pst.close();                &#125;                if (conn != null) &#123;                    conn.close();                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return name;    &#125;        //查询单个数据返回一个包含多个数据的对象    public Province queryProvinceById(Integer provinceId) &#123;        Connection conn = null;        PreparedStatement pst = null;        ResultSet rs = null;        String sql = &quot;&quot;;        String url = &quot;jdbc:mysql://localhost:3306/springdb&quot;;        String username = &quot;root&quot;;        String password = &quot;root&quot;;        Province province = null;//借助json返回多个信息时，我们采用返回对象的方式（json会对对象进行处理）        try &#123;            //加载驱动包            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //建立数据库连接            conn = DriverManager.getConnection(url, username, password);            //创建PreparedStatement            sql = &quot;select  id,name,jiancheng,shenghui from province where id=?&quot;;            pst = conn.prepareStatement(sql);            //设置参数值            pst.setInt(1, provinceId);            //执行sql            rs = pst.executeQuery();            //遍历rs            /*while(rs.next())&#123; //当你的rs中有多余一条记录时。               name =  rs.getString(&quot;name&quot;);            &#125;*/            if (rs.next()) &#123;                province = new Province();                //将查询到的数据写入对象中                province.setId(rs.getInt(&quot;id&quot;));                province.setJiancheng(rs.getString(&quot;jiancheng&quot;));                province.setName(rs.getString(&quot;name&quot;));                province.setShenghui(rs.getString(&quot;shenghui&quot;));            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //关闭资源            try &#123;                if (rs != null) &#123;                    rs.close();                &#125;                if (pst != null) &#123;                    pst.close();                &#125;                if (conn != null) &#123;                    conn.close();                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return province;    &#125;&#125;</code></pre><p>存储数据的对象</p><pre><code class="java">package cn.it.three.entity;public class Province &#123;    /**     * 用以存储查询数据*/    private Integer id;    private String name;    private String jiancheng;    private String shenghui;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getJiancheng() &#123;        return jiancheng;    &#125;    public void setJiancheng(String jiancheng) &#123;        this.jiancheng = jiancheng;    &#125;    public String getShenghui() &#123;        return shenghui;    &#125;    public void setShenghui(String shenghui) &#123;        this.shenghui = shenghui;    &#125;&#125;</code></pre><p>jsp</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;ajax根据省份id获取名称&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function search() &#123;            //发起ajax请求，传递参数给服务器， 服务器返回数据            //1.创建异步对象            var  xmlHttp  = new XMLHttpRequest();            //2.绑定事件            //readyState属性每更新一次，下面方法就执行一次     //        0：创建异步对象时， new XMLHttpRequest();     //        1: 初始异步请求对象， xmlHttp.open()     //        2：发送请求， xmlHttp.send()     //        3: 从服务器端获取了数据，此时3， 注意3是异步对象内部使用， 获取了原始的数据。     //        4：异步对象把接收的数据处理完成后。 此时开发人员在4的时候处理数据。     //    在4的时候，开发人员更新当前页面。            xmlHttp.onreadystatechange = function () &#123;                if( xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status== 200)&#123;                    //alert(xmlHttp.responseText)                    //更新页面，就是更新dom对象                    document.getElementById(&quot;proname&quot;).value= xmlHttp.responseText;                &#125;            &#125;            //3.初始异步对象            //获取proid文本框的值            var proid = document.getElementById(&quot;proid&quot;).value;            xmlHttp.open(&quot;get&quot;,&quot;queryProvince?proid=&quot;+proid,true);//以get方式发起请求            //4.发送请求            xmlHttp.send();        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;ajax根据省份id获取名称&lt;/p&gt;&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;省份编号：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proid&quot;/&gt;            &lt;input type=&quot;button&quot; value=&quot;搜索&quot; onclick=&quot;search()&quot; /&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;省份名称：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proname&quot; /&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;a href=&quot;html/main.jsp&quot;&gt;link&lt;/a&gt;&lt;/html&gt;</code></pre><p>Jquery</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;使用json格式的数据&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(function ()&#123;            $(&quot;:button&quot;).click(function ()&#123;//为按钮标签绑定监听事件                var proid =$(&quot;#proid&quot;).val();//获取输入值                $.ajax(&#123;                    url:&quot;queryJsonServlet&quot;,                    data:&#123;&quot;proid&quot;:proid&#125;,                    dataType:&quot;json&quot;,//期望服务端返回json数据                    //更新页面显示返回数据                    success:function (resp)&#123;                        $(&quot;#proname&quot;).val(resp.name)                        $(&quot;#projiancheng&quot;).val(resp.jiancheng)                        $(&quot;#proshenghui&quot;).val(resp.shenghui)                    &#125;                &#125;)            &#125;)        &#125;)    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;ajax请求使用json格式的数据&lt;/p&gt;&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;省份编号：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proid&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;搜索&quot;&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;省份名称：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proname&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;省份简称：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;projiancheng&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;省会名称：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;proshenghui&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie</title>
      <link href="2022/03/20/Cookie-01/"/>
      <url>2022/03/20/Cookie-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote><p>用户访问一个网站时，服务器响应时返回cookie，当用户再次访问此网站时（请求头）会携带cookie，服务器以cookie识别用户</p></blockquote><p>作用：在不登录的情况下，完成服务器对客户端的身份识别</p><p>常用方法：</p><p><code>new Cookie(String name, String value) </code>创建Cookie并初始化数据     <code>response.addCookie(Cookie cookie) </code>发送Cookie到客户端<br><code>Cookie[]  request.getCookies() </code>获取Cookie</p><p><code>setMaxAge(int seconds)</code>用于指定cookie存活时间，时间到后，cookie文件自动失效</p><pre><code>               1. 正数：将Cookie数据写到硬盘的文件中，以秒为单位计时，到期cookie自动失效               2. 负数：默认值,关闭浏览器就删除cookie               3. 零：删除cookie信息</code></pre><p>将中文数据存储至cookie事先要进行URL编码操作，在需要的时候进行解码操作</p><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code class="java">/**是否为首次访问：如是则发出欢迎语句，否则提示上次登录时间*/@WebServlet(&quot;/CookieTest&quot;)public class CookieTest extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);//设置响应消息体格式以及编码        Cookie[] cookies = request.getCookies();//获取Cookie        boolean flag = false;//是否首次访问的标志，默认为false        //遍历cookies        if (cookies !=null &amp;&amp; cookies.length &gt; 0)&#123;            for (Cookie cookie:cookies) &#123;                String name = cookie.getName();//获取cookie名称                System.out.println(&quot;cookie name=&quot;+name);                //不是第一次访问                if (&quot;lastTime&quot;.equals(name))&#123;                    flag = true;//第一次访问后将其设为true                    Date date = new Date();//获取当前时间                    //设置日期格式                    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                    String str_date = sdf.format(date);//对日期进行格式化                    System.out.println(&quot;编码前：&quot;+str_date);                    //URL编码（对中文进行编码便于存储至cookie）                    str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                    System.out.println(&quot;编码后：&quot;+str_date);                    cookie.setValue(str_date);//修改cookie的值                    cookie.setMaxAge(60*60*24*30);//设置cookie有效期一个月                    response.addCookie(cookie);//发送cookie到客户端                    //响应操作                    String value = cookie.getValue();                    System.out.println(&quot;解码前： &quot;+ value);                    value = URLDecoder.decode(value,&quot;utf-8&quot;);//解码操作                    System.out.println(&quot;解码后：&quot; + value);                    response.getWriter().write(&quot;欢迎回来！您上次访问时间为：&quot; + value);                    break;                &#125;            &#125;        &#125;        if (cookies!=null || cookies.length&gt;0 || flag ==false)&#123;            Date date = new Date();//获取当前时间            //设置日期格式            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);            String str_date = sdf.format(date);//对日期进行格式化            System.out.println(&quot;编码前：&quot;+str_date);            //URL编码（对中文进行编码便于存储至cookie）            str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);            System.out.println(&quot;编码后：&quot;+str_date);            Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);//创建名为lastTime值为当前时间的cookie            cookie.setMaxAge(60*60*24*30);//设置cookie有效期一个月            response.addCookie(cookie);//发送cookie到客户端            //响应            response.getWriter().write(&quot;欢迎您首次访问！&quot;);        &#125;    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;</code></pre><h1 id="共享Cookie"><a href="#共享Cookie" class="headerlink" title="共享Cookie"></a>共享Cookie</h1><p>同一服务器下共享：</p><p><code>setPath(String path)</code>设置cookie的获取范围。</p><p>默认情况下，设置当前的虚拟目录如果要共享，则可将path设置为”/“</p><p>同一域名下共享：</p><p><code>setDomain(String path)</code>:如果设置一级域名相同，那么多个服务器之间cookie可以共享</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p><p>Session的实现依赖于Cookie</p><p><img src="http://img.lbkzw.cn/img/20201012161222.png" alt="image-20201012161222663"></p><p>session的特点</p><ol><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol><p>session与Cookie的区别：</p><ol><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li><li>session数据安全，Cookie相对于不安全</li></ol><p>方法：</p><p>获取HttpSession对象</p><p><code>HttpSession session = request.getSession();</code> </p><p>使用HttpSession对象</p><p><code>Object getAttribute(String name)  </code></p><p><code>void setAttribute(String name, Object value)</code><br><code>void removeAttribute(String name)  </code></p><pre><code class="java">//在一次会话的多次请求间共享数据@WebServlet(&quot;/SessionDemo1&quot;)public class SessionDemo1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        HttpSession session = request.getSession();//获取Session对象        session.setAttribute(&quot;msg&quot;,&quot;Hello Session!&quot;);//设置Session    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;@WebServlet(&quot;/SessionDemo2&quot;)public class SessionDemo2 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        HttpSession session = request.getSession();//获取Session对象        Object msg =session.getAttribute(&quot;msg&quot;);//获取键为msg的值        System.out.println(msg);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;</code></pre><p><strong>当客户端关闭后，服务器不关闭，再次获取得的Session与之前的Session不是同一个</strong></p><p>如何在关闭客户端或服务端的前提下，保存Session数据呢？</p><p>创建Cookie,键为JSESSIONID，并存入Session id。</p><pre><code class="java">@WebServlet(&quot;/SessionDemo2&quot;)public class SessionDemo2 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        HttpSession session = request.getSession();//获取Session对象                Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,session.getId());        cookie.setMaxAge(60*60);        response.addCookie(cookie);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;</code></pre><p><strong>客户端不关闭，服务器关闭后，两次获取的session不是同一个，且数据不丢失。</strong></p><p>tomcat自动完成以下工作：</p><blockquote><p>session的钝化：            </p><p>在服务器正常关闭之前，将session对象系列化到硬盘上（保存临时文件至Work目录）</p><p>session的活化：</p><p>在服务器启动后，将session文件转化为内存中的session对象即可。</p><p>在idea里的web项目，在重启Tomcat后会删除保存临时文件的Work目录，再新建Work目录从而无法完成活化。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Java </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS作用域</title>
      <link href="2022/03/20/JS-01/"/>
      <url>2022/03/20/JS-01/</url>
      
        <content type="html"><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>JavaScript是编译型语言，不同的是JavaScript的代码编译发生在代码执行前的几微秒内</p><h1 id="LHS与RHS"><a href="#LHS与RHS" class="headerlink" title="LHS与RHS"></a>LHS与RHS</h1><p>LHS查找的目的为了赋值</p><p>RHS查找的目的是为了引用值</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域查找从词法作用域（即最内部作用域）开始逐层向上查找，直到匹配到或触顶为止</p><img src="http://img.lbkzw.cn/img/20200830120120.png" alt="screenshot_2020_08_13T21_09_28+0800" style="zoom:50%;" /><p>全局变量会自动成为全局对象，因此可通过<code> window.a（a是要访问的变量）</code>访问被同名变量屏蔽的全局变量</p><h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>使用欺骗词法则JavaScript引擎无法对作用域栈进行优化</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><pre><code class="js">    /*在函数内动态创建变量b，屏蔽全局变量b*/        function foo(str,a)&#123;            eval(str);//动态创建代码            console.log(a,b);        &#125;        var b = 2;        foo(&quot;var b = 3;&quot;,1);    /*结果：1,3*/</code></pre><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><pre><code class="js">/*重复引用对象的多个属性*/        var obj = &#123;            a = 1,            b = 2        &#125;;        with(obj)&#123;            a = 3;            b = 4;            c = 5;//对象obj中没有c，返回undefined,并创建一个全局变量c = 5;        &#125;</code></pre><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数中的作用域属于局部作用域，函数具有很好的闭包性，隐藏该隐藏的。</p><p>JavaScript中多</p><h3 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h3><ul><li>两种方式</li></ul><pre><code class="js">/*ONE*/        (function foo()&#123;            var a = 2;            console.log(a);        &#125;)();/*TWO*/          (function foo()&#123;            var a = 2;            console.log(a);        &#125;());//括号位置不同哦</code></pre><ul><li>传入参数</li></ul><pre><code class="js">       /*传入window对象，引用全局变量*/        var a = 2;        (function (global)&#123;//匿名IIFE            var a = 3;            console.log(a);             console.log(global.a);        &#125;)(window)/*结果：3,2*/</code></pre><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>变量声明、函数声明均会提升到顶部。</p><p>let声明的块中的变量声明不会提升，而是保留在原地</p><p>函数先于变量提升，函数表达式不会被提升，后面的函数声明覆盖前面的函数声明</p><pre><code class="js">        function a()&#123;            console.log(1);        &#125;        a = function a()&#123;//不会被提升            console.log(2);        &#125;                function a()&#123;            console.log(3);        &#125;        a();/*结果：3*/</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>调用一个函数只返回其属性数据，而没有返回闭包对象（函数内的函数）的不是真模块</p><p>具有函数属性的对象不是真模块</p><pre><code class="js">/*一个模块*/        function CoolModule()&#123;            var something = &quot;so&quot;;            var another = [1,2,3];            function doSomething()&#123;                console.log(something);            &#125;            function doAnother()&#123;                console.log(another.join(&quot;!&quot;));            &#125;            return &#123;                doSomething:doSomething,                doAnother:doAnother            &#125;;        &#125;        var foo = CoolModule();        foo.doAnother();        foo.doSomething();/*一个单例模式*/        var foo = (function CoolModule()&#123;            var something = &quot;so&quot;;            var another = [1,2,3];            function doSomething()&#123;                console.log(something);            &#125;            function doAnother()&#123;                console.log(another.join(&quot;!&quot;));            &#125;            return &#123;                doSomething:doSomething,                doAnother:doAnother            &#125;;        &#125;)();        foo.doAnother();        foo.doSomething();/*结果：1！2！3！so*/</code></pre><h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><h4 id="未来模块机制（python）"><a href="#未来模块机制（python）" class="headerlink" title="未来模块机制（python）"></a>未来模块机制（python）</h4><pre><code>//a.js,一个单独的模块function a()&#123;    ...&#125;export a;//将当前模块的（变量、函数）标识符导出为公共API</code></pre><pre><code>//b.jsimport a from &quot;a&quot;;//从模块a，导入函数a()function b()&#123;    ...&#125;export b;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC基本使用</title>
      <link href="2022/03/20/JDBC-01/"/>
      <url>2022/03/20/JDBC-01/</url>
      
        <content type="html"><![CDATA[<p>前言：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库，是官方（sun公司）定义的一套操作所有关系型数据库的接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p><ul><li>步骤：<ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar<br> 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下<br> 2.右键–&gt;Add As Library</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol></li></ul><h1 id="Statement：执行sql的对象"><a href="#Statement：执行sql的对象" class="headerlink" title="Statement：执行sql的对象"></a>Statement：执行sql的对象</h1><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><blockquote><ol><li><p>boolean execute(String sql) ：可以执行任意的sql</p></li><li><p>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句,即增删改查</p><blockquote><p>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</p></blockquote></li></ol></blockquote><pre><code class="java">package cn.itcast.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestJDBC1&#123;    public static void main(String[] args) &#123;        Statement stmt = null;        Connection conn = null;        try &#123;            //注册驱动            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //定义sql语句            String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;            //获取Connection对象            conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;,&quot;root&quot;,&quot;root&quot;);            //获取执行sql的对象Statement            stmt = conn.createStatement();            //执行sql            int count = stmt.executeUpdate(sql);//此方法将返回执行后的影响行数数值,此方法用于执行增、删、改、查的sql语句            // int count = stmt.execute(sql) ：可以执行任意的sql            System.out.println(count);            if(count &gt; 0)&#123;                System.out.println(&quot;添加成功！&quot;);            &#125;else&#123;                System.out.println(&quot;添加失败！&quot;);            &#125;        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException throwables) &#123;            throwables.printStackTrace();        &#125;finally &#123;            //释放资源            if (stmt != null)&#123;                try &#123;                    stmt.close();                &#125; catch (SQLException throwables) &#123;                    throwables.printStackTrace();                &#125;            &#125;            if (conn != null)&#123;                try &#123;                    conn.close();                &#125; catch (SQLException throwables) &#123;                    throwables.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="封装数据库表到对象"><a href="#封装数据库表到对象" class="headerlink" title="封装数据库表到对象"></a>封装数据库表到对象</h2><blockquote><p>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</p><p>（可用来将表数据封装为对象并装载入集合）</p></blockquote><pre><code class="java">package cn.itcast.jdbc;import java.sql.*;import java.util.ArrayList;import java.util.Date;import java.util.List;public class TestJDBC3 &#123;    public List&lt;Emp&gt; findAll()&#123;        Statement stmt = null;        Connection conn = null;        ResultSet rs = null;        List&lt;Emp&gt;list = null;        try &#123;            //注册驱动            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //定义sql语句            String sql = &quot;select * from emp&quot;;            //获取Connection对象            conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;,&quot;root&quot;,&quot;root&quot;);            //获取执行sql的对象Statement            stmt = conn.createStatement();            //执行sql            rs = stmt.executeQuery(sql);            Emp emp = null;            list = new ArrayList&lt;Emp&gt;();            while (rs.next())&#123;//        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true//                        * getXxx(参数):获取数据//                        * Xxx：代表数据类型   如： int getInt() ,    String getString()//                        * 参数：//                1. int：代表列的编号,从1开始   如： getString(1)//                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)                //获取数据                int id = rs.getInt(&quot;id&quot;);                String ename = rs.getString(&quot;ename&quot;);                int job_id = rs.getInt(&quot;job_id&quot;);                int mgr = rs.getInt(&quot;mgr&quot;);                Date joindate = rs.getDate(&quot;joindate&quot;);                double salary = rs.getDouble(&quot;salary&quot;);                double bonus = rs.getDouble(&quot;bonus&quot;);                int dept_id = rs.getInt(&quot;dept_id&quot;);                //创建Emp对象并赋值                emp = new Emp();                emp.setId(id);                emp.setEname(ename);                emp.setJob_id(job_id);                emp.setMgr(mgr);                emp.setSalary(salary);                emp.setBonus(bonus);                emp.setDept_id(dept_id);                //装载进集合                list.add(emp);            &#125;        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException throwables) &#123;            throwables.printStackTrace();        &#125;finally &#123;            //释放资源            if (rs != null)&#123;                try &#123;                    rs.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (stmt != null)&#123;                try &#123;                    stmt.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return list;    &#125;    public static void main(String[] args) &#123;       var a = new TestJDBC3();        System.out.println(a.findAll());    &#125;&#125;</code></pre><h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol><li>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li><li>操作：<ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li>使用Connection对象来管理事务<ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务</li></ul></li></ul></li></ol><pre><code class="java">        public class JDBCDemo10 &#123;        public static void main(String[] args) &#123;            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;                try &#123;                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                    //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                    pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                    pstmt2.executeUpdate();                //提交事务                conn.commit();            &#125; catch (Exception e) &#123;                //事务回滚                try &#123;                    if(conn != null) &#123;                        conn.rollback();                    &#125;                &#125; catch (SQLException e1) &#123;                    e1.printStackTrace();                &#125;                e.printStackTrace();            &#125;finally &#123;                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            &#125;        &#125;        &#125;</code></pre><p>​        </p><h1 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h1><p>通常我们获取一个数据库连接对象，在使用后将其释放。这需要繁琐的申请与释放操作，而我们有更好的方案：即从数据库连接池处获取对象，在不使用的时候再将其归还到连接池中。</p><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p><p>操作步骤：</p><ol><li>导入jar包 </li><li>定义配置文件：以properties形式，可叫任意名称，可放在任意目录下。</li><li>加载配置文件。Properties</li><li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol><h2 id="导入并使用jar包"><a href="#导入并使用jar包" class="headerlink" title="导入并使用jar包"></a>导入并使用jar包</h2><blockquote><ol><li><img src="http://img.lbkzw.cn/img/20200918202606.png" alt="image-20200918202606795" style="zoom: 50%;" /></li></ol></blockquote><blockquote><ol start="2"><li><img src="http://img.lbkzw.cn/img/20200918202636.png" alt="image-20200918202636057" style="zoom:50%;" /></li></ol></blockquote><h2 id="Properties文件配置"><a href="#Properties文件配置" class="headerlink" title="Properties文件配置"></a>Properties文件配置</h2><pre><code class="java">driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/db4username=rootpassword=rootinitialSize=1//初始数据库连接数maxActive=10//最大数据库连接数maxWait=3000</code></pre><h2 id="数据库连接池的工具类"><a href="#数据库连接池的工具类" class="headerlink" title="数据库连接池的工具类"></a>数据库连接池的工具类</h2><pre><code class="java">package cn.itcast.utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * Druid连接池的工具类 */public class JDBCUtils &#123;    //1.定义成员变量 DataSource    private static DataSource ds ;    static&#123;        try &#123;            //1.加载配置文件            Properties pro = new Properties();            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));            //2.获取DataSource            ds = DruidDataSourceFactory.createDataSource(pro);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 获取连接     */    public static Connection getConnection() throws SQLException &#123;        return ds.getConnection();    &#125;    /**     * 释放资源     */    public static void close(Statement stmt,Connection conn)&#123;       /* if(stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if(conn != null)&#123;            try &#123;                conn.close();//归还连接            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;*/       close(null,stmt,conn);    &#125;    public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;        if(rs != null)&#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if(stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if(conn != null)&#123;            try &#123;                conn.close();//归还连接            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 获取连接池方法     */    public static DataSource getDataSource()&#123;        return  ds;    &#125;&#125;</code></pre><p>使用连接池工具类</p><pre><code class="java">package cn.itcast.datasource.druid;import cn.itcast.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 使用新的工具类 */public class DruidDemo2 &#123;    public static void main(String[] args) &#123;        /*         * 完成添加操作：给account表添加一条记录         */        Connection conn = null;        PreparedStatement pstmt = null;        try &#123;            //1.获取连接            conn = JDBCUtils.getConnection();            //2.定义sql            String sql = &quot;insert into account values(null,?,?)&quot;;            //3.获取pstmt对象            pstmt = conn.prepareStatement(sql);            //4.给？赋值            pstmt.setString(1,&quot;王五&quot;);            pstmt.setDouble(2,3000);            //5.执行sql            int count = pstmt.executeUpdate();            System.out.println(count);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            //6. 释放资源            JDBCUtils.close(pstmt,conn);        &#125;    &#125;&#125;</code></pre><h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><blockquote><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></blockquote><p>步骤：</p><ol><li><p>导入jar包(注意版本要匹配，如mysql版本，数据库驱动版本等)</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li>JdbcTemplate template = new JdbcTemplate(ds);</li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li>update():执行DML语句。增、删、改语句</li><li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul><li>注意：这个方法查询的结果集长度只能是1</li></ul></li><li>queryForList():查询结果将结果集封装为list集合<ul><li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li></ul></li><li>query():查询结果，将结果封装为JavaBean对象<ul><li>query的参数：RowMapper<ul><li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li><li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li></ul></li></ul></li><li>queryForObject：查询结果，将结果封装为对象<ul><li>一般用于聚合函数的查询</li></ul></li></ul></li></ol><pre><code class="java">import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;                        import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;                        public class JdbcTemplateDemo2 &#123;                            //Junit单元测试，可以让方法独立执行                                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1()&#123;                                //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                &#125;                            /**                 * 2. 添加一条记录                 */                @Test                public void test2()&#123;                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                            &#125;                            /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3()&#123;                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                &#125;                            /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4()&#123;                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;                            &#125;                            /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                                for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;                        System.out.println(stringObjectMap);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;                                    @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                                        emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                                        return emp;                        &#125;                    &#125;);                                        for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6_2()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 7. 查询总记录数                 */                            @Test                public void test7()&#123;                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                &#125;                        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="2022/03/20/Java-01/"/>
      <url>2022/03/20/Java-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p></blockquote><p>接口中可添加静态方法与默认方法；</p><p>一个类实现一个接口的同时必须实现该接口的所有方法（可以不用实现默认方法即关键词为为 default的方法）；</p><p><strong>extends</strong> 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p><h1 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h1><p><img src="http://img.lbkzw.cn/img/20200821084956.jpeg"></p><blockquote><p>把方法抽象封装到接口或抽象类中，在别的类中对其进行实现即，变得是内容，而其框架则始终如一。</p><p>就像我与大厨炒西红柿：大家都是加油、加鸡蛋、加西红柿。只是做出来时味道不同罢了。</p></blockquote><h1 id="接口与抽象类（选择）"><a href="#接口与抽象类（选择）" class="headerlink" title="接口与抽象类（选择）"></a>接口与抽象类（选择）</h1><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>组合</td><td>新类可以组合多个接口</td><td>只能继承单一抽象类</td></tr><tr><td>状态</td><td>不能包含属性（除了静态属性，不支持对象状态）</td><td>可以包含属性，非抽象方法可能引用这些属性</td></tr><tr><td>默认方法 和 抽象方法</td><td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td><td>必须在子类中实现抽象方法</td></tr><tr><td>构造器</td><td>没有构造器</td><td>可以有构造器</td></tr><tr><td>可见性</td><td>隐式 <strong>public</strong></td><td>可以是 <strong>protected</strong> 或友元</td></tr></tbody></table><h1 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h1><ul><li>创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。</li></ul><pre><code class="java">import java.util.*;class Processor &#123;    /*父类*/    public String name() &#123;        return getClass().getSimpleName();    &#125;        public Object process(Object input) &#123;        return input;    &#125;&#125;/*子类开始，将所有传入类设置为同一个类的子类*/class Upcase extends Processor &#123;    // 返回协变类型    @Override     public String process(Object input) &#123;        return ((String) input).toUpperCase();    &#125;&#125;class Downcase extends Processor &#123;    @Override    public String process(Object input) &#123;        return ((String) input).toLowerCase();    &#125;&#125;class Splitter extends Processor &#123;    @Override    public String process(Object input) &#123;        // split() divides a String into pieces:        return Arrays.toString(((String) input).split(&quot; &quot;));    &#125;&#125;/*策略开始*/public class Applicator &#123;    public static void apply(Processor p, Object s) &#123;        //(Processor p。已知：所有传入类设置为同一个类的子类，故其父类的变量可以作为引用        System.out.println(&quot;Using Processor &quot; + p.name());//获取其类名        System.out.println(p.process(s));//根据其类名调用其覆盖的相应的process方法    &#125;        public static void main(String[] args) &#123;        String s = &quot;We are such stuff as dreams are made on&quot;;        //进入策略，以下3类均为Processor子类，故可用Processor p分别引用以下3个不同类型的对象        apply(new Upcase(), s);        apply(new Downcase(), s);        apply(new Splitter(), s);    &#125;&#125;</code></pre><h1 id="常量字段"><a href="#常量字段" class="headerlink" title="常量字段"></a>常量字段</h1><blockquote><p>接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong></p></blockquote><pre><code class="java">public interface Months &#123;    int     JANUARY = 1, FEBRUARY = 2, MARCH = 3,    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,    NOVEMBER = 11, DECEMBER = 12;&#125;</code></pre><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><blockquote><p>所有类都必须是公共可用的，唯独内部类不同。——一枝独秀</p></blockquote><ul><li>内部类的变量必须是最终变量。传入参数默认为fianl</li><li> 创建内部类对象：在拥有外部类对象之前不可创建内部类对象，且必须使用外部类的对象来创建其内部类对象。</li><li>典型手法：外部类中的一个方法返回指向内部类的引用。</li><li>可以让内部类实现一个接口，再借接口变量对创建的内部类对象进行引用。</li><li>当内部类在方法内部时除该方法外，所有类与方法不得访问。</li><li>类只能继承一个父类，实现多个内部类继承类，则等同于实现类的多继承。</li></ul><h2 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h2><blockquote><p>利用内部类实现迭代器功能，对其外类元素（方法、字段）进行访问。</p></blockquote><pre><code class="java">package com.test.day2;public class Sequence &#123;    private Object[] items;    private int next = 0;    public Sequence(int size)&#123;        items = new Object[size];    &#125;    public void add(Object x)&#123;        if(next &lt; items.length)            items[next++] = x;    &#125;    private class SequenceSelector implements Selector&#123;        private  int i = 0;        @Override        public boolean end() &#123;return  i == items.length;&#125;        @Override        public Object current() &#123;return  items[i];&#125;        @Override        public void  next() &#123;if (i &lt; items.length) i++;&#125;//定义一个迭代器，if语句相当于hasNext    &#125;    public Selector selector()&#123;        /*返回指向内部类的引用。*/        return new SequenceSelector();        //当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。        // 然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。    &#125;    public static void main(String[] args) &#123;        Sequence sequence = new Sequence(10);        for (int i = 0; i &lt; 10; i++)            sequence.add(Integer.toString(i));//Integer.toString()表示先讲int转换bai成Integer型，然后再将Integer转换成String型。        Selector selector = sequence.selector();//返回、创建、引用内部类对象操作开始（此处使用接口变量，对内部类对象进行引用）        //Selector selector = sequence.new SequenceSelector();//外部类方法返回内部类引用、创建内部类对象        //var selector = sequence.new SequenceSelector();//简写引用、创建内部类对象       // Sequence.SequenceSelector selector = sequence.new SequenceSelector();//使用外部类.内部类引用、创建内部类对象        while (!selector.end())&#123;            System.out.println(selector.current() + &quot; &quot;);            selector.next();        &#125;    &#125;&#125;</code></pre><p>这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p><h2 id="this、new"><a href="#this、new" class="headerlink" title="this、new"></a>this、new</h2><pre><code class="java">public class DotThis &#123;    void f() &#123; System.out.println(&quot;DotThis.f()&quot;); &#125;      public class Inner &#123;        public DotThis outer() &#123;            return DotThis.this;//创建对外部类对象的引用        &#125;    &#125;      public Inner inner() &#123; return new Inner(); &#125;      public static void main(String[] args) &#123;        DotThis dt = new DotThis();//在拥有外部类对象之前不可创建内部类对象。        DotThis.Inner dti = dt.inner();//必须使用外部类的对象来创建其内部类对象        dti.outer().f();    &#125;&#125;public class DotNew &#123;    public class Inner &#123;&#125;    public static void main(String[] args) &#123;        DotNew dn = new DotNew();        DotNew.Inner dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象       // var dni = dn.new Inner();//声明一个内部类变量并引用一个内部类对象    &#125;&#125;</code></pre><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <strong>final</strong> 的</li></ul><blockquote><p>匿名内部类的初始化（借助抽象类）</p></blockquote><pre><code class="java">package com.test.day2;abstract class Base &#123;//抽象类的构造器    Base(int i) &#123;        System.out.println(&quot;Base constructor, i = &quot; + i);    &#125;    public abstract void f();&#125;public class AnonymousConstructor &#123;    public static Base getBase(int i) &#123;        return new Base(i) &#123;//利用抽象类构造器进行字段初始化。            &#123; System.out.println(                    &quot;Inside instance initializer&quot;); &#125;            @Override            public void f() &#123;                System.out.println(&quot;In anonymous f()&quot;);            &#125;        &#125;;    &#125;    public static void main(String[] args) &#123;        Base base = getBase(47);        base.f();    &#125;&#125;</code></pre><h2 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h2><blockquote><p>普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p></blockquote><ul><li><p>要创建嵌套类的对象，并不需要先创建其外部类的对象，即直接创建并引用即可。</p></li><li><p>不能从嵌套类的对象中访问非静态的外围类对象。</p></li></ul><pre><code class="java">public class Parcel11 &#123;    private static class ParcelContents implements Contents &#123;        private int i = 11;        @Override        public int value() &#123; return i; &#125;    &#125;    protected static final class ParcelDestination            implements Destination &#123;        private String label;        private ParcelDestination(String whereTo) &#123;            label = whereTo;        &#125;        @Override        public String readLabel() &#123; return label; &#125;        // Nested classes can contain other static elements:        public static void f() &#123;&#125;        static int x = 10;        static class AnotherLevel &#123;            public static void f() &#123;&#125;            static int x = 10;        &#125;    &#125;    public static Destination destination(String s) &#123;        return new ParcelDestination(s);    &#125;    public static Contents contents() &#123;        return new ParcelContents();    &#125;    public static void main(String[] args) &#123;        Contents c = contents();        //并没有创建外部类的对象，再用外部类对象创建内部类。        //var i = new Parcel11()        //var c = i.contents()        Destination d = destination(&quot;Tasmania&quot;);    &#125;&#125;</code></pre><pre><code class="java">/**一个接口内部的类（接口内方法、字段默认为final static）*/public interface ClassInInterface &#123;    void howdy();    class Test implements ClassInInterface &#123;        @Override        public void howdy() &#123;            System.out.println(&quot;Howdy!&quot;);        &#125;        public static void main(String[] args) &#123;            new Test().howdy();        &#125;    &#125;&#125;</code></pre><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><blockquote><p>内部类无法被覆盖，但可通过继承覆盖其方法</p></blockquote><pre><code class="java">class WithInner &#123;    class Inner &#123;        public Yolk() &#123;            System.out.println(&quot;Egg.Yolk()&quot;);        &#125;    &#125;&#125;public class InheritInner extends WithInner.Inner &#123;//继承须以（外部类.内部）类形式。    InheritInner(WithInner wi) &#123;        wi.super();        @Override        public Yolk() &#123;            System.out.println(&quot;BigEgg2.Yolk()&quot;);    &#125;    public static void main(String[] args) &#123;        WithInner wi = new WithInner();        InheritInner ii = new InheritInner(wi);    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code class="java">package cn.day.a5;// files/PathInfo.javaimport java.nio.file.*;import java.net.URI;import java.io.File;import java.io.IOException;public class PathInfo &#123;    static void show(String id, Object p) &#123;        System.out.println(id + &quot;: &quot; + p);    &#125;    static void info(Path p) &#123;        show(&quot;toString&quot;, p);        show(&quot;Exists&quot;, Files.exists(p));//测试文件是否存在        show(&quot;RegularFile&quot;, Files.isRegularFile(p));        show(&quot;Directory&quot;, Files.isDirectory(p));//测试文件是否是一个目录。        show(&quot;Absolute&quot;, p.isAbsolute());//判断此路径是否为绝对路径        show(&quot;FileName&quot;, p.getFileName());//返回文件名        show(&quot;Parent&quot;, p.getParent());//返回此文件的父路径，无返回null        show(&quot;Root&quot;, p.getRoot());//返回此文件的根路径，无返回null        System.out.println(&quot;******************&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(System.getProperty(&quot;os.name&quot;));        info(Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;));//转化路径（此方法将来可能被弃用）        Path p = Paths.get(&quot;PathInfo.java&quot;);        info(p);        Path ap = p.toAbsolutePath();//获取这个文件的绝对路径        info(ap);        info(ap.getParent());        try &#123;/*传入p引用 文件的父路径，调用info进行处理*/            info(p.toRealPath());        &#125; catch(IOException e) &#123;            System.out.println(e);        &#125;        URI u = p.toUri();//返回一个URI来表示该路径        System.out.println(&quot;URI: &quot; + u);        Path puri = Paths.get(u);//给定的URI转换为Path对象。        System.out.println(Files.exists(puri));        File f = ap.toFile();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2022/03/20/Java-02/"/>
      <url>2022/03/20/Java-02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。</p><p>基本的集合： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> </p></blockquote><ul><li>集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li><li><strong>Set</strong> （元组）不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li><li><strong>Map</strong> （字典）是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li></ul><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><pre><code class="java">import java.util.*;class Apple &#123;  private static long counter;  private final long id = counter++;  public long id() &#123; return id; &#125;&#125;class Orange &#123;&#125;public class ApplesAndOrangesWithoutGenerics &#123;  @SuppressWarnings(&quot;unchecked&quot;)  public static void main(String[] args) &#123;    ArrayList apples = new ArrayList();    for(int i = 0; i &lt; 3; i++)      apples.add(new Apple());    /*ArrayList 保存的是 Object ，所以不仅可以通过 ArrayList 的 add() 方法将 Apple 对象放入这个集合，而且可以放入 Orange 对象。*/    apples.add(new Orange());    for(Object apple : apples) &#123;      ((Apple) apple).id();        /*当使用 ArrayList 的 get() 方法来取出你认为是 Apple 的对象时，得到的只是 Object 引用，必须将其转型为 Apple。然后需要将整个表达式用括号括起来，以便在调用 Apple 的 id() 方法之前，强制执行转型。*/    &#125;  &#125;&#125;/**通过泛型,限定&lt;Apple&gt;类型防止其它类型对象添加到容器中*/import java.util.*;class GrannySmith extends Apple &#123;&#125;public class ApplesAndOrangesWithGenerics &#123;  public static void main(String[] args) &#123;    ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();    for(int i = 0; i &lt; 3; i++)      apples.add(new GrannySmith());//向上转型也可以添加到容器哦      apples.add(new Apple());    // Compile-time error:    // apples.add(new Orange());    for(Apple apple : apples) &#123;      System.out.println(apple.id());        //使用泛型，容器知道它被限定为什么类型，因此当调用 get() 时，它会替你执行转型，因此从泛型容器中获取元素不需要强制类型转换。</code></pre><h2 id="添加元数组"><a href="#添加元数组" class="headerlink" title="添加元数组"></a>添加元数组</h2><ul><li><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。</li><li><code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中</li></ul><pre><code class="java">package com.test.day3;import java.util.*;public class AddingGroups &#123;    public static void main(String[] args) &#123;        Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));        Integer[] moreInts = &#123;6,7,8,9,10&#125;;        collection.addAll(Arrays.asList(moreInts));//Collection.addAll() 方法只能接受另一个 Collection 作为参数        /*Collection 可以接受另一个 Collection进行初始化，所以使用 Arrays.asList() 可为这个构造器产生输入。        Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，再调用 Collections.addAll()添加元素 */        Collections.addAll(collection,11,12,13,14,15);        Collections.addAll(collection,moreInts);         /*使用 Arrays.asList() 的输出作为一个 List ，无法调整大小*/        List&lt;Integer&gt; list = Arrays.&lt;Integer&gt;asList(16,17,18,19,20);        //告诉编译器 Arrays.asList() 生成的结果 List 类型的实际目标类型是什么。这称为显式类型参数说明               list.set(1,99);    &#125;&#125;</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接</li><li><strong>Collection</strong> 类型在每个槽中只能保存一个元素。 <strong>Set</strong> 中元素不重复； <strong>Queue</strong> ，只在一端插入对象，并从另一端移除对象； <strong>Map</strong> 在每个槽中存放了两个元素，即<em>键</em>和与之关联的<em>值</em>。</li></ul><pre><code class="java">import java.util.*;public class PrintingCollections &#123;  static Collection  fill(Collection&lt;String&gt; collection) &#123;    collection.add(&quot;rat&quot;);    collection.add(&quot;cat&quot;);    collection.add(&quot;dog&quot;);    collection.add(&quot;dog&quot;);    return collection;  &#125;  static Map fill(Map&lt;String, String&gt; map) &#123;    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);    map.put(&quot;cat&quot;, &quot;Rags&quot;);    map.put(&quot;dog&quot;, &quot;Bosco&quot;);    map.put(&quot;dog&quot;, &quot;Spot&quot;);    return map;  &#125;  public static void main(String[] args) &#123;    System.out.println(fill(new ArrayList&lt;&gt;()));      //ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。    System.out.println(fill(new LinkedList&lt;&gt;()));      //LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。          System.out.println(fill(new HashSet&lt;&gt;()));    System.out.println(fill(new TreeSet&lt;&gt;()));      //如果存储顺序很重要，则可以使用 TreeSet ，它将按比较结果的升序保存对象    System.out.println(fill(new LinkedHashSet&lt;&gt;()));      //LinkedHashSet ，它按照被添加的先后顺序保存对象。          System.out.println(fill(new HashMap&lt;&gt;()));      // 键和值保存在 HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非常快速的算法来控制顺序。    System.out.println(fill(new TreeMap&lt;&gt;()));      // TreeMap 通过比较结果的升序来保存键    System.out.println(fill(new LinkedHashMap&lt;&gt;()));      //LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。  &#125;&#125;/* Output:[rat, cat, dog, dog][rat, cat, dog, dog][rat, cat, dog][cat, dog, rat][rat, cat, dog]&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;*/</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>统一集合的移动、删除</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ol><li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li><li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li></ol><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p> <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><ul><li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>addFirst()</code> 在列表的开头插入一个元素。</li><li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li><li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，设计的很糟糕：如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类。</p><p><strong>Java 6 添加了 **ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法:</p><pre><code class="java">package com.test.day5;import java.util.ArrayDeque;import java.util.Deque;public class Stack&lt;T&gt; &#123;    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();    public void push(T v)&#123;storage.push(v);&#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。    public T peek() &#123;return storage.peek();&#125;    public T pop() &#123;return storage.pop();&#125;    public boolean isEmpty() &#123;return storage.isEmpty();&#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法    @Override    public String toString()&#123;        return storage.toString();    &#125;&#125;</code></pre><p>onjava8中利用泛型实现的栈：</p><pre><code class="java">package com.test.day5;import java.util.ArrayDeque;import java.util.Deque;public class Stack&lt;T&gt; &#123;    private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();    public void push(T v)&#123;storage.push(v);&#125;//将调用ArrayDeque类中addFirst（）方法即将指定元素插入此双端队列的开头。    public T peek() &#123;return storage.peek();&#125;    public T pop() &#123;return storage.pop();&#125;    public boolean isEmpty() &#123;return storage.isEmpty();&#125;//将调用ArrayDeque类中将调用ArrayDeque类中addFirst（）方法    @Override    public String toString()&#123;        return storage.toString();    &#125;&#125;//测试：public class StackTest2 &#123;    public static void main(String[] args) &#123;        Stack&lt;String&gt; stack = new Stack&lt;&gt;();//创建此对象的同时，Stack类也将创建ArrayDeque对象        for (String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))            stack.push(s);        while (!stack.isEmpty())            System.out.println(stack.pop() + &quot; &quot;);    &#125;&#125;</code></pre><h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><ul><li><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。  </p></li><li><p><strong>Set</strong> 最常见的用途是测试归属性。</p><p>**迭代器与集合 **</p><pre><code class="java">public class InterfaceVsIterator &#123;  public static void display(Iterator&lt;Pet&gt; it) &#123;    while(it.hasNext()) &#123;      Pet p = it.next();      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);//返回越过的值    &#125;    System.out.println();  &#125;  public static void display(Collection&lt;Pet&gt; pets) &#123;    for(Pet p : pets)      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    System.out.println();  &#125;    /*两个版本的 display() 方法都可以使用 Map 或 Collection 的子类型来工作。 而且Collection 接口和 Iterator 都将 display() 方法与低层集合的特定实现解耦。     Collection 要更方便一点，因为它是 Iterable 类型，因此在 display(Collection) 的实现中可以使用 for-in 构造，这使得代码更加清晰*/  public static void main(String[] args) &#123;    List&lt;Pet&gt; petList = Pets.list(8);    Set&lt;Pet&gt; petSet = new HashSet&lt;&gt;(petList);    Map&lt;String, Pet&gt; petMap = new LinkedHashMap&lt;&gt;();    String[] names = (&quot;Ralph, Eric, Robin, Lacey, &quot; +      &quot;Britney, Sam, Spot, Fluffy&quot;).split(&quot;, &quot;);    for(int i = 0; i &lt; names.length; i++)      petMap.put(names[i], petList.get(i));    display(petList);    display(petSet);    display(petList.iterator());    display(petSet.iterator());    System.out.println(petMap);    System.out.println(petMap.keySet());    display(petMap.values());    display(petMap.values().iterator());  &#125;&#125;</code></pre></li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><code>offer()</code>在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。</li><li><code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 </li><li><code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</li><li>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象</li></ul><pre><code class="java">package com.test.day4;import java.util.LinkedList;import java.util.Queue;import java.util.Random;public class QueueDemo &#123;    public static void printQ(Queue queue)&#123;        /*删除队列中所有元素*/        while (queue.peek()!=null)//peek()查询队列第一个元素            System.out.println(queue.remove()+&quot;&quot;);        System.out.println();    &#125;    public static void main(String[] args) &#123;        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        Random rand = new Random(47);//用来生成随机数        for (int i = 0; i &lt; 10; i++)            queue.offer(rand.nextInt(i+10));//向队列添加元素        printQ(queue);        Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();        for (char c: &quot;Brontosaurus&quot;.toCharArray())//将字符串分为单个字符加入队列中            qc.offer(c);        printQ(qc);    &#125;</code></pre><h3 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h3><ul><li>可以通过提供Comparator 来修改队列元素顺序。 </li><li><strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素</li><li><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</li></ul><pre><code class="java">import java.util.*;/*int string 均有默认的大小顺序*/public class PriorityQueueDemo &#123;  public static void main(String[] args) &#123;    PriorityQueue&lt;Integer&gt; priorityQueue =      new PriorityQueue&lt;&gt;();    Random rand = new Random();    for(int i = 0; i &lt; 10; i++)      priorityQueue.offer(rand.nextInt(i + 10));//将指定的元素插入此优先级队列。    QueueDemo.printQ(priorityQueue);//删除并打印队列所有元素    List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20,      18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);    priorityQueue = new PriorityQueue&lt;&gt;(ints);    QueueDemo.printQ(priorityQueue);    priorityQueue = new PriorityQueue&lt;&gt;(        ints.size(), Collections.reverseOrder());//反序排列    priorityQueue.addAll(ints);    QueueDemo.printQ(priorityQueue);    String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;    List&lt;String&gt; strings =      Arrays.asList(fact.split(&quot;&quot;));//将这个字符串分解为字母（依据空格）填入列表中    PriorityQueue&lt;String&gt; stringPQ =      new PriorityQueue&lt;&gt;(strings);    QueueDemo.printQ(stringPQ);    stringPQ = new PriorityQueue&lt;&gt;(      strings.size(), Collections.reverseOrder());//按原stringPQ大小，创建一个新的队列，反并序排列    stringPQ.addAll(strings);//将strings中的所有元素添加进队列    QueueDemo.printQ(stringPQ);    Set&lt;Character&gt; charSet = new HashSet&lt;&gt;();    for(char c : fact.toCharArray())//toCharArray分割字符。      charSet.add(c);     PriorityQueue&lt;Character&gt; characterPQ =      new PriorityQueue&lt;&gt;(charSet);//创建队列对象并将集合的元素“安排”到队列中    QueueDemo.printQ(characterPQ);  &#125;&#125;/* Output:0 1 1 1 1 1 3 5 8 141 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 2525 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1      A A B C C C D D E E E F H H I I L N N O O O O S SS T T U U U WW U U U T T S S S O O O O N N L I I H H F E E E D D C CC B A A  A B C D E F H I L N O S T U W*/</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code class="java">package com.test.day5;import java.util.HashMap;import java.util.Map;import java.util.Random;public class Statistics &#123;    public static void main(String[] args) &#123;        Random rand = new Random(47);        Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();//创建键值均为int类型的字典对象        for (int i = 0; i &lt; 1000; i++)&#123;            int r = rand.nextInt(20);            Integer freq = m.get(r);//查询有无值r，无则返回null            m.put(r, freq == null ? 1: freq + 1 );//如字典中有这个值，则为其加一        &#125;        System.out.println(m);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="2022/03/20/Java-03/"/>
      <url>2022/03/20/Java-03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>任何 Lambda 表达式的基本语法是：</p><ol><li>参数。</li><li>接着 <code>-&gt;</code>，可视为“产出”。</li><li><code>-&gt;</code> 之后的内容都是方法体。</li></ol></blockquote><p>当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例;</p><p> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见;</p><p>如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表;</p><p>对于多个参数，将参数列表放在括号 <code>()</code> 中;</p><p>表达式的结果自动成为<strong>Lambda 表达式</strong>的返回值，在此处使用 <strong>return</strong> 关键字是非法的。</p><p><strong>递归</strong>方法必须是实例变量或静态变量，否则会出现编译时错误</p><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用组成：类名或对象名 <code>::</code> 方法名</p><pre><code class="java">package com.test.day6;// functional/MethodReferences.javaimport java.util.*;interface Callable &#123; // [1]    void call(String s);&#125;class Describe &#123;    void show(String msg) &#123; // [2]        System.out.println(msg);    &#125;&#125;public class MethodReferences &#123;    static void hello(String name) &#123; // [3]        System.out.println(&quot;Hello, &quot; + name);    &#125;    static class Description &#123;        String about;        Description(String desc) &#123; about = desc; &#125;        void help(String msg) &#123; // [4]            System.out.println(about + &quot; &quot; + msg);        &#125;    &#125;    static class Helper &#123;        static void assist(String msg) &#123; // [5]            System.out.println(msg);        &#125;    &#125;    public static void main(String[] args) &#123;        Describe d = new Describe();        Callable c = d::show;        //将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。        c.call(&quot;call()&quot;); //现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show(),因为其签名均是String。        c = MethodReferences::hello; //这是一个静态方法引用。        c.call(&quot;Bob&quot;);        c = new Description(&quot;valuable&quot;)::help; // 对已实例化对象的方法的引用，称为绑定方法引用。        c.call(&quot;information&quot;);        c = Helper::assist; // 内部类方法引用        c.call(&quot;Help!&quot;);    &#125;&#125;</code></pre><h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p><strong>Runnable</strong> 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 <code>run()</code> 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong>：</p><pre><code class="java">// 方法引用与 Runnable 接口的结合使用class Go &#123;  static void go() &#123;    System.out.println(&quot;Go::go()&quot;);  &#125;&#125;public class RunnableMethodReference &#123;  public static void main(String[] args) &#123;    new Thread(new Runnable() &#123;//内部类方法      public void run() &#123;        System.out.println(&quot;Anonymous&quot;);      &#125;    &#125;).start();    new Thread(      () -&gt; System.out.println(&quot;lambda&quot;)//lambda表达式    ).start();    new Thread(Go::go).start();//方法引用  &#125;&#125;</code></pre><h2 id="未绑定的方法引用"><a href="#未绑定的方法引用" class="headerlink" title="未绑定的方法引用"></a>未绑定的方法引用</h2><blockquote><p>在目标类没有对象的时候对其采用方法引用，即为未绑定方法引用（静态类除外）</p><p>可使用目标类类型的方法参数解决未绑定方法引用问题</p></blockquote><pre><code class="java">package com.test.day6;// functional/UnboundMethodReference.java// 没有方法引用的对象class X &#123;    String f() &#123; return &quot;X::f()&quot;; &#125;&#125;interface MakeString &#123;    String make();&#125;interface TransformX &#123;    String transform(X x);&#125;public class UnboundMethodReference &#123;    public static void main(String[] args) &#123;        // MakeString ms = X::f; // 不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。        TransformX sp = X::f;//TransformX下的String transform(X x)方法接受一个X类的参数，所以可与完成对象绑定并成功调用方法。        X x = new X();        System.out.println(sp.transform(x)); // [2]        System.out.println(x.f()); // 同等效果    &#125;&#125;package com.test.day6;// functional/MultiUnbound.java// 未绑定的方法与多参数的结合运用class This &#123;    void two(int i, double d) &#123;&#125;    void three(int i, double d, String s) &#123;&#125;    void four(int i, double d, String s, char c) &#123;&#125;&#125;/*接口方法中加入对象类型参数 达到绑定对象目的*/interface TwoArgs &#123;    void call2(This athis, int i, double d);//参数This athis达到绑定对象目的&#125;interface ThreeArgs &#123;    void call3(This athis, int i, double d, String s);&#125;interface FourArgs &#123;    void call4(            This athis, int i, double d, String s, char c);&#125;public class MultiUnbound &#123;    public static void main(String[] args) &#123;        TwoArgs twoargs = This::two;        ThreeArgs threeargs = This::three;        FourArgs fourargs = This::four;        This athis = new This();        twoargs.call2(athis, 11, 3.14);//相当于woargs.call2(this.athis, 11, 3.14),成功绑定对象并传入参数调用方法        threeargs.call3(athis, 11, 3.14, &quot;Three&quot;);        fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, &#39;Z&#39;);    &#125;&#125;</code></pre><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><pre><code class="java">package com.test.day6;// functional/CtorReference.javaclass Dog &#123;    String name;    int age = -1; // For &quot;unknown&quot;    Dog() &#123; name = &quot;stray&quot;; &#125;    Dog(String nm) &#123; name = nm; &#125;    Dog(String nm, int yrs) &#123; name = nm; age = yrs; &#125;&#125;interface MakeNoArgs &#123;    Dog make();&#125;interface Make1Arg &#123;    Dog make(String nm);&#125;interface Make2Args &#123;    Dog make(String nm, int age);&#125;public class CtorReference &#123;    public static void main(String[] args) &#123;        /*[1][2][3]分别引用不同签名的构造器*/        MakeNoArgs mna = Dog::new; // [1]根据MakeNoArgs接口中方法的签名引用相符的构造器        Make1Arg m1a = Dog::new;   // [2]根据Make1Arg接口中方法的签名引用相符的构造器        Make2Args m2a = Dog::new;  // [3]根据MakeNoArgsMake2Args接口中方法的签名引用相符的构造器                Dog dn = mna.make();//相当于调用引用Dog类的构造器        Dog d1 = m1a.make(&quot;Comet&quot;);        Dog d2 = m2a.make(&quot;Ralph&quot;, 4);    &#125;&#125;</code></pre><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><blockquote><p>只包含一个抽象方法的接口（接口中方法默认为抽象的）</p><p>如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会自动包装方法引用或 Lambda 表达式到实现目标接口的类的实例中。</p></blockquote><pre><code class="java">// functional/FunctionalAnnotation.java@FunctionalInterface//@FunctionalInterface 的作用：接口中如果有多个方法则会产生编译期错误interface Functional &#123;  String goodbye(String arg);&#125;interface FunctionalNoAnn &#123;  String goodbye(String arg);&#125;public class FunctionalAnnotation &#123;  public String goodbye(String arg) &#123;    return &quot;Goodbye, &quot; + arg;  &#125;  public static void main(String[] args) &#123;    FunctionalAnnotation fa =      new FunctionalAnnotation();    Functional f = fa::goodbye;    FunctionalNoAnn fna = fa::goodbye;    // Functional fac = fa; // Incompatible    Functional fl = a -&gt; &quot;Goodbye, &quot; + a;    FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a;  &#125;&#125;</code></pre><p><code>java.util.function</code> 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。</p><p> 以下是基本命名准则：</p><ol><li>如果只处理对象而非基本类型，名称则为 <code>Function</code>，<code>Consumer</code>，<code>Predicate</code> 等。参数类型通过泛型添加。</li><li>如果接收的参数是基本类型，则由名称的第一部分表示，如 <code>LongConsumer</code>，<code>DoubleFunction</code>，<code>IntPredicate</code> 等，但基本 <code>Supplier</code> 类型例外。</li><li>如果返回值为基本类型，则用 <code>To</code> 表示，如 <code>ToLongFunction &lt;T&gt;</code> 和 <code>IntToLongFunction</code>。</li><li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 <code>UnaryOperator</code>，两个参数使用 <code>BinaryOperator</code>。</li><li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li><li>如果接收的两个参数类型不同，则名称中有一个 <code>Bi</code>。</li></ol><p>下表描述了 <code>java.util.function</code> 中的目标类型（包括例外情况）：</p><table><thead><tr><th><strong>特征</strong></th><th><strong>函数式方法名</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>无参数；   无返回值</td><td><strong>Runnable</strong>   (java.lang)     <code>run()</code></td><td><strong>Runnable</strong></td></tr><tr><td>无参数；   返回类型任意</td><td><strong>Supplier</strong>   <code>get()</code>   <code>getAs类型()</code></td><td><strong>Supplier<code>&lt;T&gt;</code>    BooleanSupplier    IntSupplier    LongSupplier    DoubleSupplier</strong></td></tr><tr><td>无参数；   返回类型任意</td><td><strong>Callable</strong>   (java.util.concurrent)    <code>call()</code></td><td><strong>Callable<code>&lt;V&gt;</code></strong></td></tr><tr><td>1 参数；   无返回值</td><td><strong>Consumer</strong>   <code>accept()</code></td><td><strong><code>Consumer&lt;T&gt;</code>   IntConsumer   LongConsumer   DoubleConsumer</strong></td></tr><tr><td>2 参数 <strong>Consumer</strong></td><td><strong>BiConsumer</strong>   <code>accept()</code></td><td><strong><code>BiConsumer&lt;T,U&gt;</code></strong></td></tr><tr><td>2 参数 <strong>Consumer</strong>；   1 引用；   1 基本类型</td><td><strong>Obj类型Consumer</strong>   <code>accept()</code></td><td><strong><code>ObjIntConsumer&lt;T&gt;</code>   <code>ObjLongConsumer&lt;T&gt;</code>   <code>ObjDoubleConsumer&lt;T&gt;</code></strong></td></tr><tr><td>1 参数；   返回类型不同</td><td><strong>Function</strong>   <code>apply()</code>   <strong>To类型</strong> 和 <strong>类型To类型</strong>   <code>applyAs类型()</code></td><td><strong>Function<code>&lt;T,R&gt;</code>   IntFunction<code>&lt;R&gt;</code>   <code>LongFunction&lt;R&gt;</code>   DoubleFunction<code>&lt;R&gt;</code>   ToIntFunction<code>&lt;T&gt;</code>   <code>ToLongFunction&lt;T&gt;</code>   <code>ToDoubleFunction&lt;T&gt;</code>   IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td></tr><tr><td>1 参数；   返回类型相同</td><td><strong>UnaryOperator</strong>   <code>apply()</code></td><td><strong><code>UnaryOperator&lt;T&gt;</code>   IntUnaryOperator   LongUnaryOperator   DoubleUnaryOperator</strong></td></tr><tr><td>2 参数类型相同；   返回类型相同</td><td><strong>BinaryOperator</strong>   <code>apply()</code></td><td><strong><code>BinaryOperator&lt;T&gt;</code>   IntBinaryOperator   LongBinaryOperator   DoubleBinaryOperator</strong></td></tr><tr><td>2 参数类型相同;   返回整型</td><td>Comparator   (java.util)   <code>compare()</code></td><td><strong><code>Comparator&lt;T&gt;</code></strong></td></tr><tr><td>2 参数；   返回布尔型</td><td><strong>Predicate</strong>   <code>test()</code></td><td><strong><code>Predicate&lt;T&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   IntPredicate   LongPredicate   DoublePredicate</strong></td></tr><tr><td>参数基本类型；   返回基本类型</td><td><strong>类型To类型Function</strong>   <code>applyAs类型()</code></td><td><strong>IntToLongFunction   IntToDoubleFunction   LongToIntFunction   LongToDoubleFunction   DoubleToIntFunction   DoubleToLongFunction</strong></td></tr><tr><td>2 参数类型不同</td><td><strong>Bi操作</strong>   (不同方法名)</td><td><strong><code>BiFunction&lt;T,U,R&gt;</code>   <code>BiConsumer&lt;T,U&gt;</code>   <code>BiPredicate&lt;T,U&gt;</code>   <code>ToIntBiFunction&lt;T,U&gt;</code>   <code>ToLongBiFunction&lt;T,U&gt;</code>   <code>ToDoubleBiFunction&lt;T&gt;</code></strong></td></tr></tbody></table><p>此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流的创建与基础操作</title>
      <link href="2022/03/20/Java-04/"/>
      <url>2022/03/20/Java-04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说;</p><p>利用流，我们无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道;</p><p>流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体;</p></blockquote><p>流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）;</p><p>在接口中添加被 <code>default</code>（<code>默认</code>）修饰的方法，即可将流式（<em>stream</em>）方法平滑地嵌入到现有类中。</p><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h4 id="ints"><a href="#ints" class="headerlink" title=".ints( )"></a>.ints( )</h4><ul><li>生成整数流，可设定边界</li><li>如设定边界为ints（5，20）则生成5（包括）-20（不包括）之间的数</li></ul><h4 id="limit"><a href="#limit" class="headerlink" title=".limit()"></a>.limit()</h4><ul><li>截断并获取流中元素</li><li>如填入7，则获取前7个元素</li></ul><pre><code class="java">// streams/Randoms.javaimport java.util.*;public class Randoms &#123;    public static void main(String[] args) &#123;        new Random(47)            .ints(5, 20)//生成整数流，设定边界如5-20（不包括20）            .distinct()//收集不重复的            .limit(7)//截断，获取7个元素            .sorted()//排序            .forEach(System.out::println);    &#125;&#125;</code></pre><h1 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h1><h2 id="Stream-of"><a href="#Stream-of" class="headerlink" title="Stream.of()"></a>Stream.of()</h2><p>将一组元素转化成为流</p><h2 id="stream"><a href="#stream" class="headerlink" title="stream()"></a>stream()</h2><p>集合可通过调用此方法产生一个流</p><h2 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet()"></a>entrySet()</h2><ul><li>产生一个对象流，每个对象都包含一个 <code>key</code> 键以及与其相关联的 <code>value</code> 值。 </li><li>可使用getKey()和getValue() 获取对象流的键值</li></ul><pre><code class="java">// streams/CollectionToStream.javaimport java.util.*;import java.util.stream.*;public class CollectionToStream &#123;    public static void main(String[] args) &#123;        List&lt;Bubble&gt; bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));        System.out.println(bubbles.stream()            .mapToInt(b -&gt; b.i)            .sum());        Set&lt;String&gt; w = new HashSet&lt;&gt;(Arrays.asList(&quot;It&#39;s a wonderful day for pie!&quot;.split(&quot; &quot;)));        w.stream()         .map(x -&gt; x + &quot; &quot;)         .forEach(System.out::print);        System.out.println();        Map&lt;String, Double&gt; m = new HashMap&lt;&gt;();        m.put(&quot;pi&quot;, 3.14159);        m.put(&quot;e&quot;, 2.718);        m.put(&quot;phi&quot;, 1.618);        m.entrySet().stream()//entrySet() 产生一个对象流，每个对象都包含一个 `key` 键以及与其相关联的 `value` 值。 。                    .map(e -&gt; e.getKey() + &quot;: &quot; + e.getValue())//getKey()和getValue() 获取键值            //中间操作 `map()` 会获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。                    .forEach(System.out::println);    &#125;&#125;</code></pre><h2 id="boxed"><a href="#boxed" class="headerlink" title="boxed()"></a>boxed()</h2><ul><li>把基本类型包装成为对应的装箱类型</li></ul><pre><code class="java">public class RandomGenerators &#123;    public static &lt;T&gt; void show(Stream&lt;T&gt; stream) &#123;        stream        .limit(4)        .forEach(System.out::println);    &#125;    public static void main(String[] args) &#123;        Random rand = new Random(47);        show(rand.ints().boxed());//boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 show() 能够接受流        show(rand.longs().boxed());    &#125;&#125;</code></pre><h2 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h2><p>收集操作，它根据参数来组合所有流中的元素。</p><h2 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining()"></a>Collectors.joining()</h2><p>每个元素都根据 <code>joining()</code> 的参数来进行分割。</p><p>得到一个 <code>String</code> 类型的结果</p><h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate()"></a>Stream.generate()</h2><ul><li>把任意  <code>Supplier&lt;T&gt;</code> 用于生成 <code>T</code> 类型的流。</li></ul><pre><code class="java">// streams/RandomWords.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;import java.io.*;import java.nio.file.*;public class RandomWords implements Supplier&lt;String&gt; &#123;    List&lt;String&gt; words = new ArrayList&lt;&gt;();    Random rand = new Random(47);    RandomWords(String fname) throws IOException &#123;        List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname));        // 略过第一行        for (String line : lines.subList(1, lines.size())) &#123;            for (String word : line.split(&quot;[ .?,]+&quot;))                words.add(word.toLowerCase());        &#125;    &#125;    public String get() &#123;        return words.get(rand.nextInt(words.size()));    &#125;    @Override    public String toString() &#123;        return words.stream()            .collect(Collectors.joining(&quot; &quot;));    &#125;    public static void main(String[] args) throws Exception &#123;        System.out.println(            Stream.generate(new RandomWords(&quot;Cheese.dat&quot;))                .limit(10)                .collect(Collectors.joining(&quot; &quot;)));//以空格分隔流元素并收集    &#125;&#125;</code></pre><pre><code class="java">package com.test.day15;// streams/Generator.javaimport java.util.*;import java.util.function.*;import java.util.stream.*;public class Generator implements Supplier&lt;String&gt; &#123;    Random rand = new Random(47);    char[] letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();    public String get() &#123;        return &quot;&quot; + letters[rand.nextInt(letters.length)];    &#125;    public static void main(String[] args) &#123;        String word = Stream.generate(new Generator())                ////Stream.generate() 的用法，它可以把任意 Supplier&lt;T&gt; 用于生成 T 类型的流。                .limit(30)//获取前30个                .collect(Collectors.joining(&quot; &quot;));//collect() 收集操作，它根据参数来组合所有流中的元素。        //使用 Collectors.joining()，你将会得到一个 String 类型的结果，        // 每个元素都根据 joining() 的参数来进行分割。        System.out.println(word);    &#125;&#125;</code></pre><h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h2><p>将元素装入数组</p><h2 id="Arrays的stream"><a href="#Arrays的stream" class="headerlink" title="Arrays的stream()"></a>Arrays的stream()</h2><p>把数组转换成为流;</p><p>（）中可加入两个额外的参数。第一个参数告诉 <code>stream()</code> 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止。</p><h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate()"></a>Stream.iterate()</h2><p>以种子（第一个参数）开头，并将其传给方法（第二个参数）；</p><p>方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code>。</p><h2 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h2><ul><li>根据参数丢弃指定数量的流元素。</li></ul><pre><code class="java">package com.test.day15;// streams/Fibonacci.javaimport java.util.stream.*;public class Fibonacci &#123;    int x = 1;    Stream&lt;Integer&gt; numbers() &#123;        return Stream.iterate(0, i -&gt; &#123;//terate() 以种子（第一个参数）开头，并将其传给方法（第二个参数）。            // iterate() 只能记忆结果，因此我们需要利用一个变量 x 追踪另外一个元素。            int result = x + i;            x = i;            return result;//返回值赋予i        &#125;);    &#125;    public static void main(String[] args) &#123;        new Fibonacci().numbers()                .skip(20) // 过滤前 20 个                .limit(10) // 然后取 10 个                .forEach(System.out::println);    &#125;&#125;</code></pre><h1 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h1><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。</p><h2 id="mapToInt-ToIntFunction"><a href="#mapToInt-ToIntFunction" class="headerlink" title="mapToInt(ToIntFunction)"></a>mapToInt(ToIntFunction)</h2><p>操作同上，但结果是 <strong>IntStream</strong>;</p><p>mapToLong(ToLongFunction)</p><p>操作同上，但结果是 <strong>LongStream</strong>;</p><p>mapToDouble(ToDoubleFunction)</p><p>操作同上，但结果是 <strong>DoubleStream</strong>。</p><pre><code class="java">package com.test.day15;// streams/FunctionMap.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;class FunctionMap &#123;    static String[] elements = &#123; &quot;12&quot;, &quot;&quot;, &quot;23&quot;, &quot;45&quot; &#125;;    static Stream&lt;String&gt;    testStream() &#123;        return Arrays.stream(elements);//把数组转换成为流并返回    &#125;    static void test(String descr, Function&lt;String, String&gt; func) &#123;        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);        testStream()                .map(func)//将函数操作应用在输入流的元素中，并将返回值传递到输出流中。                .forEach(System.out::println);    &#125;    public static void main(String[] args) &#123;        test(&quot;add brackets&quot;, s -&gt; &quot;[&quot; + s + &quot;]&quot;);        test(&quot;Increment&quot;, s -&gt; &#123;                    try &#123;//                        return s + 1;//错误的拼接了，流中一切元素为字符                        return Integer.parseInt(s) + 1 + &quot;&quot;;//将字符串参数作为有符号的十进制整数进行解析并还原为字符串                    &#125;                    catch(NumberFormatException e) &#123;                        return s;                    &#125;                &#125;        );        test(&quot;Replace&quot;, s -&gt; s.replace(&quot;2&quot;, &quot;9&quot;));        //返回一个新的字符串，将所有字符”2“替换成”9“        test(&quot;Take last digit&quot;, s -&gt; s.length() &gt; 0 ?                s.charAt(s.length() - 1) + &quot;&quot; : s);//charAt返回指定索引处的 char 值。    &#125;&#125;</code></pre><h2 id="流中元素基本类型的转换"><a href="#流中元素基本类型的转换" class="headerlink" title="流中元素基本类型的转换"></a>流中元素基本类型的转换</h2><pre><code class="java">package com.test.day15;// streams/FunctionMap3.java// Producing numeric output streams（ 产生数值输出流）import java.util.*;import java.util.stream.*;class FunctionMap3 &#123;    public static void main(String[] args) &#123;        Stream.of(&quot;5&quot;, &quot;7&quot;, &quot;9&quot;)                .mapToInt(Integer::parseInt)//int类型                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));        System.out.println();        Stream.of(&quot;17&quot;, &quot;19&quot;, &quot;23&quot;)                .mapToLong(Long::parseLong)//long类型                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));        System.out.println();        Stream.of(&quot;17&quot;, &quot;1.9&quot;, &quot;.23&quot;)                .mapToDouble(Double::parseDouble)//double类型                .forEach(n -&gt; System.out.format(&quot;%f &quot;, n));    &#125;&#125;</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><ul><li><p>获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中（与 <code>map()</code> 所做的相同）</p></li><li><p>每个结果都是一个流，将其扁平化为单个元素并拼接到一起</p></li><li><p>可用来组合流中的方法（实现方式是将元素扁平化再实现流）例：</p></li></ul><pre><code class="java">Stream&lt;String&gt; a = words.stream().flatMap(w -&gt; codePoints(w));</code></pre><ul><li><p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p></li><li><p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p></li><li><p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p></li><li><p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p></li></ul><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul><li>以参数顺序组合两个流。 </li></ul><pre><code class="java">package com.test.day15;import java.util.Random;import java.util.stream.IntStream;import java.util.stream.Stream;/*一个整数流开始，然后使用每一个整数去创建更多的随机数。*/public class StreamOfRandoms &#123;    static Random rand = new Random(47);    //一个种子为47的随机数生成，多个相同种子的随机生成实例，生成的结果一致    public static void main(String[] args) &#123;        Stream.of(1,2,3,4,5)        .flatMapToInt(i -&gt; IntStream.concat(            //concat()，以参数顺序组合两个流，我们在每个随机 `Integer` 流的末尾添加一个 -1 作为标记                rand.ints(0,100).limit(i)//根据i的值返回i个元素                ,                //生成随机数，仅返回0（包含）-100（不包含）之间的数                IntStream.of(-1)//生成一个整数流包含-1                )).forEach(n -&gt; System.out.format(&quot;%d\n&quot;,n));    &#125;&#125;</code></pre><h3 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h3><p>帮助调试。可无修改地查看流中的元素。</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>收集流中不重复的元素</p><h3 id="空流-Stream-empty"><a href="#空流-Stream-empty" class="headerlink" title="空流 Stream.empty()"></a>空流 Stream.empty()</h3><ul><li><p>如果你在没有任何上下文环境的情况下调用 Stream.empty()，Java 并不知道它的数据类型；</p></li><li><p>解决这个问题:1、2均可</p><pre><code class="java">1. Stream.&lt;String&gt;empty()//限定类型为String    2.    Stream&lt;String&gt; s = Stream.empty();</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optional类</title>
      <link href="2022/03/20/Java-05/"/>
      <url>2022/03/20/Java-05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用于，查看的流中元素返回提示而不是发生异常。</p></blockquote><p><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong>;</p><p><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty;</strong></p><p><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong>;</p><p><code>reduce()</code> 不再以 <code>identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code>identity</code> 对象成为其他形式的 <code>reduce()</code> 的默认结果，因此不存在空结果的风险）;</p><p>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code>average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</p><h1 id="解包-Optional"><a href="#解包-Optional" class="headerlink" title="解包 Optional"></a>解包 <strong>Optional</strong></h1><ul><li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li><li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>（括号中可定义）。</li><li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li><li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li></ul><h1 id="创建-Optional"><a href="#创建-Optional" class="headerlink" title="创建 Optional"></a>创建 Optional</h1><ul><li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li><li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li><li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li></ul><pre><code class="java">package com.test.day15;import java.util.*;import java.util.stream.*;import java.util.function.*;class CreatingOptionals &#123;    static void test(String testName, Optional&lt;String&gt; opt) &#123;        System.out.println(&quot; === &quot; + testName + &quot; === &quot;);        System.out.println(opt.orElse(&quot;Null&quot;));//定义若不存在值则生成otherObject为null，并打印；若有值返回并打印值。    &#125;    public static void main(String[] args) &#123;        test(&quot;empty&quot;, Optional.empty());////empty()：生成一个空 Optional。        test(&quot;of&quot;, Optional.of(&quot;Howdy&quot;));//of(value)：将一个非空值包装到 Optional 里。        try &#123;            test(&quot;of&quot;, Optional.of(null));        &#125; catch(Exception e) &#123;            System.out.println(e);        &#125;        test(&quot;ofNullable&quot;, Optional.ofNullable(&quot;Hi&quot;));        //ofNullable(value)：针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中        test(&quot;ofNullable&quot;, Optional.ofNullable(null));    &#125;&#125;</code></pre><h1 id="Optional-对象操作"><a href="#Optional-对象操作" class="headerlink" title="Optional 对象操作"></a>Optional 对象操作</h1><ul><li><p><code>filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。而流的 <code>filter()</code> 则会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。</p></li><li><p><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong>  于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。（与中间操作map类似）</p></li><li><p><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。（与中间操作flatmap类似）<code>Optional.flatMap()</code> 是为那些自己已经生成 <strong>Optional</strong> 的函数而设计的。可用来组合流中的方法（实现方式是将元素扁平化再实现流）例：</p><pre><code class="java">Optional&lt;Double&gt; a=Optional.of(-4.0).flatMap(Demo:invers).flatMap(Demo:squareRoot)</code></pre></li></ul><p>以上方法都不适用于数值型 <strong>Optional</strong>。</p><pre><code class="java">// streams/OptionalFilter.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;class OptionalFilter &#123;    static String[] elements = &#123;            &quot;Foo&quot;, &quot;&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Bingo&quot;    &#125;;    static Stream&lt;String&gt; testStream() &#123;        return Arrays.stream(elements);    &#125;    static void test(String descr, Predicate&lt;String&gt; pred) &#123;        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);        for(int i = 0; i &lt;= elements.length; i++) &#123;/            System.out.println(                    testStream()                            .skip(i)                            .findFirst()                            .filter(pred));        &#125;    &#125;    public static void main(String[] args) &#123;        test(&quot;true&quot;, str -&gt; true);//返回所有元素包括空        test(&quot;false&quot;, str -&gt; false);//返回空（Optional.empty）        test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);        test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);        test(&quot;startsWith(\&quot;B\&quot;)&quot;,                str -&gt; str.startsWith(&quot;B&quot;));    &#125;&#125;</code></pre><h1 id="Optional-流"><a href="#Optional-流" class="headerlink" title="Optional 流"></a>Optional 流</h1><pre><code class="java">package com.test.day16;// streams/Signal.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;public class Signal &#123;    private final String msg;    public Signal(String msg) &#123; this.msg = msg; &#125;    public String getMsg() &#123; return msg; &#125;    @Override    public String toString() &#123;        return &quot;Signal(&quot; + msg + &quot;)&quot;;    &#125;    static Random rand = new Random(47);//随机数    public static Signal morse() &#123;        switch(rand.nextInt(4)) &#123;//nextInt(4)，返回0-4之间的数            case 1: return new Signal(&quot;dot&quot;);            case 2: return new Signal(&quot;dash&quot;);            default: return null;        &#125;    &#125;    public static Stream&lt;Optional&lt;Signal&gt;&gt; stream() &#123;        return Stream.generate(Signal::morse)//通过所提供的产生的每个元件的无限连续的无序流Supplier                .map(signal -&gt; Optional.ofNullable(signal));//为空返回Optional.empty，不为空将值包包装在 Optional 中。    &#125;&#125;package com.test.day16;// streams/StreamOfOptionals.javaimport java.util.*;import java.util.stream.*;public class StreamOfOptionals &#123;    public static void main(String[] args) &#123;        Signal.stream()                .limit(10)                .forEach(System.out::println);        System.out.println(&quot; ---&quot;);        Signal.stream()                .limit(10)                .filter(Optional::isPresent)//返回非空的元素，isPresent值存在返回true否返回flase                .map(Optional::get)//从Optional中提取元素                .forEach(System.out::println);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端操作(收集)</title>
      <link href="2022/03/20/Java-06/"/>
      <url>2022/03/20/Java-06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下操作将会获取流的最终结果。至此我们无法再继续往后传递流。</p><p>终端操作（Terminal Operations）总是我们在流管道中所做的最后一件事。</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li><code>toArray()</code>：将流转换成适当类型的数组。</li><li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组。</li></ul><pre><code class="java">// streams/RandInts.javapackage streams;import java.util.*;import java.util.stream.*;public class RandInts &#123;    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();    public static IntStream rands() &#123;        return Arrays.stream(rints);    &#125;&#125;</code></pre><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><ul><li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li><li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。]</li><li><code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。</li></ul><pre><code class="java">package com.test.day16;// streams/ForEach.javaimport java.util.*;import java.util.stream.*;public class ForEach &#123;    static final int SZ = 14;    public static void main(String[] args) &#123;        RandInts.rands().limit(SZ)//截取14个                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));        System.out.println();        RandInts.rands().limit(SZ)                .parallel()                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));         /*在第一个流中，未使用 parallel() ，所以 rands() 按照元素迭代出现的顺序显示结果；        在第二个流中，引入parallel() ，即便流很小，输出的结果顺序也和前面不一样。这是由于多处理器并行操作的原因。        多次运行测试，结果均不同。多处理器并行操作带来的非确定性因素造成了这样的结果。*/        System.out.println();        RandInts.rands().limit(SZ)                .parallel()//parallel()：实现多处理器并行操作。                // 实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。                .forEachOrdered(n -&gt; System.out.format(&quot;%d &quot;, n));//强制保持原始流顺序    &#125;&#125;package com.test.day16;// streams/RandInts.javaimport java.util.*;import java.util.stream.*;public class RandInts &#123;    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();    public static IntStream rands() &#123;        return Arrays.stream(rints);//返回此数组流    &#125;&#125;</code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul><li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li><li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</li><li><strong>Collectors</strong> 里面没有特定的 <code>toTreeSet()</code>，但是我们可以通过将集合的构造函数引用传递给 <code>Collectors.toCollection()</code>，从而构建任何类型的集合。<strong>如下</strong>：</li></ul><pre><code class="java">// streams/TreeSetOfWords.javaimport java.util.*;import java.nio.file.*;import java.util.stream.*;public class TreeSetOfWords &#123;    public static void    main(String[] args) throws Exception &#123;        Set&lt;String&gt; words2 =                Files.lines(Paths.get(&quot;TreeSetOfWords.java&quot;))//Paths.get读取全文，Files.lines打开 Path 并将其转换成为行流。                        .flatMap(s -&gt; Arrays.stream(s.split(&quot;\\W+&quot;)))// Arrays.stream() 将其转化成为流；并将结果展平映射成为单词流。                        .filter(s -&gt; !s.matches(&quot;\\d+&quot;)) // No numbersmatches(\\d+) 查找并移除全数字字符串                        .map(String::trim)//String.trim() 去除单词两边的空白，                        .filter(s -&gt; s.length() &gt; 2) filter() //过滤所有长度小于3的单词，，最后将                        .limit(100)//获取100个单词                        .collect(Collectors.toCollection(TreeSet::new));        System.out.println(words2);//将元素收集至Tree集合构造器    &#125;&#125;//1.将数据收集进一个列表(Stream 转换为 List，允许重复值，有顺序)//创建流Stream&lt;String&gt; language = Stream.of(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);List&lt;String&gt; listResult = language.collect(Collectors.toList());result.forEach(System.out::println);//2.将数据收集进一个集合(Stream 转换为 Set，不允许重复值，没有顺序)Stream&lt;String&gt; language = Stream.of(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);Set&lt;String&gt; setResult = language.collect(Collectors.toSet());setResult.forEach(System.out::println);      List&lt;String&gt; list = Arrays.asList(&quot;java&quot;, &quot;python&quot;, &quot;C++&quot;,&quot;php&quot;,&quot;java&quot;);        </code></pre><h2 id="自定义收集"><a href="#自定义收集" class="headerlink" title="自定义收集"></a>自定义收集</h2><pre><code class="java">//用LinkedList收集      List&lt;String&gt; linkedListResult = list.stream().collect(Collectors.toCollection(LinkedList::new));      linkedListResult.forEach(System.out::println);      System.out.println(&quot;--------------&quot;);            //用CopyOnWriteArrayList收集      List&lt;String&gt; copyOnWriteArrayListResult = list.stream().collect(Collectors.toCollection(CopyOnWriteArrayList::new));      copyOnWriteArrayListResult.forEach(System.out::println);      System.out.println(&quot;--------------&quot;);            //用TreeSet收集      TreeSet&lt;String&gt; treeSetResult = list.stream().collect(Collectors.toCollection(TreeSet::new));      treeSetResult.forEach(System.out::println);</code></pre><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><ul><li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li><li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li><li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li></ul><pre><code class="java">package com.test.day16;// streams/Reduce.javaimport java.util.*;import java.util.stream.*;class Frobnitz &#123;    int size;    Frobnitz(int sz) &#123; size = sz; &#125;    @Override    public String toString() &#123;        return &quot;Frobnitz(&quot; + size + &quot;)&quot;;    &#125;    // Generator:    static Random rand = new Random(47);    static final int BOUND = 100;    static Frobnitz supply() &#123;/*个方法对于 Supplier&lt;Frobnitz&gt; 是签名兼容的，    我们可以将其方法引用传递给 Stream.generate()（这种签名兼容性被称作结构一致性）*/        return new Frobnitz(rand.nextInt(BOUND));//随机返回0-100之间的数    &#125;&#125;public class Reduce &#123;    public static void main(String[] args) &#123;        Stream.generate(Frobnitz::supply)//Stream.iterate和Stream.generate。这两个操作可以创建无限流：不像从固定集合创建的流那样有固定大小的流。                .limit(10)                .peek(System.out::println)//peek接收的参数类型为Consumer，而map接收的参数类型为Function        //println 方法可以被调用是因为 Frobnitz 可以通过 toString() 方法转换成 String                .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)/*reduce() 中的 Lambda 表达式使用了三元表达式来获取结果，                当其长度小于 50 的时候获取 fr0 否则获取序列中的下一个值 fr1。当取得第一个长度小于 50 的 Frobnitz，只要得到结果就会忽略其他。*/                .ifPresent(System.out::println);    &#125;&#125;</code></pre><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>count()</code>：流中的元素个数;</p><p><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素;</p><p><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</p><h2 id="数字流信息"><a href="#数字流信息" class="headerlink" title="数字流信息"></a>数字流信息</h2><p><code>average()</code> ：求取流元素平均值;</p><p><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>;</p><p><code>sum()</code>：对所有流元素进行求和;</p><p><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul><li><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li><li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li></ul><pre><code class="java">package com.test.day16;// streams/SelectElement.javaimport java.util.*;import java.util.stream.*;public class SelectElement &#123;    public static void main(String[] args) &#123;        System.out.println(RandInts.rands().findFirst().getAsInt());//获取随机流中生成的头一个元素，并返回        System.out.println(                RandInts.rands().parallel().findFirst().getAsInt());        System.out.println(RandInts.rands().findAny().getAsInt());//对于非并行流，findAny()会选择流中的第一个元素（即使从定义上来看是选择任意元素）。        System.out.println(                RandInts.rands().parallel().findAny().getAsInt());//parallel()并行化，findAny选择并行化后的第一个元素    &#125;&#125;</code></pre><h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><ul><li><code>allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。</li><li><code>anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。</li><li><code>noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li></ul><pre><code class="java">package com.test.day16;// streams/Matching.java// Demonstrates short-circuiting of *Match() operationsimport java.util.stream.*;import java.util.function.*;interface Matcher extends BiPredicate&lt;Stream&lt;Integer&gt;, Predicate&lt;Integer&gt;&gt; &#123;&#125;public class Matching &#123;    static void show(Matcher match, int val) &#123;        System.out.println(                match.test(                        IntStream.rangeClosed(1, 9)//生成1-9                                .boxed()//将流元素装入包装器Integer                                .peek(n -&gt; System.out.format(&quot;%d &quot;, n)),//返回由该流的元素，作为元素从所得流消耗的每个元件上附加地执行所述提供动作的流。                        n -&gt; n &lt; val));//执行peek中操作    &#125;/*    allMatch(Predicate) ：返回flase时停止计算           anyMatch(Predicate)：在获得true时停止执行，如结尾仍未获得true。返回flase    noneMatch(Predicate)：如果流的每个元素根据提供的 Predicate 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。*/    public static void main(String[] args) &#123;        show(Stream::allMatch, 10);        show(Stream::allMatch, 4);//第5个值5，大于4，故停止计算（短路时直接结束此操作）        show(Stream::anyMatch, 3);//在获得true时停止执行        show(Stream::anyMatch, 0);        show(Stream::noneMatch, 5);//在第一个 true 时停止执行计算，故返回flase        show(Stream::noneMatch, 0);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2022/03/20/Java-07/"/>
      <url>2022/03/20/Java-07/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.lbkzw.cn/img/20200821102446.png" alt="img"></p><ul><li><p>RuntimeException(运行时异常)会自动被 java 虚拟机抛出，所以不必在异常说明中把它们列出来,也不需要在异常说明中声明方法将抛出 RuntimeException 类型的异常</p></li><li><p>RuntimeException 也被称为“不受检查异常”，将被自动捕获,如果 没有被捕获而直达 main()，那么在程序退出前将调用异常的 printStackTrace() 方法。(返回栈轨迹信息)</p></li><li><p>要么<strong>声明</strong>异常要么<strong>处理</strong>异常(只有在你知道如何处理的情况下才捕获异常)。</p><pre><code class="java">package cn.day.a2;// exceptions/LostMessage.java// How an exception can be lostclass VeryImportantException extends Exception &#123;    @Override    public String toString() &#123;        return &quot;A very important exception!&quot;;    &#125;&#125;class HoHumException extends Exception &#123;    @Override    public String toString() &#123;        return &quot;A trivial exception&quot;;    &#125;&#125;public class LostMessage &#123;    void f() throws VeryImportantException &#123;        throw new VeryImportantException();    &#125;    void dispose() throws HoHumException &#123;        throw new HoHumException();    &#125;    /*声明异常，而不做处理（交给调用的人处理）*/    public static void main(String[] args) throws VeryImportantException &#123;//仅仅声明异常            LostMessage lm = new LostMessage();                lm.f();            &#125;    &#125;    /*捕获并处理异常*///    public static void main(String[] args)  &#123;//        try &#123;//            LostMessage lm = new LostMessage();//            try &#123;//                lm.f();//            &#125; finally &#123;//                lm.dispose();//            &#125;//        &#125; catch(VeryImportantException | HoHumException e) &#123;//            System.out.println(e);//        &#125;//        //    &#125;////&#125;</code></pre></li><li><p>可以通过<strong>继承</strong>异常基类来<strong>自定义异常</strong></p><pre><code class="java">class SimpleException extends Exception &#123;&#125;public class InheritingExceptions &#123;    public void f() throws SimpleException &#123;        System.out.println(                &quot;Throw SimpleException from f()&quot;);        throw new SimpleException();    &#125;    public static void main(String[] args) &#123;        InheritingExceptions sed =                new InheritingExceptions();        try &#123;            sed.f();        &#125; catch(SimpleException e) &#123;            System.out.println(&quot;Caught it!&quot;);        &#125;    &#125;&#125;</code></pre></li></ul><h1 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h1><h2 id="声明多个异常"><a href="#声明多个异常" class="headerlink" title="声明多个异常"></a>声明多个异常</h2><pre><code class="java">void f() throws TooBig, TooSmall, DivZero &#123; // 方法体...&#125;</code></pre><h2 id="声明所有异常"><a href="#声明所有异常" class="headerlink" title="声明所有异常"></a>声明所有异常</h2><pre><code class="java">catch(Exception e) &#123;    System.out.println(&quot;Caught an exception&quot;);&#125;</code></pre><h2 id="声明子异常捕获父异常"><a href="#声明子异常捕获父异常" class="headerlink" title="声明子异常捕获父异常"></a>声明子异常捕获父异常</h2><blockquote><p>java7之后就可以通过编译了</p></blockquote><pre><code class="java">class BaseException extends Exception &#123;&#125;class DerivedException extends BaseException &#123;&#125;public class PreciseRethrow &#123;    void catcher() throws DerivedException &#123;//声明子异常        try &#123;            throw new DerivedException();        &#125; catch(BaseException e) &#123;//捕获父异常            throw e;        &#125;    &#125;&#125;</code></pre><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><h2 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h2><pre><code class="java">// exceptions/SameHandler.javaclass EBase1 extends Exception &#123;&#125;class Except1 extends EBase1 &#123;&#125;class EBase2 extends Exception &#123;&#125;class Except2 extends EBase2 &#123;&#125;class EBase3 extends Exception &#123;&#125;class Except3 extends EBase3 &#123;&#125;class EBase4 extends Exception &#123;&#125;class Except4 extends EBase4 &#123;&#125;public class SameHandler &#123;    void x() throws Except1, Except2, Except3, Except4 &#123;&#125;    void process() &#123;&#125;    void f() &#123;        try &#123;            x();            /*以下是分别捕获并处理异常*/        &#125; catch(Except1 e) &#123;            process();        &#125; catch(Except2 e) &#123;            process();        &#125; catch(Except3 e) &#123;            process();        &#125; catch(Except4 e) &#123;            process();        &#125;    &#125;&#125;</code></pre><h3 id="多重捕获"><a href="#多重捕获" class="headerlink" title="多重捕获"></a>多重捕获</h3><ul><li>java7之后即使不同类型的异常也可通过**|**来连接捕获，进行异常处理</li></ul><pre><code>// exceptions/MultiCatch.javapublic class MultiCatch &#123;    void x() throws Except1, Except2, Except3, Except4 &#123;&#125;    void process() &#123;&#125;    void f() &#123;        try &#123;            x();        &#125; catch(Except1 | Except2 | Except3 | Except4 e) &#123;            process();        &#125;    &#125;&#125;</code></pre><h2 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h2><ul><li>重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略。此外，异常对象的所有信息都得以保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。</li></ul><pre><code class="java">catch(Exception e) &#123;    System.out.println(&quot;An exception was thrown&quot;);    throw e;&#125;</code></pre><ul><li>当再次抛出异常时,printStackTrace() 方法显示的将是原来异常抛出点调用栈的信息，而并非重新抛出点的信息。可以调用 filInStackTrace() 方法更新异常抛出点调用栈的信息（这将返回一个 Throwable 对象）。</li></ul><pre><code class="java">package cn.day.a1;public class Rethrowing &#123;    public static void f() throws Exception &#123;        System.out.println(                &quot;originating the exception in f()&quot;);        throw new Exception(&quot;thrown from f()&quot;);    &#125;    public static void g() throws Exception &#123;        try &#123;            f();        &#125; catch(Exception e) &#123;            System.out.println(                    &quot;Inside g(), e.printStackTrace()&quot;);            e.printStackTrace(System.out);            throw e;//再次抛出后没有更新        &#125;    &#125;    public static void h() throws Exception &#123;        try &#123;            f();        &#125; catch(Exception e) &#123;            System.out.println(                    &quot;Inside h(), e.printStackTrace()&quot;);            e.printStackTrace(System.out);            throw (Exception)e.fillInStackTrace();//抛出并更新        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            g();//抛出点的调用栈信息一致        &#125; catch(Exception e) &#123;            System.out.println(&quot;main: printStackTrace()&quot;);            e.printStackTrace(System.out);                    &#125;        try &#123;            h();//抛出点的调用栈信息是更新前后的        &#125; catch(Exception e) &#123;            System.out.println(&quot;main: printStackTrace()&quot;);            e.printStackTrace(System.out);        &#125;    &#125;&#125;</code></pre><ul><li>在捕获异常之后抛出另一种异常,效果类似于使用 filInStackTrace()，有关原异常抛出点调用栈会丢失</li></ul><pre><code class="java">// exceptions/RethrowNew.java// Rethrow a different object from the one you caughtclass OneException extends Exception &#123;    OneException(String s) &#123; super(s); &#125;&#125;class TwoException extends Exception &#123;    TwoException(String s) &#123; super(s); &#125;&#125;public class RethrowNew &#123;    public static void f() throws OneException &#123;        System.out.println(                &quot;originating the exception in f()&quot;);        throw new OneException(&quot;thrown from f()&quot;);    &#125;    public static void main(String[] args) &#123;        try &#123;            try &#123;                f();            &#125; catch(OneException e) &#123;                System.out.println(                        &quot;Caught in inner try, e.printStackTrace()&quot;);                e.printStackTrace(System.out);                throw new TwoException(&quot;from inner try&quot;);//抛出不同异常            &#125;        &#125; catch(TwoException e) &#123;            System.out.println(                    &quot;Caught in outer try, e.printStackTrace()&quot;);            e.printStackTrace(System.out);//此异常仅知道自己来自 main()，而对 f() 一无所知。        &#125;    &#125;&#125;</code></pre><h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><p>捕获一个异常并抛出另一个异常，同时想保持已捕获异常的信息。</p><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><ul><li><p>异常有无发生，均执行的操作（抛出异常时紧跟异常处理语句后执行）</p><pre><code class="java">// exceptions/MultipleReturns.javapublic class MultipleReturns &#123;    public static void f(int i) &#123;        System.out.println(                &quot;Initialization that requires cleanup&quot;);        try &#123;            System.out.println(&quot;Point 1&quot;);            if(i == 1) return;//返回，中断下面操作，但finally语句仍会执行。            System.out.println(&quot;Point 2&quot;);            if(i == 2) return;            System.out.println(&quot;Point 3&quot;);            if(i == 3) return;            System.out.println(&quot;End&quot;);            return;        &#125; finally &#123;            System.out.println(&quot;Performing cleanup&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        for(int i = 1; i &lt;= 4; i++)            f(i);    &#125;&#125;</code></pre></li><li><p>在任何finally语句中使用return，发生(抛出)的异常将静默。</p><pre><code class="javascript">public class ExceptionSilencer &#123;    public static void main(String[] args) &#123;        try &#123;            throw new RuntimeException();        &#125; finally &#123;            // Using &#39;return&#39; inside the finally block            // will silence any thrown exception.            return;        &#125;    &#125;&#125;</code></pre></li><li><p>try中与finally中发生同时（抛出）异常，try中的异常将不被显示(设计缺陷)</p><pre><code class="java">package cn.day.a2;// exceptions/LostMessage.java// How an exception can be lostclass VeryImportantException extends Exception &#123;    @Override    public String toString() &#123;        return &quot;A very important exception!&quot;;    &#125;&#125;class HoHumException extends Exception &#123;    @Override    public String toString() &#123;        return &quot;A trivial exception&quot;;    &#125;&#125;public class LostMessage &#123;    void f() throws VeryImportantException &#123;        throw new VeryImportantException();    &#125;    void dispose() throws HoHumException &#123;        throw new HoHumException();    &#125;    public static void main(String[] args) &#123;        try &#123;            LostMessage lm = new LostMessage();            try &#123;                lm.f();//由于finally也抛出异常，故此异常不被显示            &#125; finally &#123;                lm.dispose();            &#125;        &#125; catch(VeryImportantException | HoHumException e) &#123;            System.out.println(e);        &#125;    &#125;&#125;</code></pre></li></ul><h1 id="异常限制"><a href="#异常限制" class="headerlink" title="异常限制"></a>异常限制</h1><ul><li>一个类可不声明其超类或实现接口中的异常</li><li>一个类不能声明与其超类中声明的异常无直接继承关系的异常</li><li>异常限制对构造器不起作用。</li></ul><pre><code class="java">package cn.day.a2;/**重写的方法只能抛出在其基类版本中指定的异常，或从基类异常派生的异常**//*定义异常*/class BaseballException extends Exception &#123;&#125;class Foul extends BaseballException &#123;&#125;class Strike extends BaseballException &#123;&#125;/*声明异常*/abstract class Inning &#123;    Inning() throws BaseballException &#123;&#125;    public void event() throws BaseballException &#123;    &#125;    public abstract void atBat() throws Strike, Foul;    public void walk() &#123;&#125; &#125;/*定义异常*/class StormException extends Exception &#123;&#125;class RainedOut extends StormException &#123;&#125;class PopFoul extends Foul &#123;&#125;/*一个接口中声明两个异常*/interface Storm &#123;    void event() throws RainedOut;    void rainHard() throws RainedOut;&#125;/*继承上面含有声明异常的类并实现含有声明异常的接口*/public class StormyInning extends Inning implements Storm &#123;       public StormyInning()            throws RainedOut, BaseballException &#123;&#125;//声明这个构造器可能发生的异常（来自接口与父类）    public StormyInning(String s)  throws BaseballException &#123;&#125;    @Override    public void rainHard() throws RainedOut &#123;&#125;//声明了实现的接口异常    @Override    public void event() &#123;&#125;    // 没有声明异常哦    @Override    public void atBat() throws PopFoul &#123;&#125;//覆盖方法可以声明继承了其超类所声明的异常的子异常//    public void atBat() throws RainedOut &#123;&#125;//其接口有，但其超类未声明此异常，故不可这样做//    public void atBat() throws BaseballException &#123;&#125;覆盖方法不能声明其超类中未声明且与其超类中声明的异常无直接继承关系的异常    public static void main(String[] args) &#123;        try &#123;            StormyInning si = new StormyInning();            si.atBat();        &#125; catch(PopFoul e) &#123;            System.out.println(&quot;Pop foul&quot;);        &#125; catch(RainedOut e) &#123;            System.out.println(&quot;Rained out&quot;);        &#125; catch(BaseballException e) &#123;            System.out.println(&quot;Generic baseball exception&quot;);        &#125;        try &#123;            Inning i = new StormyInning();            i.atBat();        &#125; catch(Strike e) &#123;            System.out.println(&quot;Strike&quot;);        &#125; catch(Foul e) &#123;            System.out.println(&quot;Foul&quot;);        &#125; catch(RainedOut e) &#123;            System.out.println(&quot;Rained out&quot;);        &#125; catch(BaseballException e) &#123;            System.out.println(&quot;Generic baseball exception&quot;);        &#125;    &#125;&#125;</code></pre><h1 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h1><ul><li><p>异常处理，采用“就近原则”：异常子类可作为捕获参数用于捕获其父类类型的异常。</p><pre><code class="java">// exceptions/Human.java// Catching exception hierarchiesclass Annoyance extends Exception &#123;&#125;class Sneeze extends Annoyance &#123;&#125;public class Human &#123;    public static void main(String[] args) &#123;        // Catch the exact type:        try &#123;            throw new Sneeze();        &#125; catch(Sneeze s) &#123;            System.out.println(&quot;Caught Sneeze&quot;);        &#125; catch(Annoyance a) &#123;            System.out.println(&quot;Caught Annoyance&quot;);        &#125;                try &#123;            throw new Sneeze();        &#125; catch(Annoyance a) &#123;//可捕获Annoyance父类Sneeze的异常            System.out.println(&quot;Caught Annoyance&quot;);        &#125;         catch(Sneeze a) &#123;//将永远无法捕获并处理异常，所以会报错。            System.out.println(&quot;Caught Annoyance&quot;);        &#125;    &#125;&#125;</code></pre></li></ul><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><ul><li>确保有无异常时打开的文件在结束之后均关闭</li></ul><pre><code class="java">static String readFirstLineFromFile(String path) throws IOException &#123;      try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;//即使发生异常（）内的资源也会关闭        return br.readLine();      &#125;    &#125;/*try finally*/static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException &#123;      BufferedReader br = new BufferedReader(new FileReader(path));      try &#123;        return br.readLine();      &#125; finally &#123;        if (br != null) br.close();//如果close出现异常，则文件无法正常关闭      &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="2022/03/20/Java-08/"/>
      <url>2022/03/20/Java-08/</url>
      
        <content type="html"><![CDATA[<p>泛型是编译时泛型，用于检查类型安全以及类型推断，虚拟机运行时已经被擦除；</p><p>泛型的类型参数T在编译后为Object类型；</p><p>泛型方法能使方法独立于类而产生变化。</p><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><pre><code class="java">/**泛型类*///此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123;     //key这个成员变量的类型为T由实例化时指定      private T key;    public Generic(T value) &#123; //只有方法所在类声明了T泛型类，那么成员方法才可接收一个T类型的参数        this.key = value;    &#125;    public T getKey()&#123; //这只是类中一个普通的成员方法，只不过其返回值是同泛型类T一样的类型        //如为public F getKey()，将发生异常        return key;    &#125;&#125;</code></pre><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><pre><code class="JAVA">/**泛型接口*///我们可以为接口传入无数个实参，形成无数种类型的Generator接口。//定义一个泛型接口public interface Generator&lt;T&gt; &#123;    public T next();&#125; //类实现泛型接口时，需将泛型的声明也一起加到类中 //即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; //如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;。class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;    @Override    public T next() &#123;        return null;    &#125;&#125;</code></pre><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><pre><code class="java">/**泛型方法*///在泛型类中声明了一个泛型方法，使用泛型E，E可以为任意类型，可与方法所在类的类型相同，也可以不同。//如下：这是一个泛型T的类，它有一个泛型E的泛型方法，这个泛型方法接收并返回一个E类型的参数（类型由实例决定）public class Test1 &lt;T&gt; &#123;    public &lt;E&gt; E function1(E a)&#123; return  a;&#125;&#125; //    1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 //    2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,  IllegalAccessException&#123;        T instance = tClass.newInstance();        return instance;&#125;/*  public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;       为T的泛型接收一个为E的形参，这将发生异常    &#125;  */</code></pre><h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><p>当操作类型时，不需要使用类型的具体功能而只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><p><strong>？</strong>和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><pre><code class="java">//’？’是类型实参，而不是类型形参 public void showKeyValue1(Generic&lt;?&gt; obj)&#123;    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125;</code></pre><h1 id="要使静态方法接收泛型参数则必须将其写为泛型方法"><a href="#要使静态方法接收泛型参数则必须将其写为泛型方法" class="headerlink" title="要使静态方法接收泛型参数则必须将其写为泛型方法"></a>要使静态方法接收泛型参数则必须将其写为泛型方法</h1><pre><code class="java">public class StaticGenerator&lt;T&gt; &#123;        //如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：      //    &quot;StaticGenerator cannot be refrenced from static context&quot;        public static &lt;T&gt; void show(T t)&#123;    &#125;&#125;</code></pre><h1 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h1><p><strong>泛型的上下边界添加，必须与泛型的声明在一起</strong> </p><pre><code class="java">/*只准传入某种类型的父类或；只准传入某种类型的子类。*/public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125;/**泛型类的边界限定*/public class Generic&lt;T extends Number&gt;&#123;    private T key;    public Generic(T key) &#123;        this.key = key;    &#125;    public T getKey()&#123;        return key;    &#125;&#125;/**泛型方法的边界限定*/public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;    System.out.println(&quot;container key :&quot; + container.getKey());    T test = container.getKey();    return test;&#125;</code></pre><h1 id="限定"><a href="#限定" class="headerlink" title="限定"></a>限定</h1><ol><li>一个类如果没有限定类型，那么虚拟机将会使用Object对其类型进行替换</li><li>如果限定了类型，则将类型替换为限定的类型</li><li>如限定多个类型，则默认替换为第一个限定类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="2022/03/20/Java-09/"/>
      <url>2022/03/20/Java-09/</url>
      
        <content type="html"><![CDATA[<h2 id="流的分类："><a href="#流的分类：" class="headerlink" title="流的分类："></a>流的分类：</h2><p>操作数据单位：字节流、字符流<br>数据的流向：输入流、输出流<br>流的角色：节点流、处理流</p><h2 id="流的体系结构"><a href="#流的体系结构" class="headerlink" title="流的体系结构"></a>流的体系结构</h2><h3 id="整体结构体系"><a href="#整体结构体系" class="headerlink" title="整体结构体系"></a>整体结构体系</h3><img src="http://img.lbkzw.cn/img/20200830171143.png" alt="2020-08-30" style="zoom: 67%;" /><h3 id="主要流"><a href="#主要流" class="headerlink" title="主要流"></a>主要流</h3><table><thead><tr><th><strong>抽象基类</strong></th><th><strong>节点流（或文件流）</strong></th><th><strong>缓冲流（处理流的一种）</strong></th></tr></thead><tbody><tr><td>InputStream</td><td>FileInputStream   (read(byte[] buffer))</td><td>BufferedInputStream (read(byte[] buffer))</td></tr><tr><td>OutputStream</td><td>FileOutputStream  (write(byte[] buffer,0,len)</td><td>BufferedOutputStream (write(byte[] buffer,0,len) / flush()</td></tr><tr><td>Reader</td><td>FileReader (read(char[] cbuf))</td><td>BufferedReader (read(char[] cbuf) / readLine())</td></tr><tr><td>Writer</td><td>FileWriter (write(char[] cbuf,0,len)</td><td>BufferedWriter (write(char[] cbuf,0,len) / flush()</td></tr></tbody></table><h1 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h1><blockquote><p>直接作用于文件</p></blockquote><h2 id="字符流：FileReader与FileWriter"><a href="#字符流：FileReader与FileWriter" class="headerlink" title="字符流：FileReader与FileWriter"></a>字符流：FileReader与FileWriter</h2><pre><code class="java">  @Test    public void testFileReaderFileWriter() &#123;        FileReader fr = null;//为完美关闭流提供条件。        //由下方代码得出：代码执行到finally时，若未创建流且变量fr为非null值，则将引起异常（为创建流而关闭流）        FileWriter fw = null;        try &#123;            //1.创建File类的对象，指明读入和写出的文件            File srcFile = new File(&quot;hello.txt&quot;);            File destFile = new File(&quot;hello2.txt&quot;);            //不能使用字符流来处理图片等字节数据//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);            //2.创建输入流和输出流的对象            fr = new FileReader(srcFile);            fw = new FileWriter(destFile);            //3.数据的读入和写出操作            char[] cbuf = new char[5];            int len;//记录每次读入到cbuf数组中的字符的个数            while((len = fr.read(cbuf)) != -1)&#123;//从流fr中将 cbuf.length 个字节的数据读入一个 char 数组中//直到因到达流末尾而返回 -1时停止循环。                fw.write(cbuf,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.关闭流资源            //方式一：//            try &#123;//                if(fw != null)//                    fw.close();//            &#125; catch (IOException e) &#123;//                e.printStackTrace();//            &#125;finally&#123;//                try &#123;//                    if(fr != null)//                        fr.close();//                &#125; catch (IOException e) &#123;//                    e.printStackTrace();//                &#125;//            &#125;            //方式二：            try &#123;                if(fw != null)//确定创建了流                    fw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fr != null)                    fr.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><h2 id="字节流：FileInputStream与FileOutputStream"><a href="#字节流：FileInputStream与FileOutputStream" class="headerlink" title="字节流：FileInputStream与FileOutputStream"></a>字节流：FileInputStream与FileOutputStream</h2><p>对于文本文件(.txt,.java,.c,.cpp…)，使用字符流处理;</p><p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理。</p><pre><code class="java">@Test                                                                    public void testFileInputStream() &#123;                                          FileInputStream fis = null;                                              try &#123;                                                                        //1. 造文件                                                                 File file = new File(&quot;hello.txt&quot;);                                                                                                                //2.造流                                                                   fis = new FileInputStream(file);                                          /*1、2这样写也可以fis = new FileInputStream(&quot;hello.txt&quot;);会自动包裹*/                                                                       //3.读数据                                                                  byte[] buffer = new byte[5];  //这是个byte数组哦        //由于中文在utf-8编码中占用3个字节（最高占用到6个字节），而每次读入5个字节可能发生乱码        int len;//记录每次读取的字节的个数                                                   while((len = fis.read(buffer)) != -1)&#123;                                                                                                                String str = new String(buffer,0,len); //通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。                                  System.out.print(str);                                                                                                                        &#125;                                                                    &#125; catch (IOException e) &#123;                                                    e.printStackTrace();                                                 &#125; finally &#123;                                                                  if(fis != null)&#123;                                                             //4.关闭资源                                                                 try &#123;                                                                        fis.close();                                                         &#125; catch (IOException e) &#123;                                                    e.printStackTrace();                                                 &#125;                                                                                                                                             &#125;                                                                    &#125;                                                                                                                                             &#125;                                                                        </code></pre><h1 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h1><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>作用于流，在流外再包裹一层流。</p><p>BufferedInputStream会一次性从文件中读取8192个(8Kb),存在缓冲区中,直到缓冲区装满了,才重新从文件中读取下一个8192个字节数组;</p><p>不会直接写到文件,先写到缓冲区中直到缓冲区写满,BufferedOutputStream才会把缓冲区中的数据一次性写到文件里;</p><p><code>flush()</code>刷新缓冲区，可以强制将缓冲区的内容全部写入输出流;close()方法关闭带缓冲流的流时，会自动刷新缓冲区后再关闭流。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><pre><code class="java"> @Test    public void testBufferedReaderBufferedWriter()&#123;        BufferedReader br = null;        BufferedWriter bw = null;        try &#123;            //创建文件和相应的流            br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;)));            bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;)));            //读写操作            //方式一：使用char[]数组//            char[] cbuf = new char[1024];//            int len;//            while((len = br.read(cbuf)) != -1)&#123;//                bw.write(cbuf,0,len);//    //            bw.flush();//            &#125;            //方式二：使用String            String data;            while((data = br.readLine()) != null)&#123;                //方法一：//                bw.write(data + &quot;\n&quot;);//data中不包含换行符                //方法二：                bw.write(data);//data中不包含换行符                bw.newLine();//提供换行的操作            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //关闭资源            if(bw != null)&#123;                try &#123;                    bw.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(br != null)&#123;                try &#123;                    br.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;</code></pre><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h3><pre><code class="java">@Test    public void BufferedStreamTest()&#123;        BufferedInputStream bis = null;        BufferedOutputStream bos = null;        try &#123;            //1.造文件            File srcFile = new File(&quot;爱情与友情.jpg&quot;);            File destFile = new File(&quot;爱情与友情3.jpg&quot;);            //2.造流            //2.1 造节点流            FileInputStream fis = new FileInputStream((srcFile));            FileOutputStream fos = new FileOutputStream(destFile);            //2.2 造缓冲流            bis = new BufferedInputStream(fis);            bos = new BufferedOutputStream(fos);            //3.复制的细节：读取、写入            byte[] buffer = new byte[10];            int len;            while((len = bis.read(buffer)) != -1)&#123;                bos.write(buffer,0,len);//                bos.flush();//刷新缓冲区，可以强制将缓冲区的内容全部写入输出流            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.资源关闭            //要求：先关闭外层的流，再关闭内层的流            if(bos != null)&#123;                try &#123;                    bos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(bis != null)&#123;                try &#123;                    bis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.//        fos.close();//        fis.close();        &#125;    &#125;</code></pre><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>提供字节流与字符流之间的转换</p><pre><code class="java">package com.atguigu.java;import org.junit.Test;import java.io.*;/** * 处理流之二：转换流的使用 * 1.转换流：属于字符流 *   InputStreamReader：将一个字节的输入流转换为字符的输入流 *   OutputStreamWriter：将一个字符的输出流转换为字节的输出流 * * 2. 解码：字节、字节数组  ---&gt;字符数组、字符串 *    编码：字符数组、字符串 ---&gt; 字节、字节数组 * * * 3.字符集 *ASCII：美国标准信息交换码。    用一个字节的7位可以表示。 ISO8859-1：拉丁码表。欧洲码表    用一个字节的8位表示。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 * * * @author shkstart * @create 2019 下午 4:25 */public class InputStreamReaderTest &#123;    /*    此时处理异常的话，仍然应该使用try-catch-finally    InputStreamReader的使用，实现字节的输入流到字符的输入流的转换     */    /*    此时处理异常的话，仍然应该使用try-catch-finally    综合使用InputStreamReader和OutputStreamWriter     */    @Test    public void test1()  &#123;    FileInputStream fis = null;    //在js中我们知道，catch也具有局部作用域，因此照本方法处理异常需要将引用流的变量在全局作用域声明        // （方法中的变量不会默认初始化为null，需要手动处理）    InputStreamReader isr =null;        try &#123;            fis = new FileInputStream(&quot;dbcp.txt&quot;);//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集            //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集            isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//使用系统默认的字符集            char[] cbuf = new char[20];            int len;            while((len = isr.read(cbuf)) != -1)&#123;                String str = new String(cbuf,0,len);                System.out.print(str);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (isr!=null)&#123;                try &#123;                    isr.close();                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    @Test    public void test2()&#123;        InputStreamReader isr = null;        OutputStreamWriter osw = null;        try &#123;            FileInputStream fis = new FileInputStream(new File(&quot;dbcp.txt&quot;));            FileOutputStream fos = new FileOutputStream(new File(&quot;dbcp_gbk.txt&quot;));            isr = new InputStreamReader(fis,&quot;utf-8&quot;);            osw = new OutputStreamWriter(fos,&quot;gbk&quot;);            //2.读写过程            char[] cbuf = new char[20];            int len;            while((len = isr.read(cbuf)) != -1)&#123;                osw.write(cbuf,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //3.关闭资源            if (isr!=null)&#123;                try &#123;                    isr.close();                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;            &#125;            if (isr!=null)&#123;                try &#123;                    osw.close();                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><blockquote><p>将对象序列化为二进制流便于在网络中传输</p></blockquote><p>序列化:用ObjectOutputStream类保存基本类型数据或对象的机制<br>反序列化:用ObjectInputStream类读取基本类型数据或对象的机制</p><p>可序列化的类必须实现以下接口任意一个：</p><ul><li><p>Serializable</p><p>实现Serializable接口的类都有一个表示序列化版本标识符的静态变量:<code>private static final long serialVersionUID;</code><br>serialVersionUID用来进行版本控制;如果类没有显示定义这个静态常量,它的值是Java运行时环境根据类的内部细节自<br>动生成的;若类的实例变量做了修改,serialVersionUID 可能发生变化。</p></li><li><p>Externalizable</p></li></ul><pre><code class="java">import java.io.Serializable;/** * Person需要满足如下的要求，方可序列化 * 1.需要实现接口：Serializable * 2.当前类提供一个全局常量：serialVersionUID * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性 *   也必须是可序列化的。（默认情况下，基本数据类型可序列化） * * * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 * * * @author shkstart * @create 2019 上午 10:38 *//*一个将用以序列化的类*/public class Person implements Serializable&#123;//实现接口：Serializable    public static final long serialVersionUID = 475463534532L;//全局常量：serialVersionUID    private String name;    private int age;    private int id;    private Account acct;    public Person(String name, int age, int id) &#123;        this.name = name;        this.age = age;        this.id = id;    &#125;    public Person(String name, int age, int id, Account acct) &#123;        this.name = name;        this.age = age;        this.id = id;        this.acct = acct;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, id=&quot; + id +                &quot;, acct=&quot; + acct +                &#39;&#125;&#39;;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Person() &#123;    &#125;&#125;class Account implements Serializable&#123;    public static final long serialVersionUID = 4754534532L;    private double balance;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;balance=&quot; + balance +                &#39;&#125;&#39;;    &#125;    public double getBalance() &#123;        return balance;    &#125;    public void setBalance(double balance) &#123;        this.balance = balance;    &#125;    public Account(double balance) &#123;        this.balance = balance;    &#125;&#125;/*序列化操作开始*/@Test    public void testObjectOutputStream()&#123;        ObjectOutputStream oos = null;        try &#123;            //1.            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));            //2.            oos.writeObject(new String(&quot;我爱北京天安门&quot;));            oos.flush();//刷新操作            oos.writeObject(new Person(&quot;王铭&quot;,23));            oos.flush();            oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000)));            oos.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(oos != null)&#123;                //3.                try &#123;                    oos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /*    反序列化：将磁盘文件中的对象还原为内存中的一个java对象    使用ObjectInputStream来实现     */    @Test    public void testObjectInputStream()&#123;        ObjectInputStream ois = null;        try &#123;            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));            Object obj = ois.readObject();            String str = (String) obj;            Person p = (Person) ois.readObject();//注意之前创建的是Person的对象            Person p1 = (Person) ois.readObject();            System.out.println(str);            System.out.println(p);            System.out.println(p1);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(ois != null)&#123;                try &#123;                    ois.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;</code></pre><h1 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h1><blockquote><p>可读可写、可盐可甜</p></blockquote><p><code>public RandomAccessFile(File file, String mode)</code><br><code>public RandomAccessFile(String name, String mode)</code><br>创建 RandomAccessFile 类实例需要指定一个 mode 参数,该参数指定 RandomAccessFile 的访问模式:</p><ol><li>r: 以只读方式打开</li><li>rw:打开以便读取和写入</li><li>rwd:打开以便读取和写入;同步文件内容的更新</li><li>rws:打开以便读取和写入;同步文件内容和元数据的更新</li></ol><p>如果模式为只读r。则不会创建文件,而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 </p><p>如果模式为rw读写，如果文件不存在则会去创建文件。</p><pre><code class="java">   @Test    public void test1() &#123;        RandomAccessFile raf1 = null;        RandomAccessFile raf2 = null;        try &#123;            //1.            raf1 = new RandomAccessFile(&quot;爱情与友情.jpg&quot;,&quot;r&quot;);            raf2 = new RandomAccessFile(new File(&quot;爱情与友情12.jpg&quot;),&quot;rw&quot;);            //2.            byte[] buffer = new byte[1024];            int len;            while((len = raf1.read(buffer)) != -1)&#123;                raf2.write(buffer,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //3.            if(raf1 != null)&#123;                try &#123;                    raf1.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(raf2 != null)&#123;                try &#123;                    raf2.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;/*插入数据*/    @Test    public void test2() throws IOException &#123;        RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);        raf1.seek(3);//将指针调到角标为3的位置        raf1.write(&quot;xyz&quot;.getBytes());//使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组        raf1.close();    &#125;</code></pre><h1 id="字节流实现图片加密解密"><a href="#字节流实现图片加密解密" class="headerlink" title="字节流实现图片加密解密"></a>字节流实现图片加密解密</h1><pre><code class="java">package com.atguigu.exer;import org.junit.Test;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * @author shkstart * @create 2019 下午 4:08 */public class PicTest &#123;    //图片的加密    @Test    public void test1() &#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            fis = new FileInputStream(&quot;爱情与友情.jpg&quot;);            fos = new FileOutputStream(&quot;爱情与友情secret.jpg&quot;);            byte[] buffer = new byte[20];            int len;            while ((len = fis.read(buffer)) != -1) &#123;                //字节数组进行修改                //错误的                //            for(byte b : buffer)&#123;                //                b = (byte) (b ^ 5);                //            &#125;                //正确的                for (int i = 0; i &lt; len; i++) &#123;                    buffer[i] = (byte) (buffer[i] ^ 5);                &#125;                fos.write(buffer, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fis != null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    //图片的解密    @Test    public void test2() &#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            fis = new FileInputStream(&quot;爱情与友情secret.jpg&quot;);            fos = new FileOutputStream(&quot;爱情与友情4.jpg&quot;);            byte[] buffer = new byte[20];            int len;            while ((len = fis.read(buffer)) != -1) &#123;                //字节数组进行修改                //错误的                //            for(byte b : buffer)&#123;                //                b = (byte) (b ^ 5);                //            &#125;                //正确的                for (int i = 0; i &lt; len; i++) &#123;                    buffer[i] = (byte) (buffer[i] ^ 5);                &#125;                fos.write(buffer, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fis != null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="2022/03/20/Java-10/"/>
      <url>2022/03/20/Java-10/</url>
      
        <content type="html"><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><blockquote><p>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。</p></blockquote><p>验证：</p><pre><code class="java">package com.data.test;public class Students implements Cloneable&#123;    //clone()方法是protected修饰的，因此需要实现Cloneable接口才能调用，同时需要覆写clone()方法才能调用。    private int id;    private int age;    private String name;    private Teacher teacher;    public Students(int id, int age, String name, Teacher teacher) &#123;        this.id = id;        this.age = age;        this.name = name;        this.teacher = teacher;    &#125;    public int getId() &#123;        return id;    &#125;    public int getAge() &#123;        return age;    &#125;    public String getName() &#123;        return name;    &#125;    public Teacher getTeacher() &#123;        return teacher;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setTeacher(Teacher teacher) &#123;        this.teacher = teacher;    &#125;    @Override    public String toString() &#123;        return &quot;Students&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, teacher=&quot; + teacher +                &#39;&#125;&#39;;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;            return super.clone();    &#125;&#125;</code></pre><pre><code class="java">package com.data.test;public class Teacher &#123;    private String name;    private String six;    public Teacher(String name, String six) &#123;        this.name = name;        this.six = six;    &#125;    public String getName() &#123;        return name;    &#125;    public String getSix() &#123;        return six;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setSix(String six) &#123;        this.six = six;    &#125;    @Override    public String toString() &#123;        return &quot;Teacher&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, six=&#39;&quot; + six + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><pre><code class="java">package com.data.test;public class TestObject &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        var stu = new Students(01,20,&quot;张三&quot;,new Teacher(&quot;王五&quot;,&quot;男&quot;));        var stuClone =(Students)stu.clone();        /*判断此俩对象地址是否相同*/        if (stu.equals(stuClone))&#123;            System.out.println(&quot;地址相同&quot;);        &#125;else System.out.println(&quot;地址不同&quot;);        /*toString查看数据*/        System.out.println(stuClone);        System.out.println(stu);        /*验证浅拷贝不拷贝对象仅仅拷贝对象引用*/        System.out.println(&quot;----------验证浅拷贝不拷贝对象仅仅拷贝对象引用-----------&quot;);        var aT = stu.getTeacher();        aT.setName(&quot;尼古拉斯&quot;);        System.out.println(stuClone);        System.out.println(stu);        /*验证浅拷贝会复制字段*/        System.out.println(&quot;----------验证浅拷贝会复制字段-----------&quot;);        stu.setId(2);        System.out.println(stu);        System.out.println(stuClone);        /*修改数据*/        System.out.println(&quot;----------通过改变引用的方式进行数据修改(不影响原始对象即被拷贝的对象)-----------&quot;);        stu.setTeacher(new Teacher(&quot;李四&quot;,&quot;女&quot;));        //即使在clone后，stu与stuClone引用的仍是同一个对象，故可以通过改变引用的方式进行数据修改        System.out.println(stuClone);        System.out.println(stu);    &#125;&#125;</code></pre><p>运行结果：</p><img src="http://img.lbkzw.cn/img/20200927111340.png" alt="image-20200927111340317" style="zoom:50%;" /><h1 id="对象的toString"><a href="#对象的toString" class="headerlink" title="对象的toString"></a>对象的toString</h1><p>未覆盖toString：</p><blockquote><p>打印的是该对象的地址</p></blockquote><img src="http://img.lbkzw.cn/img/20200927103720.png" alt="image-20200927103720635" style="zoom:50%;" /><p>覆盖toString：</p><pre><code class="java">@Override    public String toString() &#123;        return &quot;Students&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, teacher=&quot; + teacher +                &#39;&#125;&#39;;//teacher是一个对象的引用    &#125;</code></pre><img src="http://img.lbkzw.cn/img/20200927103948.png" alt="image-20200927103948710" style="zoom:50%;" /><p>由于未覆盖teacher引用对象的toString，故打印出其引用对象的地址。</p><p>覆盖teacher引用对象的toString</p><pre><code class="java">@Override    public String toString() &#123;        return &quot;Teacher&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, six=&#39;&quot; + six + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;</code></pre><p>运行结果：</p><img src="http://img.lbkzw.cn/img/20200927104304.png" alt="image-20200927104304776" style="zoom:50%;" /><h1 id="深度拷贝"><a href="#深度拷贝" class="headerlink" title="深度拷贝"></a>深度拷贝</h1><ol><li>为类重写原始类与克隆类的clone方法，实现其自我克隆：<br>这个缺点是：如果克隆类中也引用了一个对象则又需要对这个对象的类实现Cloneable接口并覆盖其clone方法，接着再克隆这个对象，周而复始，无往不利。</li></ol><pre><code class="java">/*Students类的clone*/@Override    protected Object clone() throws CloneNotSupportedException &#123;            var cloneStudents = (Students)super.clone();            cloneStudents.teacher = (Teacher)teacher.clone();            //对新克隆的Students对象中的元素即teacher引用的对象进行克隆。            return cloneStudents;    &#125;/*Teacher类的clone*/@Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;    </code></pre><ol start="2"><li>利用序列化：</li></ol><p>一个用来序列化的类</p><pre><code class="java">package com.data.test;import java.io.*;public class Copy implements Serializable &#123;    private static final long serialVersionUID = 1L;    protected &lt;T&gt;T copy() throws IOException, ClassNotFoundException &#123;        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bos);        oos.writeObject(this);        /*反序列化*/        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bis);        return (T) ois.readObject();    &#125;&#125;</code></pre><p>原始类与克隆类继承copy类（用于序列化操作）</p><pre><code class="java">public class Students extends Copy&#123;...&#125;public class Teacher extends Copy&#123;...&#125;</code></pre><pre><code class="java">package com.data.test;import java.io.IOException;public class TestObject &#123;    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;        var stu = new Students(01,20,&quot;张三&quot;,new Teacher(&quot;王五&quot;,&quot;男&quot;));        Students stuClone =stu.copy();        /*判断此俩对象地址是否相同*/        if (stu.equals(stuClone))&#123;            System.out.println(&quot;地址相同&quot;);        &#125;else System.out.println(&quot;地址不同&quot;);        /*toString查看数据*/        System.out.println(stuClone);        System.out.println(stu);        /*验证拷贝对象*/        System.out.println(&quot;----------验证拷贝对象-----------&quot;);        var aT = stu.getTeacher();        aT.setName(&quot;尼古拉斯&quot;);        System.out.println(stuClone);        System.out.println(stu);        /*验证复制字段*/        System.out.println(&quot;----------验证复制字段-----------&quot;);        stu.setId(2);        System.out.println(stu);        System.out.println(stuClone);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1~4章</title>
      <link href="2022/03/20/Java-11/"/>
      <url>2022/03/20/Java-11/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaBeans模式"><a href="#JavaBeans模式" class="headerlink" title="JavaBeans模式"></a>JavaBeans模式</h1><blockquote><p>当我们需要传入多个参数构造对象时（比如有时传入2个参数，有时传入20个参数），可采用“重叠构造器模式”即利用“重载”机制。</p><p>但如果需要传入的参数是2-2000个呢？</p><p>我们总不能复写2000个构造器吧。</p><p>我们可采用: <strong>JavaBeans模式</strong></p></blockquote><p>用一个无参数的构造器创建对象，然后通过多个set方法设置参数。</p><pre><code class="java">public class myJavaBeans &#123;    private int id;    private String name;    private String sex;    /*更多字段省略*/    public myJavaBeans() &#123;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;&#125;</code></pre><p><em>这个方法模式存在线程安全</em></p><p>下面有一种Builder模式可保证线程安全</p><p><strong>Builder模式</strong></p><p>使用<strong>静态内部类</strong>（静态工厂方法）设置属性（参数），最后创建类（返回其父类的对象）完成对象初始化。</p><pre><code class="java">public class myBuilder &#123;    private int id;    private String name;    private String sex;        public static class Builder  &#123;//静态内部类只会被加载一次        private int id;        private String name;        private String sex;        public Builder() &#123;        &#125;        public Builder setId(int id) &#123;            this.id = id;            return this;//返回this，用于实现链接式调用        &#125;        public Builder setName(String name) &#123;            this.name = name;            return this;        &#125;        public Builder setSex(String sex) &#123;            this.sex = sex;            return this;        &#125;        //通过此方法返回内部类对象，此时内部类对象        public myBuilder builder()&#123;            return new myBuilder(this);        &#125;    &#125;    private myBuilder(Builder builder) &#123;        //构造器传入静态内部类builder对象，对myBuilder进行初始化。        this.id = builder.id;        this.name = builder.name;        this.sex = builder.sex;    &#125;    public static void main(String[] args) &#123;        myBuilder demoMyBuilder = new myBuilder.Builder().setId(0).setName(&quot;张三&quot;).setSex(&quot;男&quot;).builder();        //此内部类的set方法返回其本身，故可以将多个set方法调用链接起来        System.out.println(demoMyBuilder.sex);        System.out.println(demoMyBuilder.id);        System.out.println(demoMyBuilder.name);    &#125;&#125;</code></pre><p>使用泛型构建任何对象</p><pre><code class="java">public interface Builder1&lt;T&gt; &#123;    public T build();&#125;</code></pre><h1 id="单例模式Singleton"><a href="#单例模式Singleton" class="headerlink" title="单例模式Singleton"></a>单例模式Singleton</h1><ol><li><p>仅设置一个私有构造器，使用公共的final静态字段构造对象。</p><pre><code class="java">public class Elvis &#123;    public static final Elvis INSTANCE = new Elvis();//加载类时将自动创建对象    private Elvis()&#123;&#125;    public void leaveTheBuilding()&#123;&#125;&#125;</code></pre></li><li><p>通过静态工厂方法:设置一个私有构造器，一个私有final静态字段（构造对象），最后通过一个静态方法返回final静态字段。</p><pre><code class="java">class Elvis1&#123;    //1.字段私有化    private static final Elvis1 INSTANCE = new Elvis1();    //2.构造器私有化    private Elvis1()&#123;&#125;    //2.静态工厂方法返回对象引用    public static Elvis1 getInstance()&#123;return INSTANCE;&#125;    public void leaveTheBuilding()&#123;&#125;&#125;</code></pre><h1 id="消除过期元素"><a href="#消除过期元素" class="headerlink" title="消除过期元素"></a>消除过期元素</h1></li></ol><pre><code class="java">import java.lang.reflect.Array;import java.util.Arrays;import java.util.EmptyStackException;public class Stack &#123;    private Object[] elements;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    private int size = 0;    public Stack()&#123;        elements = new Object[DEFAULT_INITIAL_CAPACITY];    &#125;    //动态数组    private void ensureCapacity()&#123;        if (elements.length == size)&#123;            elements = Arrays.copyOf(elements,2*size+1);        &#125;    &#125;    //添加元素    public void push(Object e)&#123;        ensureCapacity();//先判断数组是否有空间（空间不足则扩展空间）        elements[size++] = e;    &#125;        //弹出元素//    public Object pop()&#123;//        if (size == 0)&#123;//栈为空抛出异常//            throw new EmptyStackException();//        &#125;//        return elements[--size];//        //注意：即使连续使用多个pop()方法，经历--size的元素仍然存在于数组中//    &#125;    public Object pop()&#123;        if (size == 0)&#123;            throw new EmptyStackException();        &#125;        Object result = elements[--size];        elements[size] = null;//将索引赋值为null，消除过期元素        return result;    &#125;&#125;</code></pre><h1 id="使类与成员的可访问性最小化"><a href="#使类与成员的可访问性最小化" class="headerlink" title="使类与成员的可访问性最小化"></a>使类与成员的可访问性最小化</h1><ol><li>创建类时不声明则默认为缺省即包访问级别，声明为protected时仅可被子类、同一包内的类访问。</li><li>子类覆盖父类方法时访问级别不得低于其父类</li></ol><p><strong>闭包性：public&lt;default（缺省级别，默认）&lt;protected&lt;private</strong></p><p>private与protected不能用来修饰类；</p><p>只有同一包内的另一个类迫切需要访问一个成员时，我们才会将private修改为protected。</p><h1 id="在公共类中使用访问方法而非公共-域"><a href="#在公共类中使用访问方法而非公共-域" class="headerlink" title="在公共类中使用访问方法而非公共 域"></a>在公共类中使用访问方法而非公共 域</h1><ol><li>将公共类字段私有化，通过set、get方法对其进行修改、访问。</li><li>可使用不可变的公共字段：<code>public final int ID;</code></li></ol><h1 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h1><ol><li><p>字段采用是<code> private final</code>修饰，提供创建新对象的方法而不提供修改的方法,修改时返回新对象。</p><pre><code class="java">public final class Complex &#123;    private final double re;    private final double im;    public Complex(double re, double im) &#123;        this.re = re;        this.im = im;    &#125;    public Complex add(Complex o)&#123;//修改时返回新对象        return new Complex(re-o.re,im+o.re);    &#125;&#125;</code></pre></li><li><p>.字段采用是 <code>private final</code>修饰，有仅一个私有构造器，通过静态工厂方法返回对象</p><pre><code class="java">public final class Complex &#123;    private final double re;    private final double im;    private Complex(double re, double im) &#123;        this.re = re;        this.im = im;    &#125;    public static Complex valueOf(double re, double im)&#123;        return new Complex(re,im);    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单使用动态代理</title>
      <link href="2022/03/20/Java-Aop/"/>
      <url>2022/03/20/Java-Aop/</url>
      
        <content type="html"><![CDATA[<h1 id="简单使用动态代理"><a href="#简单使用动态代理" class="headerlink" title="简单使用动态代理"></a>简单使用动态代理</h1><blockquote><p>使用Aop在不改变原有结构下对类的功能进行增强</p></blockquote><p>1.目标类接口</p><pre><code class="java">package cn.itthree.aop.service;/** * 目标接口* */public interface UsbSell &#123;    /*amount表示单次购买数量     * 返回值是一个u盘的价格*/    float sell(int amount);&#125;</code></pre><p>2.目标方法</p><pre><code class="java">package cn.itthree.aop.factory;import cn.itthree.aop.service.UsbSell;/**目标类*/public class UsbKingFactory implements UsbSell &#123;    @Override    //目标方法    public float sell(int amount) &#123;        System.out.println(&quot;目标类中执行了目标方法调用&quot;);        return 85.0f;    &#125;&#125;</code></pre><p>3.一个简单的代理类</p><pre><code class="java">package cn.itthree.aop.handler;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MySellHandler implements InvocationHandler &#123;    private Object target = null;    public MySellHandler(Object target) &#123;        this.target = target;    &#125;    @Override    //动态代理对象需要传入    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //执行目标方法并获取返回值        Object res = null;        res = method.invoke(target,args);        //功能增强        //在不改变结构的情况下对目标类进行增强        if (res != null)&#123;            Float price = (Float)res;            price += 25;            res = price;        &#125;        return res;    &#125;&#125;</code></pre><p>4.测试主程序</p><pre><code class="java">package cn.itthree.aop;import cn.itthree.aop.factory.UsbKingFactory;import cn.itthree.aop.handler.MySellHandler;import cn.itthree.aop.service.UsbSell;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class MainShop &#123;    public static void main(String[] args) &#123;        //1.创建目标对象        UsbSell factory =  new UsbKingFactory();        //2.创建InvocationHandler对象        InvocationHandler handler = new MySellHandler(factory);        //3.创建代理对象        /*        public static Object newProxyInstance(ClassLoader loader,                                          Class&lt;?&gt;[] interfaces,                                          InvocationHandler h)                                          */        //传入3个参数：        //1.目标类        //3.目标类的接口        //3.InvocationHandler对象        UsbSell proxy  = (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),handler);        //4.通过代理执行方法        float price = proxy.sell(1);        System.out.println(&quot;动态代理对象，调用方法： &quot;+price);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jsp</title>
      <link href="2022/03/20/Java-Jsp-01/"/>
      <url>2022/03/20/Java-Jsp-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Jsp书写规则"><a href="#Jsp书写规则" class="headerlink" title="Jsp书写规则"></a>Jsp书写规则</h1><p><code>&lt;% %&gt;</code>中书写Java代码</p><pre><code>&lt;%    Students stu1 = new Students(&quot;张三&quot;,1);    Students stu2 = new Students(&quot;李四&quot;,2);    Students stu3 = new Students(&quot;Li Si&quot;,3);    List&lt;Students&gt; list = new ArrayList&lt;&gt;();    list.add(stu1);    list.add(stu2);    list.add(stu3);%&gt;</code></pre><p><code>&lt;%= %&gt;</code>用于变量传值</p><p>如下代码，for循环为一个整体，用&lt;%分隔包裹实现输出值到页面。</p><p>究其根本，仍是使用流，如：</p><pre><code class="java">PrintWriter out = servletResponse.getWriter();out.print(&quot;&lt;center&gt;&lt;h1&gt;廉颇老矣，尚能饭否？&lt;/h1&gt;&lt;/center&gt;&quot;);</code></pre><pre><code class="jsp">&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;    &lt;tr&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td&gt;学号&lt;/td&gt;    &lt;/tr&gt;    &lt;%        for (Students value:list)&#123;    %&gt;    &lt;tr&gt;        &lt;td&gt;&lt;%=value.getName()%&gt;&lt;/td&gt;        &lt;td&gt;&lt;%=value.getId()%&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;%        &#125;    %&gt;&lt;/table&gt;</code></pre><h1 id="Jsp内置对象"><a href="#Jsp内置对象" class="headerlink" title="Jsp内置对象"></a>Jsp内置对象</h1><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>​     类型：HttpServletRequest<br>​     作用: 在JSP文件运行时读取请求包信息并与Servlet在请求转发过程中实现数据共享</p><pre><code class="jsp">&lt;!--  浏览器输入： http://localhost:8080/myWeb/request.jsp?userName=张三&amp;password=123--&gt;&lt;%   //在JSP文件执行时，借助于内置request对象读取请求包参数信息    String userName = request.getParameter(&quot;userName&quot;);    String password =request.getParameter(&quot;password&quot;);%&gt;来访用户姓名:&lt;%=userName%&gt;&lt;br/&gt;来访用户密码:&lt;%=password%&gt;</code></pre><p>效果图：</p><p><img src="http://img.lbkzw.cn/img/20201101154914.png" alt="image-20201101154914442"></p><h3 id="ServletContext-全局作用域对象"><a href="#ServletContext-全局作用域对象" class="headerlink" title="ServletContext(全局作用域对象)"></a>ServletContext(全局作用域对象)</h3><p>同一个网站中Servlet与Jsp，都可以通过ServletContext实现数据共享</p><p>jsp中设置全局作用域对象：</p><pre><code class="jsp">&lt;%    application.setAttribute(&quot;key1&quot;, &quot;hello world&quot;);%&gt;</code></pre><pre><code class="java">@WebServlet(&quot;/Servlet1&quot;)public class Servlet1 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        ServletContext application = request.getServletContext();//获取全局作用域对象        String value = (String)application.getAttribute(&quot;key1&quot;);//通过键获取值（获取作用域内的数据）        System.out.println(value);    &#125;        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;</code></pre><p><img src="http://img.lbkzw.cn/img/20201101161507.png" alt="image-20201101161507410"></p><pre><code>###  session</code></pre><p>数据共享：</p><p>第一个jsp文件</p><pre><code class="jsp">&lt;%     Integer value=(Integer) session.getAttribute(&quot;key1&quot;);%&gt;</code></pre><p>第二个jsp文件</p><pre><code class="jsp">&lt;%   // HttpSession session = request.getSession();   session.setAttribute(&quot;key1&quot;, 200);%&gt;</code></pre><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><blockquote><p>jsp默认支持el表达式。如要忽略el表达式需要设置jsp中<code>page</code>指令中：<code>isELIgnored=&quot;true&quot; ;</code>忽略当前这个el表达式则于<code>$&#123;&#125;</code>前加<code>/</code>即可</p></blockquote><p>##运算符</p><p>算数运算符： + - * /(div) %(mod)</p><p>比较运算符： &gt; &lt; &gt;= &lt;= == !=</p><p>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</p><p>空运算符： empty</p><ul><li>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</li><li>如：<code>$&#123;empty list&#125;</code>判断字符串、集合、数组对象是否为null或者长度为0</li><li><code>$&#123;not empty str&#125;</code>判断字符串、集合、数组对象是否不为null 并且 长度&gt;0\</li></ul><pre><code class="jsp">&lt;h3&gt;EL运算&lt;/h3&gt;$&#123;1+2&#125;$&#123;1-2&#125;$&#123;1*2&#125;$&#123;1/2&#125;&lt;h3&gt;empty&lt;/h3&gt;&lt;%    String str = &quot;&quot;;    request.setAttribute(&quot;str&quot;,str);    List list = new ArrayList();    request.setAttribute(&quot;list&quot;,list);%&gt;$&#123;not empty str&#125;$&#123;not empty list&#125;&lt;h3&gt;EL传值&lt;/h3&gt;&lt;%request.setAttribute(&quot;name&quot;,&quot;张三&quot;);session.setAttribute(&quot;name&quot;,&quot;李四&quot;);request.setAttribute(&quot;age&quot;,&quot;19&quot;);%&gt;$&#123;requestScope.name&#125;$&#123;requestScope.age&#125;&lt;%--不指定域时依次从最小的域中查找是否有该键对应的值，直到找到为止。--%&gt;$&#123;name&#125;$&#123;sessionScope.name&#125;</code></pre><p>运行结果：</p><p><img src="http://img.lbkzw.cn/img/20201101231746.png" alt="image-20201101231746003"></p><p>User.java</p><pre><code class="java">package cn.threecloth.el;import java.text.SimpleDateFormat;import java.util.Date;public class User &#123;    //逻辑视图    private String name;    private int age;    private Date birthday;    public String getBir()&#123;        //格式化日期返回String日期数据        if(birthday!=null)&#123;            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            return sdf.format(birthday);        &#125;else &#123;            return &quot;&quot;;        &#125;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public Date getBirthday(Date date) &#123;        return birthday;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;&#125;</code></pre><p>##获取值</p><blockquote><p> el表达式只能从域对象中获取值.    </p></blockquote><p><code>$&#123;域名称.键名&#125;</code>：从指定域中获取指定键的值.</p><p>如果不指明域，那么将依次从最小的域中查找是否有该键对应的值，直到找到为止。如：<code> $&#123;键名&#125;</code></p><ul><li>域名称：<ol><li>pageScope        –&gt; pageContext</li><li>requestScope     –&gt; request</li><li>sessionScope     –&gt; session</li><li>applicationScope –&gt; application（ServletContext）</li></ol></li></ul><pre><code class="jsp">&lt;%    User user = new User();    user.setAge(19);    user.setName(&quot;张三&quot;);    user.setBirthday(new Date());    request.setAttribute(&quot;user&quot;,user);    List list = new ArrayList();    list.add(&quot;aaa&quot;);    list.add(&quot;bbb&quot;);    list.add(&quot;ccc&quot;);    request.setAttribute(&quot;list&quot;,list);    Map map = new HashMap();    map.put(&quot;name&quot;,&quot;张三&quot;);    map.put(&quot;user&quot;,user);    map.put(&quot;list&quot;,list);    request.setAttribute(&quot;map&quot;,map);%&gt;&lt;h3&gt;el获取对象中的值&lt;/h3&gt;&lt;%--    * 通过的是对象的属性来获取        * setter或getter方法，去掉set或get，在将剩余部分，首字母变为小写。        * setName --&gt; Name --&gt; name--%&gt;$&#123;user.bir&#125;&lt;br&gt;&lt;%--指定作用域获取值--%&gt;$&#123;requestScope.user.age&#125;&lt;br&gt;$&#123;requestScope.user.name&#125;&lt;br&gt;&lt;h3&gt;获取list集合中的值&lt;/h3&gt;$&#123;list&#125;&lt;br&gt;$&#123;list[0]&#125;&lt;br&gt;$&#123;list[1]&#125;&lt;br&gt;$&#123;list[2]&#125;&lt;br&gt;&lt;h3&gt;获取map集合中的值与对象&lt;/h3&gt;$&#123;map.name&#125;$&#123;map.user&#125;$&#123;map.user.age&#125;$&#123;map.list[0]&#125;&lt;h3&gt;动态获取虚拟目录&lt;/h3&gt;$&#123;pageContext.request.contextPath&#125;</code></pre><p>运行结果：</p><img src="http://img.lbkzw.cn/img/20201101232011.png" alt="image-20201101232011676" style="zoom:50%;" /><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><blockquote><p>用于简化和替换jsp页面上的java代码</p></blockquote><pre><code class="jsp">&lt;%    List list = new ArrayList();    list.add(new User(&quot;张三&quot;,23,new Date()));    list.add(new User(&quot;李四&quot;,18,new Date()));    list.add(new User(&quot;王五&quot;,19,new Date()));    request.setAttribute(&quot;list&quot;,list);%&gt;&lt;table border=&quot;1&quot; width=&quot;500&quot; align=&quot;center&quot;&gt;    &lt;tr&gt;        &lt;th&gt;编号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;        &lt;th&gt;生日&lt;/th&gt;    &lt;/tr&gt;    &lt;c:forEach  var=&quot;user&quot; varStatus=&quot;s&quot; items=&quot;$&#123;list&#125;&quot;&gt;        &lt;%--foreach:相当于java代码的for语句--%&gt;        &lt;c:if test=&quot;$&#123;s.count % 2 != 0&#125;&quot;&gt;           &lt;%--if:相当于java代码的if语句,test中写布尔表达式--%&gt;            &lt;%--如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容--%&gt;            &lt;tr bgcolor=&quot;red&quot;&gt;                &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt;                &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;                &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;                &lt;td&gt;$&#123;user.bir&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/c:if&gt;        &lt;c:if test=&quot;$&#123;s.count % 2 == 0&#125;&quot;&gt;            &lt;tr  bgcolor=&quot;green&quot;&gt;                &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt;                &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;                &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;                &lt;td&gt;$&#123;user.bir&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/c:if&gt;    &lt;/c:forEach&gt;</code></pre><pre><code class="jsp">&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%--引入jsl表达式包--%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    List list = new ArrayList();    list.add(&quot;aaa&quot;);    list.add(&quot;bbb&quot;);    list.add(&quot;ccc&quot;);    request.setAttribute(&quot;list&quot;,list);    request.setAttribute(&quot;number&quot;,4);%&gt;&lt;%--取出域中集合的值--%&gt;&lt;c:if test=&quot;$&#123;not empty list&#125;&quot;&gt;    $&#123;list[0]&#125;&lt;/c:if&gt;&lt;br&gt;&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt;    第$&#123;s.count&#125;次遍历&amp;nbsp;当前索引$&#123;s.index&#125;&amp;nbsp;当前值$&#123;str&#125;&amp;nbsp;当前状态$&#123;s&#125;    &lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;%--属性：begin：开始值end：结束值var：临时变量step：步长varStatus:循环状态对象index:容器中元素的索引，从0开始count:循环次数，从1开始items:容器对象&lt;%--判断奇偶--%&gt;&lt;br&gt;&lt;c:if test=&quot;$&#123;number%2==0&#125;&quot;&gt;    $&#123;number&#125;为偶数&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;number%2!=0&#125;&quot;&gt;    $&#123;number&#125;为奇数&lt;/c:if&gt;&lt;HR color=#987cb9 SIZE=1&gt;&lt;h3&gt;switch&lt;/h3&gt;    &lt;%--choose:相当于java代码的switch语句        1. 使用choose标签声明                     相当于switch声明        2. 使用when标签做判断                     相当于case        3. 使用otherwise标签做其他情况的声明        相当于default--%&gt;&lt;c:choose&gt;&lt;%--    以下相当于case ：--%&gt;    &lt;c:when test=&quot;$&#123;number==1&#125;&quot;&gt;星期一&lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;number==2&#125;&quot;&gt;星期二&lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;number==3&#125;&quot;&gt;星期三&lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;number==4&#125;&quot;&gt;星期四&lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;number==5&#125;&quot;&gt;星期五&lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;number==6&#125;&quot;&gt;星期六&lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;number==7&#125;&quot;&gt;星期日&lt;/c:when&gt;&lt;%--以下相当于default    --%&gt;    &lt;c:otherwise&gt;        输入数字有误    &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack,Queue,Tree</title>
      <link href="2022/03/20/Java-Stack-01/"/>
      <url>2022/03/20/Java-Stack-01/</url>
      
        <content type="html"><![CDATA[<pre><code class="mermaid">graph LRA[扫描输入] --&gt;B&#123;是否为运算符&#125;    B --&gt; |是运算符| C&#123;运算符栈是否为空&#125;    B --&gt;|是数值| D&#123;判断是否为多位数&#125;    D --&gt;|是多位| J[扫描到运算符为止]    J --&gt; K    D --&gt;|是个位| K[压入数值栈]    C --&gt;|为空| E[将运算符压入栈]    C --&gt;|不为空| F&#123;比较运算符优先级&#125;    F --&gt;|优先级高于栈顶| G[入栈]    F --&gt;|优先级低于栈顶| H[弹出运算符栈与数值栈中元素]    H --&gt;|进行计算| I[将计算结果与比较优先级的运算符分别入栈]    O[中缀表达式算法]   </code></pre><h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>方法：为每个运算符旁的数值加括号如:<code>a+b*c; </code>改为<code> (a+(b*c))</code>，再将运算符移到括号外，得到后缀表达式<code> abc*+</code></p><p>转为算法：</p><ol><li>新建运算符栈，从左至右扫描，</li><li>运算符栈空时直接入栈，不为空则比较优先级，优先级大于时直接入栈，等于或小于时先（原栈顶元素）出栈，（档期元素）再入栈</li><li>到达末尾（即扫描完毕时），弹出所有运算符并追加到表达式末尾</li></ol><p>后缀表达式求值：遇到符号弹出数值进行求值（数值优先处于符号右方）</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="数组实现："><a href="#数组实现：" class="headerlink" title="数组实现："></a>数组实现：</h2><pre><code class="java">package com.pdf.data;import org.junit.Test;public class ArrayStack &#123;    /*字段分别为：栈大小、模拟栈的数组、栈顶*/    private int maxsize;    private int[] stack;    private int top = -1;    public ArrayStack(int maxsize)&#123;        this.maxsize = maxsize;        stack = new int[this.maxsize];    &#125;    /*The stack is full*/    public boolean isFull()&#123;        return top+1 == maxsize;    &#125;    /*The stack is void*/    public boolean isEmpty()&#123;        return top == -1;    &#125;    /*Press-in data*/    public void push(int value)&#123;        if (isFull())&#123;            System.out.println(&quot;Stack fill&quot;);            return;        &#125;        top++;        stack[top]=value;    &#125;    /*Pop-up data*/    public int pop()&#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;Stack Void&quot;);        &#125;        int value = stack[top];        top--;        return value;    &#125;    /*print Stack*/    public void list()&#123;        if (isEmpty())&#123;            System.out.println(&quot;Stack void&quot;);            return;        &#125;        for (int i=top;i&gt;=0;i--)&#123; System.out.printf(&quot;stack[%d]=%d\n&quot;,i,stack[i]);        &#125;    &#125;    public static void main(String[] args) &#123;        var mStack = new ArrayStack(100);        for (int i = 1; i &lt; 101; i++) &#123;            assert i &lt; 50:i;//断言            mStack.push(i);        &#125;        mStack.list();    &#125;&#125;</code></pre><h2 id="链表实现："><a href="#链表实现：" class="headerlink" title="链表实现："></a>链表实现：</h2><pre><code class="java">package com.abstrast.data.stack;import java.util.EmptyStackException;/*链表实现栈*/public final class LinkedStack&lt;T&gt; implements StackInterface&lt;T&gt; &#123;    private Node topNode;//指向栈顶    public LinkedStack()&#123;        topNode = null;    &#125;    /*节点类*/    private class Node&#123;        private T data;        private Node next;        Node(T newEntry,Node topNode)&#123;            data = newEntry;            next = topNode;        &#125;        public Node getNextNode() &#123;            return next;        &#125;        public T getData() &#123;            return data;        &#125;    &#125;    @Override    public void push(T newEntry) &#123;//        Node newNode = new Node(newEntry,topNode);//        topNode = newNode;        topNode = new Node(newEntry,topNode);// 压入数据时直接指向栈顶    &#125;    @Override    public T pop() &#123;        T top = peek();        topNode = topNode.getNextNode();        return top;    &#125;    @Override    public T peek() &#123;//查看栈顶元素       if(isEmpty())           throw new EmptyStackException();       else           return topNode.getData();    &#125;    @Override    public boolean isEmpty() &#123;        return topNode ==null;//顶栈为null则为空    &#125;    @Override    public void clear() &#123;//没有顶栈则栈为空        topNode = null;    &#125;//    public static void main(String[] args) &#123;//        var a = new LinkedStack&lt;String&gt;();//        a.push(&quot;a&quot;);//        a.push(&quot;b&quot;);//        a.push(&quot;c&quot;);//        a.push(&quot;d&quot;);//        a.peek();//        a.pop();//        a.peek();//    &#125;&#125;</code></pre><h2 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h2><pre><code class="java">import java.util.Iterator;/** * 这是一个动态数组栈*/public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;&#123;//实现Iterable&lt;Item&gt;接口后可以使用foreach遍历    private Item[] a = (Item[]) new Object[1];//栈元素数量，通过强制类型转换Object数组实现泛型号=数组    private int N = 0;//元素数量    public boolean isEmpty()&#123;        return N == 0;    &#125;    public int size()&#123;        return N;    &#125;    /*实现动态数组*/    private void resize(int max)&#123;        Item[] temp = (Item[]) new Object[max];//创建空间大小为2倍的新数组        for (int i = 0; i &lt; N; i++)&#123;//复制数组元素            temp[i] = a[i];        &#125;        a = temp;    &#125;    public void push(Item item)&#123;        if (N == a.length)resize(2*a.length);//数组存储空间不足，则扩大为2倍        a[N++] = item;//每次添加元素N+1    &#125;    public Item pop()&#123;        Item item = a[--N];        a[N] = null;//防止游离元素，即不在栈中，但仍存在于数组中的元素        if (N &gt; 0&amp;&amp;N == a.length/4)resize(a.length/2);//如果该数组仅仅占用1/4,那么缩小它        return item;    &#125;    public Iterator&lt;Item&gt; iterator()&#123;//实现了一个迭代器        return new ReverseArrayIterator();    &#125;    private class ReverseArrayIterator implements Iterator&lt;Item&gt;&#123;        private int i = N;        public boolean hasNext()&#123;return  i &gt; 0;&#125;        public Item next()&#123;return a[--i];&#125;//next即越过并返回这个元素，        // 数组下标从0开始，而数组中只要存在元素那么数量便从1开始，故需要减1（否则下标N下的元素不存在则返回null）        public void remove()&#123;&#125;    &#125;    public static void main(String[] args) &#123;        long startTime = System.currentTimeMillis(); // 获取开始时间        var a = new ResizingArrayStack&lt;String&gt;();        for (int i = 0; i &lt; 1000000; i++) &#123;            a.push(&quot;abc&quot;+i);        &#125;        for (String s: a)            System.out.println(s);        long endTime = System.currentTimeMillis(); // 获取结束时间        System.out.println(&quot;程序运行时间： &quot; + (endTime - startTime) + &quot;ms&quot;);    &#125;&#125;</code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h2><pre><code class="java">package cn.three.cloth.queue;import java.util.Iterator;import java.util.NoSuchElementException;public class ListQueue &lt;T&gt;implements Iterable&lt;T&gt;&#123;    /**分析：     * 队列实现需包含：队列长度、头指针，尾指针、结点类。     *功能:增、删、清空查看队列、队列有无、查看队列头元素     * 迭代：队列类实现可迭代接口Iterable&lt;T&gt;，再由内部类实现迭代器。     */    private int length;    private Node head,tail;    /*节点类*/    private class Node&lt;T&gt;&#123;        private T data;        private Node next;        Node(T data) &#123;            this.data = data;        &#125;        @Override        public String toString() &#123;            return &quot;Node(&quot; +                    &quot;data=&quot; + data +                    &quot;, next=&quot; + next +                    &#39;)&#39;;        &#125;    &#125;    /*判断队列是否为空*/    private boolean isEmpty()&#123;//        return length!=0;也可以哦        return head == null;    &#125;    /*添加元素*/    private void enqueue(T x)&#123;        if (isEmpty())&#123;            tail = head = new Node&lt;T&gt;(x);            length++;        &#125;else &#123;            tail = tail.next = new Node&lt;T&gt;(x);//尾指针与与原尾结点均指向新结点            length++;        &#125;    &#125;    /*删除元素*/    public T dequeue()&#123;        if (isEmpty())&#123;            throw new UnsupportedOperationException(&quot;队列无数据&quot;);        &#125;else&#123;            T returnValue = (T) head.data;            head = head.next;            length--;            return returnValue;        &#125;    &#125;    /*清空队列*/    public void makeEmpty()&#123;        head=tail=null;        length=0;    &#125;    /*返回头元素*/    public T getHead() throws Exception &#123;        if (isEmpty())&#123;            throw new Exception(&quot;队列无数据&quot;);        &#125;else&#123;            return (T) head.data;        &#125;    &#125;    /*查看队列中所有元素*/    public void showQueue()&#123;        Node head =this.head;//引用head便于进行遍历        while (head.next!=null)&#123;            System.out.println(head.data);            head=head.next;        &#125;        System.out.println(head.data);    &#125;    /*迭代器*/    @Override    public Iterator&lt;T&gt; iterator() &#123;        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象    &#125;    private class DequeueIterator implements Iterator&lt;T&gt;&#123;        private Node current = head;        public boolean hasNext() &#123;            return current != null;        &#125;        public void remove() &#123;            throw new UnsupportedOperationException(                    &quot;remove is not supported!&quot;);        &#125;        public T next() &#123;            if (!hasNext())                throw new NoSuchElementException();            T item = (T) current.data;            current = current.next;            return item;        &#125;    &#125;    @Override    public String toString() &#123;        return &quot;ListQueue&#123;&quot; +                &quot;length=&quot; + length +                &quot;, head=&quot; + head +                &quot;, tail=&quot; + tail +                &#39;&#125;&#39;;    &#125;    /*测试*/    public static void main(String[] args) throws Exception &#123;        var a = new ListQueue&lt;Integer&gt;();//创建队列        for (int i = 0; i &lt; 10; i++) &#123;//添加元素            a.enqueue(i);        &#125;        for (int i: a) &#123;            System.out.println(i);        &#125;      //覆盖toString只为了更直观的查看队列        System.out.println(a+&quot;&quot;);    &#125;&#125;</code></pre><h2 id="数组模拟队列-amp-amp-单例模式"><a href="#数组模拟队列-amp-amp-单例模式" class="headerlink" title="数组模拟队列&amp;&amp;单例模式"></a>数组模拟队列&amp;&amp;单例模式</h2><pre><code class="java">import org.junit.Test;public class ArrayQueue &#123;    private static int maxsize;    /*分别创建最大容量、头指针、尾指针、数组*/    private int front = -1;    private int rear = -1;    private int[] arr;    private static ArrayQueue MYARRAYQUEUE;    private ArrayQueue(int maxsize)&#123;        this.maxsize = maxsize;        arr = new int[maxsize];    &#125;    /*队列是否为满*/    public boolean isFull()&#123;        return rear == maxsize-1;//因为尾、头部指针开始均指向-1，故容量减1为满    &#125;    /*队列是否为空*/    public boolean isEmpty()&#123;        return rear  == front;    &#125;    /*添加数据到队列*/    public void addQueue(int n)&#123;       if (isFull())&#123;           System.out.println(&quot;挤挤总会有的？？？&quot;);           return;       &#125;       arr[++rear]=n;// 写入尾部    &#125;    public static synchronized ArrayQueue getArrayQueue(int a)&#123;        if(null != MYARRAYQUEUE)return MYARRAYQUEUE;        maxsize = a;        MYARRAYQUEUE = new ArrayQueue(a);        return MYARRAYQUEUE;    &#125;    public void showQueue() &#123;        var a = ArrayQueue.getArrayQueue(maxsize);        // 遍历        if (isEmpty()) &#123;            System.out.println(&quot;队列空的，没有数据~~&quot;);            return;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);        &#125;    &#125;&#125;class RunArrayQueue extends Thread&#123;    @Override    public void run() &#123;        var a = ArrayQueue.getArrayQueue(4);        a.showQueue();        a.addQueue(4);        a.addQueue(5);        a.addQueue(6);        a.showQueue();    &#125;    public static void main(String[] args) &#123;        var a = new RunArrayQueue();        var b = new RunArrayQueue();        a.start();        b.start();    &#125;&#125;</code></pre><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><pre><code class="java">public class CircleArrayQueue &#123;    private static int maxsize;    /*分别创建最大容量、头指针、尾指针、数组*/    private int front = 0;    private int rear = 0;    private int[] arr;    private CircleArrayQueue(int maxsize) &#123;        this.maxsize = maxsize;        arr = new int[maxsize];    &#125;    /*队列是否为满*/    public boolean isFull() &#123;        return (rear + 1) % maxsize == front;        //无论指针怎么移动，rear总与最后一个元素间隔一格    &#125;    /*队列是否为空*/    public boolean isEmpty() &#123;        return rear == front;    &#125;    /*添加数据到队列*/    public void addQueue(int n) &#123;        if (isFull()) &#123;            System.out.println(&quot;挤挤总会有的？？？&quot;);            return;        &#125;        arr[rear] = n;        rear = (rear + 1) % maxsize;    &#125;    /*取出数据*/    public int getQueue() &#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;队列为空你币没了&quot;);        &#125;        int value = arr[front];        front = (front + 1)%maxsize;        return value;    &#125;    /*打印队列*/    public void showQueue() &#123;        // 遍历        if (isEmpty()) &#123;            System.out.println(&quot;队列空的，没有数据~~&quot;);            return;        &#125;        for (int i = 0; i &lt; front + size(); i++) &#123;            System.out.printf(&quot;arr[%d]=%d\n&quot;, i%maxsize, arr[i%maxsize]);        &#125;    &#125;    public int size()&#123;        return (rear + maxsize -front)%maxsize;    &#125;    //显示队列头信息    public int headQueue()&#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;队列为空&quot;);        &#125;        return arr[front];    &#125;    public static void main(String[] args) &#123;       var a = new CircleArrayQueue(10);    &#125;&#125;</code></pre><h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><h3 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h3><pre><code class="java">package cn.three.cloth.queue;import java.util.Iterator;import java.util.NoSuchElementException;public class ListQueue2&lt;T&gt;implements Iterable&lt;T&gt;&#123;    /**双向队列不带头结点     */    private int length;    private Node head,tail;    /*节点类*/    private class Node&lt;T&gt;&#123;        private T data;        private Node next;        private Node prev;        Node(T data) &#123;            this.data = data;        &#125;        @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                    &quot;data=&quot; + data +                    &quot;, next=&quot; + next +                    &quot;, prev=&quot; + prev +                    &#39;&#125;&#39;;        &#125;    &#125;    /*判断队列是否为空*/    private boolean isEmpty()&#123;//        return length==0;也可以哦        return head == null;    &#125;    /*队头添加元素*/    private void addHead(T x)&#123;        if (isEmpty())&#123;            tail = head = new Node(x);            length++;            &#125;        else &#123;            Node newNode = head;//指向原head指向的首结点            head = new Node(x);//将head指向添加的新结点            //head.prev=null;类中的成员字段会自动初始化为null，故不必设置新首结点prev=null            head.next = newNode;//将新结点的next指向原首节点            newNode.prev = head;//原首结点的prev指向新结点            length++;//队列长度+1        &#125;    &#125;    /*队尾添加元素*/    private void addTail(T x)&#123;        if (isEmpty())&#123;            tail = head = new Node(x);            length++;        &#125;        else &#123;            Node newNode = tail;            tail = new Node(x);            //tail.next=null;类中的成员字段会自动初始化为null，故不必设置新尾结点next=null            newNode.next = tail;//原尾结点的next指向新结点            tail.prev=newNode;//新结点的prev指向原尾结点            length++;        &#125;    &#125;    /*队头删除元素*/    public T removeHead()&#123;        if (isEmpty())&#123;//队列无元素抛出异常            throw new UnsupportedOperationException(&quot;队列无数据&quot;);        &#125;else&#123;            T returnValue = (T) head.data;            head = head.next;            length--;            //如果删除时队列中只存在一个元素则head=null，否则令首节点的prev=null            if (length==0)&#123;                tail=head=null;            &#125;else &#123;                head.prev=null;            &#125;            return returnValue;        &#125;    &#125;    /*队尾删除元素*/    public T removeTail()&#123;        if (isEmpty())&#123;            throw new UnsupportedOperationException(&quot;队列无数据&quot;);        &#125;else&#123;            T returnValue = (T) tail.data;            tail = tail.prev;            length--;            if (length==0)&#123;                tail=head=null;            &#125;else &#123;                tail.next=null;            &#125;            return returnValue;//返回被删除结点的值        &#125;    &#125;    /*清空队列*/    public void makeEmpty()&#123;        head=tail=null;        length=0;    &#125;    /*返回头元素*/    public T getHead() throws Exception &#123;        if (isEmpty())&#123;            throw new Exception(&quot;队列无数据&quot;);        &#125;else&#123;            return (T) head.data;        &#125;    &#125;    /*查看队列中所有元素*/    public void showQueue()&#123;        Node head =this.head;//引用head便于进行遍历        while (head.next!=null)&#123;            System.out.println(head.data);            head=head.next;        &#125;        System.out.println(head.data);    &#125;    /*迭代器*/    @Override    public Iterator&lt;T&gt; iterator() &#123;        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象    &#125;    private class DequeueIterator implements Iterator&lt;T&gt;&#123;        private ListQueue2.Node current = head;//指向首结点        public boolean hasNext() &#123;            return current != null;        &#125;        public void remove() &#123;            throw new UnsupportedOperationException(                    &quot;remove is not supported!&quot;);        &#125;        public T next() &#123;            if (!hasNext())                throw new NoSuchElementException();            T item = (T) current.data;//存储当前结点中的值            current = current.next;//更新指针，指向下一个结点            return item;//返回当前结点中的值        &#125;    &#125;    @Override    public String toString() &#123;        return &quot;ListQueue&#123;&quot; +                &quot;length=&quot; + length +                &quot;, head=&quot; + head +                &quot;, tail=&quot; + tail +                &#39;&#125;&#39;;    &#125;    /*测试*/    public static void main(String[] args) throws Exception &#123;        var a = new ListQueue2&lt;Integer&gt;();//创建队列        for (int i = 0; i &lt; 10; i++) &#123;//添加元素            a.addHead(i);            a.removeTail();        &#125;a.removeTail();        for (int i: a) &#123;            System.out.println(i);        &#125;      //覆盖toString只为了更直观的查看队列        System.out.println(a+&quot;&quot;);    &#125;&#125;</code></pre><p>###带头结点</p><pre><code class="java">package cn.three.cloth.queue;import java.util.Iterator;import java.util.NoSuchElementException;public class ListQueue3&lt;T&gt;implements Iterable&lt;T&gt;&#123;    /**双向队列带头结点的     * 引入一个头结点nil， 初始化时nil的prev和next分别指向自身。用于判断队列是否为空     * 加入新元素以后只需要操作新增节点，nil 和 nil的下一个节点。     */    private int length;    private Node headNode;    /*节点类*/    private class Node&lt;T&gt;&#123;        private T data;        private Node next;        private Node prev;        //使用了默认结点构造器        @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                    &quot;data=&quot; + data +                    &quot;, next=&quot; + next +                    &quot;, prev=&quot; + prev +                    &#39;&#125;&#39;;        &#125;    &#125;    public ListQueue3()&#123;        headNode = new Node();        headNode.next = headNode;        headNode.prev = headNode;    &#125;    /*判断队列是否为空*/    private boolean isEmpty()&#123;//        return length==0;也可以哦        return headNode.next == headNode;    &#125;    /*队头添加元素    * 添加的所有元素都将位于头结点之后*/    private void addHead(T x)&#123;            Node newNode = new Node();//创建新结点            newNode.data=x;            //以下操作顺序不能颠倒            //先将新结点的前驱为头结点，后继为头结点的原后继            newNode.prev=headNode;            newNode.next=headNode.next;            //再将头结点的原后继的前驱、改为新结点            headNode.next.prev=newNode;            headNode.next=newNode;//最后将头结点的后继为新结点            length++;//队列长度+1    &#125;    /*队尾添加元素    * 添加的所有元素都将位于头结点之前*/    private void addTail(T x)&#123;        Node newNode = new Node();//创建新结点        newNode.data=x;        newNode.next=headNode;//新结点的后继为头结点        //以下操作顺序不能颠倒        newNode.prev=headNode.prev;//现将新结点的前驱为头结点的前驱        headNode.prev.next=newNode;//再将头结点前驱的后继为新结点        headNode.prev=newNode;//最后将头结点前驱改为新结点        length++;//队列长度+1    &#125;    /*队头删除元素*/    public T removeHead()&#123;        if (isEmpty())            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);        Node del = headNode.next;//指向将要删除的结点        T retunValue = (T) del.data;        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点        del.next.prev = headNode;        headNode.next = del.next;        length--;        return retunValue;    &#125;    /*队尾删除元素*/    public T removeTail()&#123;        if (isEmpty())            throw new NoSuchElementException(&quot;Can&#39;t remove from empty deque&quot;);        Node del = headNode.prev;//指向将要删除的结点        T retunValue = (T) del.data;        //将即将被删除元素的后继结点的前驱改为头结点，并将头结点的后继设为此结点        del.prev.next=headNode;        headNode.prev=del.prev;        length--;        return retunValue;    &#125;    /*清空队列*/    public void makeEmpty()&#123;        headNode.next=null;        length=0;    &#125;    /*迭代器*/    @Override    public Iterator&lt;T&gt; iterator() &#123;        return (Iterator&lt;T&gt;) new DequeueIterator();//返回迭代器对象    &#125;    private class DequeueIterator implements Iterator&lt;T&gt;&#123;        private ListQueue3.Node current = headNode.next;//指向头结点        public boolean hasNext() &#123;            return current != headNode;        &#125;        public void remove() &#123;            throw new UnsupportedOperationException(                    &quot;remove is not supported!&quot;);        &#125;        public T next() &#123;            if (!hasNext())                throw new NoSuchElementException();            T item = (T) current.data;//存储当前结点中的值            current = current.next;//更新指针，指向下一个结点            return item;//返回当前结点中的值        &#125;    &#125;    /*测试*/    public static void main(String[] args) throws Exception &#123;        var a = new ListQueue3&lt;Integer&gt;();//创建队列        for (int i = 0; i &lt; 10; i++) &#123;            a.addTail(i);        &#125;a.removeHead();        for (int i: a) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树结点类：</p><pre><code class="java">package cn.three.cloth.Tree;/** * 二叉树结点类*/public class Node&lt;T&gt;&#123;    private int no;    private T element;    private Node left;    private Node right;    public Node(int no, T element) &#123;        this.no = no;        this.element = element;    &#125;    public int getNo() &#123;        return no;    &#125;    public T getElement() &#123;        return element;    &#125;    public Node getLeft() &#123;        return left;    &#125;    public Node getRight() &#123;        return right;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    public void setElement(T element) &#123;        this.element = element;    &#125;    public void setLeft(Node left) &#123;        this.left = left;    &#125;    public void setRight(Node right) &#123;        this.right = right;    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;no=&quot; + no +                &quot;, element=&quot; + element +&quot;&#125;&quot;;    &#125;    /*前、中、后序遍历开始*/    //前序遍历    public void preOrder()&#123;        System.out.println(this);        if (this.left != null)&#123;            this.left.preOrder();        &#125;        if (this.right != null)&#123;            this.right.preOrder();        &#125;    &#125;    //中序遍历    public void infixOrder()&#123;        if (this.left != null)&#123;            this.left.infixOrder();        &#125;        System.out.println(this);        if (this.right != null)&#123;            this.right.infixOrder();        &#125;    &#125;    //后序遍历    public void postOrder()&#123;        if (this.left != null)&#123;            this.left.postOrder();        &#125;        if (this.right != null)&#123;            this.right.postOrder();        &#125;        System.out.println(this);    &#125;    /*前、中、后序查找开始*/    //前序查找、    public Node preOrderSearch(int no)&#123;        if (this.no == no)&#123;            return this;        &#125;        Node resNode = null;        if (this.left != null)&#123;            resNode = this.left.preOrderSearch(no);        &#125;        if (resNode != null)&#123;            return resNode;        &#125;        if (this.right != null)&#123;            resNode = this.right.preOrderSearch(no);        &#125;        return resNode;    &#125;    //中序查找    public Node infixOrderSearch(int no)&#123;        Node resNode = null;        if (this.left != null)&#123;            resNode = this.left.infixOrderSearch(no);        &#125;        if (resNode != null)&#123;            return resNode;        &#125;        if (this.no == no)&#123;            return this;        &#125;        if (this.right != null)&#123;            resNode = this.right.infixOrderSearch(no);        &#125;        return resNode;    &#125;    //后序查找    public Node postOrderSearch(int no)&#123;        Node resNode = null;        if (this.left != null)&#123;            resNode = this.left.postOrderSearch(no);        &#125;        if (resNode != null)&#123;            return resNode;        &#125;        if (this.right != null)&#123;            resNode = this.right.postOrderSearch(no);        &#125;        if (this.no == no)&#123;            return this;        &#125;        return resNode;    &#125;    /*删除结点*/    public void delNode(int no)&#123;        //判断当前结点的左、右结点是否为要删除结点        if (this.left !=null &amp;&amp; this.left.no == no)&#123;            this.left = null;            return;        &#125;        if (this.right !=null &amp;&amp; this.right.no == no)&#123;            this.right = null;            return;        &#125;        //··左、右递归删除        if (this.left != null)&#123;            this.left.delNode(no);        &#125;;        if (this.right != null)&#123;            this.right.delNode(no);        &#125;;    &#125;&#125;</code></pre><p>二叉树：</p><pre><code class="java">package cn.three.cloth.Tree;/** * 二叉树*/public class BinaryTree1 &#123;    private Node root;    public void setRoot(Node root) &#123;        this.root = root;    &#125;/*前、中、后序遍历*/    public void preOrder()&#123;        if (this.root != null)&#123;            this.root.preOrder();        &#125;else System.out.println(&quot;当前二叉树为空&quot;);    &#125;    public void infixOrder()&#123;        if (this.root != null)&#123;            this.root.infixOrder();        &#125;else System.out.println(&quot;当前二叉树为空&quot;);    &#125;    public void postOrder()&#123;        if (this.root != null)&#123;            this.root.postOrder();        &#125;else System.out.println(&quot;当前二叉树为空&quot;);    &#125;    /*前、中、后序遍历*/    public Node preOrderSearch(int no)&#123;        if (root != null)&#123;            return root.preOrderSearch(no);        &#125;else &#123;            return null;        &#125;    &#125;    public Node infixOrderSearch(int no)&#123;        if (root != null)&#123;            return root.infixOrderSearch(no);        &#125;else &#123;            return null;        &#125;    &#125;    public Node postOrderSearch(int no)&#123;        if (root != null)&#123;            return root.postOrderSearch(no);        &#125;else &#123;            return null;        &#125;    &#125;    public void delNode(int no)&#123;        if (root != null)&#123;//该树不为空树            if (root.getNo() == no)&#123;//该树根结点是否为目标结点                root = null;            &#125;else &#123;                root.delNode(no);//递归删除（Node类中的）以此结点为根结点。沿着左结点遍历查询删除，如未找到则再沿着根结点的右结点遍历查询            &#125;        &#125;else &#123;            System.out.println(&quot;该树为空！&quot;);        &#125;    &#125;&#125;</code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组<img src="https://i.loli.net/2020/09/13/qRFTifeoytCw1c6.png"></h1><pre><code class="java">public class SparseArray &#123;    public static void main(String[] args) &#123;        // 创建一个原始的二维数组 11 * 11        // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子        int chessArr1[][] = new int[11][11];        chessArr1[1][2] = 1;        chessArr1[2][3] = 2;        chessArr1[4][5] = 2;        // 输出原始的二维数组        System.out.println(&quot;原始的二维数组~~&quot;);        for (int[] row : chessArr1) &#123;            for (int data : row) &#123;                System.out.printf(&quot;%d\t&quot;, data);            &#125;            System.out.println();        &#125;        // 将二维数组 转 稀疏数组的思路        // 1. 先遍历二维数组 得到非0数据的个数        int sum = 0;        for (int i = 0; i &lt; 11; i++) &#123;            for (int j = 0; j &lt; 11; j++) &#123;                if (chessArr1[i][j] != 0) &#123;                    sum++;                &#125;            &#125;        &#125;        // 2. 根据非0数据个数再加一（记录总行、列、有效值个数）创建对应的稀疏数组        int sparseArr[][] = new int[sum + 1][3];        // 给稀疏数组赋值        sparseArr[0][0] = 11;        sparseArr[0][1] = 11;        sparseArr[0][2] = sum;                // 遍历二维数组，将非0的值存放到 sparseArr中        int count = 0; //count 用于记录是第几个非0数据        for (int i = 0; i &lt; 11; i++) &#123;            for (int j = 0; j &lt; 11; j++) &#123;                if (chessArr1[i][j] != 0) &#123;                    count++;                    sparseArr[count][0] = i;//行                    sparseArr[count][1] = j;//列                    sparseArr[count][2] = chessArr1[i][j];//值                &#125;            &#125;        &#125;                // 输出稀疏数组的形式        System.out.println();        System.out.println(&quot;得到稀疏数组为~~~~&quot;);        for (int i = 0; i &lt; sparseArr.length; i++) &#123;            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);        &#125;        System.out.println();                //将稀疏数组 --》 恢复成 原始的二维数组        /*         *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]            2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.         */                //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组                int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];                //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可                for(int i = 1; i &lt; sparseArr.length; i++) &#123;            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];        &#125;                // 输出恢复后的二维数组        System.out.println();        System.out.println(&quot;恢复后的二维数组&quot;);                for (int[] row : chessArr2) &#123;            for (int data : row) &#123;                System.out.printf(&quot;%d\t&quot;, data);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> dataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heap,heap-sort</title>
      <link href="2022/03/20/Java-datas-heap/"/>
      <url>2022/03/20/Java-datas-heap/</url>
      
        <content type="html"><![CDATA[<p>堆：以<strong>完全二叉树</strong>的形式展现：</p><p>除了树的最后一层结点不需要是满的，其它的每一层<strong>从左到右</strong>都是满的，如果最后一层结点不 是满的，那么要求<strong>左满右不满</strong></p><p><img src="http://img.lbkzw.cn/img/20201029185145.png" alt="image-20201029185145002"></p><p>并以<strong>数组</strong>进行存储。每个结点都大于等于它的两个<strong>子结点</strong>。</p><p>如下图，如用k表示<strong>当前结点</strong>，则其的<strong>左右结点</strong>分别为2k，2k+1，任意结点的<strong>父节点</strong>为k/2</p><p>k/2(包括k/2)前是<strong>非叶子结点</strong>k/2之后是<strong>叶子结点</strong>。</p><p><img src="http://img.lbkzw.cn/img/20201027152457.png" alt="image-20201027152457648"></p><h1 id="堆实现"><a href="#堆实现" class="headerlink" title="堆实现"></a>堆实现</h1><pre><code class="java">package cn.three.cloth.heap;public class Heap&lt;T extends  Comparable &lt;T&gt;&gt; &#123;//类型 T 必须实现 Comparable 接口，并且这个接口的类型是 T    private T[] items;//存储堆    private int N;//堆元素的数量    public Heap(int x) &#123;        this.items = (T[]) new Comparable[x+1];//数组索引0处不存放元素    &#125;    //判断堆中索引i处的元素是否小于索引j处的元素    private boolean less(int i,int j)&#123;        return items[i].compareTo(items[j])&lt;0;    &#125;    //交换堆中i索引和j索引处的值    private void exch(int i,int j)&#123;        T temp = items[i];        items[i] = items[j];        items[j] = temp;    &#125;    //删除堆中最大的元素,并返回这个最大元素    public T delMax()&#123;        T max = items[1];        exch(1,N);//交换最大元素与末尾元素的位置        items[N]=null;//清除游离元素        N--;//元素数量减一        sink(1);//下沉        return max;    &#125;    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置    private void sink(int k)&#123;        //将当前结点k与其较大的一个子结点对比，如果当前结点k小，则交换位置父子双方双方位置        while(2*k&lt;=N)&#123;            //当前结点无左子节点时停止循环            int max;            //找出左右子结点中最大的一个，并存入max            if (2*k+1&lt;=N)&#123;//当前结点是否有右结点                if (less(2*k,2*k+1))&#123;                    max = 2*k+1;                &#125;else&#123;                    max = 2*k;                &#125;            &#125;else &#123;                max = 2*k;            &#125;            //判断max是否小于当前结点            if (!less(k,max))&#123;                break;            &#125;            exch(k,max);//交换k与max的位置            k = max;//并改变下次循环时k的值为max，进行后续的下沉循环操作        &#125;    &#125;    //插入要上浮，删除要下沉    //往堆中插入一个元素    public void insert(T t)&#123;        items[++N]=t;        swim(N);//插入一个大的数值会影响堆内的顺序，故需要将元素置于一个恰当的位置    &#125;    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置    private void swim(int k)&#123;        while (k&gt;1)&#123;            if (less(k/2,k))&#123;//比较k结点与其父节点的大小                exch(k/2,k);//将k与其父节点交换位置            &#125;            k = k / 2;//比较与交换结束后更新k的位置为其父结点        &#125;    &#125;    public static void main(String[] args) &#123;            Heap&lt;String&gt; heap = new Heap&lt;String&gt;(20);            heap.insert(&quot;A&quot;);            heap.insert(&quot;B&quot;);            heap.insert(&quot;C&quot;);            heap.insert(&quot;D&quot;);            heap.insert(&quot;E&quot;);            heap.insert(&quot;F&quot;);            heap.insert(&quot;G&quot;);            String del;            while((del=heap.delMax())!=null)&#123;                System.out.print(del+&quot;,&quot;);            &#125;        &#125;&#125;</code></pre><p>#堆排序</p><p>创建一个新数组，在其索引1（包含索引1）处往后对原数组进行复制，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后 对扫描到的每一个元素做下沉操作。</p><pre><code class="java">package cn.three.cloth.heap;import java.util.Arrays;public class HeapSort1 &#123;    //调用此方法使用堆排序（从小到大排序）    public static  void sort(Comparable[] source) &#123;        Comparable[] heap = new Comparable[source.length+1];//创建一个大小为传入数组length+1的数组（此数组0索引下不添加数据）        createHeap(source,heap);//创建堆        int N = heap.length-1;//定义一个变量，记录未排序的元素中最大的索引        //通过循环将小的元素排列在前        while(N!=1)&#123;            exch(heap,1,N);//交换元素            N--; //排序交换后最大元素所在的索引，不参与此后的堆下沉            sink(heap,1, N);//需要对索引1处的元素进行对的下沉调整        &#125;        //用排序好的数据覆盖原数组        System.arraycopy(heap,1,source,0,source.length);    &#125;    private static  boolean less(Comparable[] heap, int i, int j) &#123;        return heap[i].compareTo(heap[j])&lt;0;        //heap[i]小于heap[j]时返回True，否则返回false        //compareTo根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。    &#125;    //交换位置    private static  void exch(Comparable[] heap, int i, int j) &#123;        Comparable tmp = heap[i];        heap[i] = heap[j];        heap[j] = tmp;    &#125;    //构造堆进行排序    private static void createHeap(Comparable[] source, Comparable[] heap) &#123;        //复制数组source从下标0开始，复制到heap数组从索引1开始的位置往后        System.arraycopy(source,0,heap,1,source.length);        for (int i = (heap.length)/2;i&gt;0;i--)&#123;//从最后一个非叶结点开始下沉操作，直到所有非叶结点下沉完毕            sink(heap,i,heap.length-1);        &#125;        //循环结束后将得到一个有序的堆（自根结点元素依次减小）    &#125;    //在heap堆中，对target处的元素做下沉    //下沉之后大的元素在前.    private static void sink(Comparable[] heap, int target, int range)&#123;        while(2*target&lt;=range)&#123;//当前结点无左子节点时停止循环            //1.找出当前结点的较大的子结点            int max = 2*target;            if (2*target+1&lt;=range)&#123;                if (less(heap,2*target,2*target+1))&#123;                    max = 2*target+1;                &#125;            &#125;            //2.比较当前结点的值和较大子结点的值            if (less(heap,target,max))&#123;                //小于则交换父子结点位置                exch(heap,target,max);                target = max;            &#125;else &#123;                break;//大于则退出下沉循环            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        String[] arry =&#123;&quot;a&quot;,&quot;d&quot;,&quot;b&quot;,&quot;s&quot;,&quot;Z&quot;,&quot;z&quot;&#125;;        HeapSort1.sort(arry);        System.out.println(Arrays.toString(arry));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> dataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2022/03/20/Javadm-02/"/>
      <url>2022/03/20/Javadm-02/</url>
      
        <content type="html"><![CDATA[<p>最简单的设计模式，它是一种仅提供一个对象实例的方法。</p><pre><code class="java">interface Resource &#123;    int getValue();    void setValue(int x);&#125;/** 由于这不是从Cloneable基类继承而且没有添加可克隆性，* 因此将其设置为final可防止通过继承添加可克隆性。* 这也实现了线程安全的延迟初始化：*/final class Singleton &#123;    private static final class ResourceImpl implements Resource &#123;        private int i;        private ResourceImpl(int i) &#123;//只有一个私有构造器供静态内部类调用            this.i = i;        &#125;        /*两个属性*/        public synchronized int getValue() &#123;            return i;        &#125;        public synchronized void setValue(int x) &#123;            i = x;        &#125;    &#125;    private static class ResourceHolder &#123;        private static Resource resource = new ResourceImpl(47);    &#125;    public static Resource getResource() &#123;//此公共静态方法供外部调用，返回对象        return ResourceHolder.resource;    &#125;&#125;public class SingletonPattern &#123;    public static void main(String[] args) &#123;        Resource r = Singleton.getResource();        System.out.println(r.getValue());        Resource s2 = Singleton.getResource();        s2.setValue(9);        System.out.println(r.getValue());        try &#123;                  // 不能这么做，会发生：compile-time error（编译时错误）.                  // Singleton s3 = (Singleton)s2.clone();                 &#125; catch(Exception e) &#123;                       throw new RuntimeException(e);                 &#125;          &#125;&#125; /* Output: 47 9 */</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="2022/03/20/Javadm-01/"/>
      <url>2022/03/20/Javadm-01/</url>
      
        <content type="html"><![CDATA[<p>将代理对象在生命周期内从一个实现切换到另一种实现</p><pre><code class="java">package cn;//patterns/StateDemo.java //状态模式的简单演示interface StateBase &#123;    void f();    void g();    void h();    void changeImp(StateBase newImp);&#125;/** * 多个操作类，多个代理类; * 一个共同接口一脉相承，中途变法自家兄弟*/class State implements StateBase &#123;    private StateBase implementation;    State(StateBase imp) &#123;        implementation = imp;//引用new Implementation1() new Implementation2()    &#125;    @Override    public void changeImp(StateBase newImp) &#123;        implementation = newImp;    &#125;     @Override    public void f() &#123;         implementation.f();    &#125;    @Override    public void g() &#123;        implementation.g();    &#125;    public void h() &#123;        implementation.h();    &#125;&#125;class Implementation1 implements StateBase &#123;    @Override    public void f() &#123;        System.out.println(&quot;Implementation1.f()&quot;);    &#125;    @Override    public void g() &#123;        System.out.println(&quot;Implementation1.g()&quot;);    &#125;    @Override    public void h() &#123;        System.out.println(&quot;Implementation1.h()&quot;);    &#125;    @Override    public void changeImp(StateBase newImp) &#123;        //改变传入的参数，即改变private StateBase implementation字段的引用，以达到在代理对象的生命周期内从一个实现切换到另一种实现的目的    &#125;&#125;class Implementation2 implements StateBase &#123;    @Override    public void f() &#123;        System.out.println(&quot;Implementation2.f()&quot;);    &#125;    @Override    public void g() &#123;        System.out.println(&quot;Implementation2.g()&quot;);    &#125;    @Override    public void h() &#123;        System.out.println(&quot;Implementation2.h()&quot;);    &#125;    @Override    public void changeImp(StateBase newImp) &#123;    &#125;&#125;public class StateDemo &#123;    static void test(StateBase b) &#123;        b.f();        b.g();        b.h();    &#125;    public static void main(String[] args) &#123;        StateBase b = new State(new Implementation1());        test(b);        b.changeImp(new Implementation2());//注意此时传入的对象        test(b);        b.changeImp(new Implementation1());        test(b);    &#125;&#125;/* Output:Implementation1.f()Implementation1.g()Implementation1.h()Implementation2.f()Implementation2.g()Implementation2.h()Implementation1.f()Implementation1.g()Implementation1.h()*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="2022/03/20/Javadm-03/"/>
      <url>2022/03/20/Javadm-03/</url>
      
        <content type="html"><![CDATA[<p>只要代理对象以某种方式代表具体实现的方法调用，那么基本思想就算实现了。而，拥有一个公共接口是很方便的，因此具体实现必须实现代理对象调用的所有方法。</p><pre><code class="java">// patterns/ProxyDemo.java// Simple demonstration of the Proxy patterninterface ProxyBase &#123;    void f();    void g();    void h();&#125;class Proxy implements ProxyBase &#123;    private ProxyBase implementation;//这是一个私有字段    Proxy() &#123;        implementation = new Implementation();//创建所代理类（Implementation）的对象    &#125;    /*覆盖方法并调用所代理类（Implementation）的方法*/    @Override    public void f() &#123; implementation.f(); &#125;    @Override    public void g() &#123; implementation.g(); &#125;    @Override    public void h() &#123; implementation.h(); &#125;&#125;class Implementation implements ProxyBase &#123;    /*与代理类实现同一个接口,必须实现（覆盖）接口中所有方法哦/    @Override    public void f() &#123;        System.out.println(&quot;Implementation.f()&quot;);    &#125;    @Override    public void g() &#123;        System.out.println(&quot;Implementation.g()&quot;);    &#125;    @Override    public void h() &#123;        System.out.println(&quot;Implementation.h()&quot;);    &#125;&#125;public class ProxyDemo &#123;    public static void main(String[] args) &#123;        Proxy p = new Proxy();        p.f();        p.g();        p.h();    &#125;&#125;/*Output:Implementation.f()Implementation.g()Implementation.h()*//*总结：1.代理模式中通常代理类与被代理类实现一个公共接口利于交流。2.在创建代理类对象的时，被代理类的对象也将同时创建（因为new被代理类写在代理类的构造器中）并为代理类的一个私有变量引用3. so，想要调用被代理类的方法只需使用代理类 私有变量.被代理类的方法 （即在代理类中使用方法调用被代理类的方法）*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/c%E2%95%93%E2%95%95%E2%95%92%CE%B4%E2%95%A1%E2%94%80%E2%94%A4%C2%BD%E2%95%A1%E2%96%8C/"/>
      <url>2022/03/20/c%E2%95%93%E2%95%95%E2%95%92%CE%B4%E2%95%A1%E2%94%80%E2%94%A4%C2%BD%E2%95%A1%E2%96%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="c指针的传递"><a href="#c指针的传递" class="headerlink" title="c指针的传递"></a>c指针的传递</h1><h2 id="作为函数参数传递"><a href="#作为函数参数传递" class="headerlink" title="作为函数参数传递"></a>作为函数参数传递</h2><p>真正的传入一个指针到函数中</p><p><img src="http://img.lbkzw.cn/img/image-20210827171357110.png" alt="image-20210827171357110"></p><p>间接的传入指针到函数中</p><p><img src="http://img.lbkzw.cn/img/image-20210827171451818.png" alt="image-20210827171451818"></p><p>p1就是指针p，而p2是一个新的指针</p><p>以下分别为指针p、p1、p2的地址：</p><p><img src="http://img.lbkzw.cn/img/image-20210827171611554.png" alt="image-20210827171611554"></p><h2 id="作为变量传递"><a href="#作为变量传递" class="headerlink" title="作为变量传递"></a>作为变量传递</h2><ol><li>直接改变变量的值</li></ol><p><img src="http://img.lbkzw.cn/img/image-20210827172216274.png" alt="image-20210827172216274"></p><ol start="2"><li>间接改变变量的值</li></ol><p>这里改变的是指针p2中存储的地址的值，而不是p2中所存储地址对应内存的值</p><p>举个例子：</p><p>目的：我们想将小明称为小红</p><p>做法：</p><ol><li>直接将将小明改名为小红，那么身份证上写的也是小红，但小明他还是那个小明。</li><li>直接找来了小红，说她是小明变的。</li></ol><p>做法1就是直接改变变量的值，做法2就是间接改变变量的值</p><p><img src="http://img.lbkzw.cn/img/image-20210827172151988.png" alt="image-20210827172151988"></p><p>测试程序：</p><pre><code class="c">/* * @Author: itThree * @Date: 2021-08-27 13:59:28 * @LastEditTime: 2021-08-27 17:11:14 * @Description:  * @FilePath: \cpp\testcpp\swapWithPointers.cpp * 光阴之逆旅，百代之过客，而已 */#include&lt;stdio.h&gt;//传入指针p,参数int* &amp;p解析指针地址//就是说传入的是真正的指针pvoid testp1(int* &amp;p1)&#123;    int num1 = 2020;    //将p1地址对应内存下的值直接改变；    *p1 = num1;    printf(&quot;%d,%d,%d,%p\n&quot;,p1,*p1,num1,&amp;p1);&#125;//传入指针p,参数int* p初始化并指向传入的指针//就是说初始化一个指针指向指针p所指向的东西void testp2(int* p2)&#123;   int num2 = 2019;   //将p2指向num2的地址   p2 = &amp;num2;   printf(&quot;%d,%d,%d,%p\n&quot;,p2,*p2,num2,&amp;p2);   &#125;int main()&#123;    // int x = 1;    // int y = 2;    // //传入x,y的地址，交换其值的位置    // swapWithPointers(&amp;x,&amp;y);    // printf(&quot;x=%d\ty=%d&quot;,x,y);    int num = 2021;    int* p = &amp;num;    printf(&quot;初始值:\n&quot;);    printf(&quot;%d,%d,%d,%p\n&quot;,p,*p,num,&amp;p);    printf(&quot;经过test1:\n&quot;);    testp1(p);    printf(&quot;经过test2:\n&quot;);    testp2(p);    //从结果可以看出test1真正的改变了num的值，而test2仅是将指针指向了另一个地址    printf(&quot;最终:\n&quot;);    printf(&quot;%d,%d,%d,%p\n&quot;,p,*p,num,&amp;p);        return 0;&#125;</code></pre><p>运行结果：</p><p><img src="http://img.lbkzw.cn/img/image-20210827172030142.png" alt="image-20210827172030142"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/java-mybatis-01/"/>
      <url>2022/03/20/java-mybatis-01/</url>
      
        <content type="html"><![CDATA[<p>#基础支持层</p><h2 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h2><p>常见的三种解析方式： DOM SAX StAX</p><p>DOM整体将XML整体解析为树状样式</p><p>优点：便于获取数据，如在父子兄弟节点间切换很自然</p><p>缺点：占用资源较大</p><p>SAX基于事件模型的解析方式，解析时只将xml的一部分加载到内存，可在任一节点注册回调函数。</p><p>解析器解析到此节点（注册回调函数的节点）时会通过回调函数将事件发送给应用程序（推模式）</p><p>StAx同SAX将XML作为一个事件流处理，应用程序调用调用解析器进行解析，最后解析器返回结果</p><p>优点：占用资源小</p><p>缺点：只能向后单向进行无法支持XPath（查询XML文档）</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.ibatis.builder.xml;import java.io.IOException;import java.io.InputStream;import java.util.Locale;import org.apache.ibatis.io.Resources;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;public class XMLMapperEntityResolver implements EntityResolver &#123;    ////mybatis-config文件与指定文件的SystemId    private static final String IBATIS_CONFIG_SYSTEM = &quot;ibatis-3-config.dtd&quot;;    private static final String IBATIS_MAPPER_SYSTEM = &quot;ibatis-3-mapper.dtd&quot;;    private static final String MYBATIS_CONFIG_SYSTEM = &quot;mybatis-3-config.dtd&quot;;    private static final String MYBATIS_MAPPER_SYSTEM = &quot;mybatis-3-mapper.dtd&quot;;    //mybatis-config.xml文件位置    private static final String MYBATIS_CONFIG_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;;    //映射文件位置    private static final String MYBATIS_MAPPER_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;;    public XMLMapperEntityResolver() &#123;    &#125;        //查找指定的dtd文档调用getInputSource读取文档    public InputSource resolveEntity(String publicId, String systemId) throws SAXException &#123;        try &#123;            if (systemId != null) &#123;                //将传入的SystemId转为小写                String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);                                if (lowerCaseSystemId.contains(&quot;mybatis-3-config.dtd&quot;) || lowerCaseSystemId.contains(&quot;ibatis-3-config.dtd&quot;)) &#123;                    return this.getInputSource(&quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;, publicId, systemId);                &#125;                if (lowerCaseSystemId.contains(&quot;mybatis-3-mapper.dtd&quot;) || lowerCaseSystemId.contains(&quot;ibatis-3-mapper.dtd&quot;)) &#123;                    return this.getInputSource(&quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;, publicId, systemId);                &#125;            &#125;            return null;        &#125; catch (Exception var4) &#123;            throw new SAXException(var4.toString());        &#125;    &#125;//读取dtd文档生成InputSource对象    private InputSource getInputSource(String path, String publicId, String systemId) &#123;        InputSource source = null;        if (path != null) &#123;            try &#123;                InputStream in = Resources.getResourceAsStream(path);                source = new InputSource(in);                source.setPublicId(publicId);                source.setSystemId(systemId);            &#125; catch (IOException var6) &#123;            &#125;        &#125;        return source;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo for github的那些事情</title>
      <link href="2022/03/20/hexo-01/"/>
      <url>2022/03/20/hexo-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先申明：本篇并非安装hexo的教程，而是本人安装hexo时遇到的一些问题及解决方案。<br><strong>一站式部署hexo教程：</strong><a href="https://hexo.io/zh-cn/docs/">官方文档</a><br>本人操作均按hexo<a href="https://hexo.io/zh-cn/docs/">官方文档</a>进行。<br>按官方文档来，问题会比按网上的帖子少的多，且你遇到的问题一定有人已经遇到过，百度搜索你遇到的错误就很容易解决</p></blockquote><h2 id="官方第一坑"><a href="#官方第一坑" class="headerlink" title="官方第一坑"></a>官方第一坑</h2><p>官方文档中用gh-pages分支，可是全程没有提到，仅仅用到的时候才提到，这个会出问题，不如从一开始就在gh-pages分支上进行</p><h3 id="创建gh-pages分支"><a href="#创建gh-pages分支" class="headerlink" title="创建gh-pages分支"></a>创建gh-pages分支</h3><p><strong>创建分支时主分支的版本库不能为空</strong></p><pre><code class="git">git init //创建本地库git branch -v //查看分支vim index.html //创建文件（为win10用户请自行手动创建一个文件，仅仅提交版本库用）git add .git branch gh-pages//创建分支</code></pre><h2 id="官方第二坑"><a href="#官方第二坑" class="headerlink" title="官方第二坑"></a>官方第二坑</h2><p>文档没有明明白白的说<code>deploy:</code>的填写<br><code>_config.yml</code>中<code>deploy:</code>一定要填写好：</p><pre><code class="hexo">deploy:  type: &#39;git&#39;  repo: 你远程库的ssh地址  branch: gh-pages//分支名</code></pre><h2 id="hexo命令易懂叙述："><a href="#hexo命令易懂叙述：" class="headerlink" title="hexo命令易懂叙述："></a>hexo命令易懂叙述：</h2><pre><code class="hexo">hexo g //生成网页hexo s //本地预览（部署网站到本地，测试用啦）hexo d //部署网站到远程库hexo clean //清除缓存（网页缓存）hexo clean&amp;&amp;hexo g&amp;&amp;hexo s //连招，清除缓存生成网页并开启本地预览hexo clean&amp;&amp;hexo g&amp;&amp;hexo d //连招，清除缓存生成网页并部署到远程库</code></pre><h2 id="我用到的一些git命令："><a href="#我用到的一些git命令：" class="headerlink" title="我用到的一些git命令："></a>我用到的一些git命令：</h2><pre><code class="git">git add . //添加所有到版本库git commit -m&quot;1&quot; //提交到本地库git push blog gh-pages --force //本地库覆盖远程库git config --global user.email xxx@163.com //本地标识</code></pre><h2 id="我遇到的一些错误："><a href="#我遇到的一些错误：" class="headerlink" title="我遇到的一些错误："></a>我遇到的一些错误：</h2><p><code> 执行 hexo deploy 后,出现 error deployer not found:github 的错误</code><br><strong>解决方案：</strong><br><code>npm install hexo-deployer-git --save</code></p><p><strong>忘记遇到的什么问题了：</strong><code>npm install hexo-renderer-pug hexo-renderer-stylus </code></p><p>  ps：博客，电脑访问不了的话，可以换手机试试。最经网络老抽风无法访问github.io后缀的域名</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2022/03/20/javadm-04/"/>
      <url>2022/03/20/javadm-04/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试时，程序运行的成功与否并不依靠返回值、打印语句来判断;通常我们使用断言而非print来展示返回值</p><pre><code class="java">Assert.assertEquals(-1,value)//预测变量value的值为-1assert i &lt; 50:i;//断言i的值小于50（如i大于等于50将发生异常并返回实际i的值）</code></pre><p>idea中运行结果为绿色就是运行成功，红色则失败。</p><p><code>@Before</code>在测试方法前自动执行，通常用来申请资源</p><p><code>@After</code>在测试方法后自动执行，通常用来释放资源</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote><pre><code class="java">import java.lang.annotation.*;//元注解：对注解进行注解@Target(ElementType.TYPE)//该注解可以被写在什么位置，取值如：类、方法、字段、包等@Retention(RetentionPolicy.RUNTIME)//表明注解保留的时间段如：运行时即存入字节码并为JVM所接收、仅保留到字节码、保留到编译时（前）@Documented//注解可以被抽取到javadoc文档中@Inherited//该注解是否可以被继承public @interface MyAnnotation &#123;    String value();    int a();&#125;@MyAnnotation(value = &quot;value&quot;,a=0)public class MyAnnotationTest &#123;&#125;</code></pre><p> 用于描述注解的注解</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>变量&amp;&amp;语法</title>
      <link href="2022/03/20/js-02/"/>
      <url>2022/03/20/js-02/</url>
      
        <content type="html"><![CDATA[<p>函数体内局部变量优先级高于全局变量；</p><p>函数内的变量声明将提升至函数体顶部，同时在原位置完成初始化var声明；</p><p>在for循环中使用var声明变量时，该变量的作用域为for循环所属函数。</p><pre><code class="js"> var a=[];   for(var i = 0;i&lt;10;i++)&#123;       var q = i;      a[i]=function()&#123;console.log(q)&#125;   &#125;   a[0]()         /*其中，由于for循环并不是一个函数体，所以for循环中定义的变量q和i是作用域for循环所在的函数体，和a同级，  i++ 和  q=i 并不是重新定义变量，只是重复赋值，最终循环结束，i = 10,q=9; */ </code></pre><p>let声明的变量，只在let所在的代码块有效果</p><pre><code class="js">1.  var a=[];  2.  for(let i = 0;i&lt;10;i++)&#123;  3.     ley q = i;  4.     a[i]=function()&#123;console.log(q)&#125;  5.  &#125;  6.  a[6]()    //这里会输出   6  let声明的变量仅在块级作用域有效，所以这里的i只在本轮循环有效果，每次循环的i其实都是一个新的变量</code></pre><h1 id="function-声明"><a href="#function-声明" class="headerlink" title="function 声明"></a>function 声明</h1><pre><code class="js">/*定义一个函数 *///one:function mysqrt(x)&#123;//使用此声明则函数名与函数初始化块均“提前”到脚本或函数的顶部    return Math.sqrt(x*x);    &#125;//twovar mysqrt = function(x)&#123;return Math.sqrt(x*x);&#125;//使用此声明则仅有变量声明“提前”到脚本或函数的顶部，初始化体仍在原来的位置</code></pre><h1 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h1><ul><li>for-in 会跳过null、undefined</li><li>只遍历可枚举的（包含继承的属性名）</li></ul><pre><code class="js">/*使用for-in 变量数组元素 */var o = &#123;x:1,y:2,z:3&#125;var a = [],i = 0//声明一个数组与一个变量for(a[i++]in o); </code></pre><h1 id="continue-break"><a href="#continue-break" class="headerlink" title="continue,break"></a>continue,break</h1><p>带标签的continue,break作用相同，均是跳转到指定循环（均不得跳转至所属函数边界，即所属函数外）</p><pre><code class="js">mainloop: while(token!=null)&#123;    continue mainloop;&#125;mainloop: while(token!=null)&#123;    break mainloop;//mainloop为自定义标记&#125;</code></pre><h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h1><p>检索对象列表，解析变量名</p><pre><code>/*用于简化代码*/with(document.forms[0])&#123;    name.value=&quot;&quot;;    address.value=&quot;&quot;;    email.value=&quot;&quot;;&#125;/*简化前*/var f = document.form[0];f.name.value=&quot;&quot;;f.address.value=&quot;&quot;;f.email.value=&quot;&quot;;</code></pre><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="严格相等"><a href="#严格相等" class="headerlink" title="===严格相等"></a>===严格相等</h2><ul><li>比较过程中没有类型的转换，两个值类型不同则其不等</li><li>值为null或undefined则其不等</li><li>均是相同的布尔值则相等</li><li>其中一个值为NaN则不等**</li></ul><h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><ul><li>值为null或undefined则其相等</li><li>两个不同类型的值转换后相等则其相等（如：true转换为1 false转换为0 再进行比较）</li></ul><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><ul><li>左操作数是一个字符串或可以转换为字符串，有操作数是一个对象</li><li>如右侧对象包含左侧操作数，表达式返回true</li></ul><pre><code class="js">var a = &#123;x:a&#125;&quot;x&quot; in a; //true</code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ul><li>如左侧对象是右侧类的实例，表达式将返回true</li></ul><pre><code class="js">var mynew = new Date();mynew instanceof Date;//返回true</code></pre><h1 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a>null、undefined</h1><ul><li>null是一个特殊对象（非对象），多用来表示字符串、数字、对象得无值。</li><li>undefined（未定义） 表示属性或元素不存在</li><li>===可区分null与undefined，而==则不行</li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code class="js">x+&quot;&quot;//等价于String(x)+x//等价于Number(x)!!x//等价于Boolean(x)</code></pre><p><strong>对象向字符串转换</strong></p><p>有toString则通过此方法将其变为字符串，无toString则通过ValueOf，二者均无则报错。</p><p>空数组向数值转换结果为0</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul><li>throw 抛出异常</li></ul><pre><code class="js">try&#123;/*可能出现异常的代码*/&#125;catch()&#123;/*对异常的处理*/&#125;finally&#123;/*不管发不发生异常都执行的语句*/&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS函数</title>
      <link href="2022/03/20/js-03/"/>
      <url>2022/03/20/js-03/</url>
      
        <content type="html"><![CDATA[<p>函数方法（方法体同声明均提升到顶部位置）</p><pre><code class="JavaScript">function printprops(o)&#123;            for(var p in o)&#123;                console.log(p + &quot;:&quot; + o[p] + &quot;\n&quot;);            &#125;        &#125;//返回nudefined</code></pre><p>函数表达式（方法体原地保留、仅提前声明）</p><pre><code class="javascript">        var f = function(x)&#123;return x*x;&#125;//适合做只用一次的函数</code></pre><p>函数中声明的变量仅在函数体内可见，因此可用函数来声明局部变量（也可通过let方法声明局部块）</p><pre><code class="javascript">        (function()&#123;/*局部变量*/&#125;());//结束并立即调用函数</code></pre><p>函数是特殊的对象，所以也可拥有属性、方法，还可使用Function构造函数对象</p><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><ul><li><p>省略的实参都是undefined，多出的参数自动省略</p></li><li><p>函数可赋值给变量、存储在数组、对象属性中（称为方法），还可作为参数传入另一函数</p><pre><code class="javascript">/**函数赋值于变量*/function square(x)&#123;return x*x;&#125;var s = square;/**函数作为对象属性，此时叫方法*/var o=&#123;square:function(x)&#123;return x*x;&#125;&#125;;/*函数存储在数组中*/var a = [function(x)&#123;return x*x;&#125;,20];a[0](a[1]);//看似nb的直接量调用a0的括号中装上a1，哈哈</code></pre></li><li><p>内部函数可使用外部函数的参数和变量</p><pre><code class="javascript">function hypotenuse(a,b)&#123;            function square(x)&#123;return x*x;&#125;            return Math.sqrt(square(a)+square(b))    //调用square函数时，传入了外部函数的a,b参数        &#125;</code></pre></li></ul><h2 id="函数作为对象方法"><a href="#函数作为对象方法" class="headerlink" title="函数作为对象方法"></a>函数作为对象方法</h2><pre><code class="js">var o =&#123;            m:function()&#123;//函数作为对象方法                var self = this;//指代对象O                console.log(this====o);                f();                function f()&#123;//嵌套函数                    console.log(this===o);//这里的this不是O                    console.log(self===o);                &#125;            &#125;        &#125;;        o.m();</code></pre><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><pre><code class="javascript">var o = new Object();//无参数构造函数var o = new Object;//无参数构造函数</code></pre><h1 id="实参对象"><a href="#实参对象" class="headerlink" title="实参对象"></a>实参对象</h1><ul><li><p>arguments标识符指向实参对象引用</p><pre><code class="javascript">function f(x)&#123;            console.log(x);            arguments[0]=null;//修改参数x            console.log(x);        &#125;</code></pre><h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><ul><li><p>指代当前执行的函数</p><pre><code class="javascript">    var factorial = function(x)&#123;            if(x&lt;=1)return 1;            return x*arguments.callee(x-1);//递归调用        &#125;</code></pre></li></ul></li></ul><ul><li><p>接收任意数量的实参</p><pre><code>function max(/*number...*/)&#123; &#125;</code></pre></li></ul><h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><pre><code class="javascript">uniquelnteger.counter = 0;//为函数属性设置初始值function uniquelnteger()&#123;    return uniquelnteger.counter++;&#125;/**作为数组储存*/function factorial(n)&#123;            if(isFinite(n)&amp;&amp;n&gt;0&amp;&amp;n===Math.round(n))&#123;                if(!(n in factorial))//判断n在不在                factorial[n]=n*factorial(n-1);//计算并存储a                return factorial[n];            &#125;else return NaN;        &#125;factorial[1]=1</code></pre><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><pre><code class="javascript">var scope = &quot;global scope&quot;;        function checkscope()&#123;            var scope = &quot;local scope&quot;;            function f()&#123;return scope;&#125;            return f();        &#125;        checkscope();//返回局部变量值local scope/**************类似java对象之间的闭包性*******************/function counter()&#123;            var n = 0;            return&#123;                count:function()&#123;return n++;&#125;,                reset:function()&#123;n = 0;&#125;            &#125;;        &#125;        var c = counter(),d = counter();//即分别创建两个作用域链        c.count(),d.count();//初始值都是0，调用后+1        c.reset();//重置c为0，对其中一个作用域lian        c.count(),d.count();//c-0 ，d-1/*******************实现存取器***************///用参数n保存变量值function counter(n)&#123;    return&#123;        get count()&#123;return n++;&#125;,        set count(m)&#123;            if(m&gt;=n)n=m;            else throw Error(&quot;count can only be set to a larger value&quot;);        &#125;    &#125;;&#125;var c = counter(1000);c.count;c.count;//访问（读）操作c.count = 2000;//写操作/********访问实例：********//*错误的闭包示范*/        function constfuncs()&#123;            var funcs=[];            for(var i=0;i&lt;10;i++)            funcs[i]=function()&#123;return i;&#125;;//闭包内的i是同一个i，即最终i=10            return funcs;//最终返回10        &#125;        var funcs=constfuncs();        funcs[5]()//10/*正确的闭包示范*/            function constfuncs(v)&#123;return function()&#123;return v;&#125;;&#125;        var funcs =[];        for(var i = 0 ;i&lt;10; i++)funcs[i]=constfuncs(i);//在闭包外每个i都是不同的i        funcs[5]()//5</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call( ),apply( )"></a>call( ),apply( )</h2><pre><code class="javascript">f.call(o);//以对象o的方法形式调用函数ff.apply(o);f.call(o ,1,2)//以对象o的方法形式调用函数f，并传入参数f.apply(o,[1,2]);</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind( )"></a>bind( )</h2><ul><li><p>绑定，一个函数调用bind( )方法，并传入一个对象，那么bind( )方法会返回一个新的函数，调用新的函数即可把原函数当作传入对象的方法来使用</p><pre><code class="javascript">function f(y)&#123;return this.x+y;&#125;;//函数var o =&#123;x:1;&#125;;//对象var g = f.bind(o);//新函数g(2);//调用新函数</code></pre></li></ul><h1 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h1><ul><li>每次调用**Function( )**就会创建新对象</li></ul><pre><code class="javascript">var f = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x*y&quot;);//等同于 var f=function(x,y)&#123;return x*y&#125;</code></pre><ul><li>Function( )构建对象的函数体编译会在顶层函数（全局作用域）进行</li></ul><pre><code class="javascript">var scope = &quot;hello&quot;;function a()&#123;var scope = &quot;world&quot;;return new Function(&quot;return scope&quot;);&#125;a()();//返回hello</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象</title>
      <link href="2022/03/20/js-04/"/>
      <url>2022/03/20/js-04/</url>
      
        <content type="html"><![CDATA[<h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><ul><li>字符串、布尔值、数字等可通过包装器，构造一个临时对象</li><li>必要时，js会进行包装器与字符串、数字、布尔值的相互转换</li></ul><pre><code class="js">var a = &quot;hello&quot;;var word = a.substring(a.indexOf(&quot;&quot;)+1,a.length);//结果word=ello//substring() 方法用于提取字符串中介于两个指定下标之间的字符。//indexOf() 方法返回某个指定的字符串值在字符串中首次出现的位置。</code></pre><h1 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h1><pre><code class="js">/*像py里的字典*/var book =&#123;    &quot;main title&quot;:&quot;The Definitive Guide&quot;,    &quot;author&quot;:&quot;David Flanagan&quot;&#125;;//对象直接量的原型为constructor.prototype</code></pre><h1 id="new创建对象"><a href="#new创建对象" class="headerlink" title="new创建对象"></a>new创建对象</h1><pre><code class="js">var mydate = new Date();//new+构造函数创建对象 </code></pre><h1 id="删除、查询、添加、继承"><a href="#删除、查询、添加、继承" class="headerlink" title="删除、查询、添加、继承"></a>删除、查询、添加、继承</h1><pre><code class="js">/*添加、查询对象属性 */ var customer=&#123;a1:&quot;1&quot;,a2:&quot;2&quot;,a3:&quot;3&quot;&#125; var addr=&quot;&quot;; for(i=0;i&lt;4,i++)&#123;//拼接customer属性     addr+=customer[&quot;a&quot;+i]+&#39;\n&#39; &#125; customer.a4 =&#39;4&#39;;//为customer创建一个名为a4的属性，值为4 customer[a5]=&quot;5&quot;//为customer创建一个名为a5的属性，值为5 var mynumber =customer.a4;//查询customer的a4属性，并将其赋值于此变量/*继承对象、删除对象属性*/ var o = &#123;&#125; o.x = 1; var p = inherit(o);//继承对象，包含其toString方法与属性 p.y = 2; delete p.x;//delete无法删除对象继承的属性，可直接在其父上操作 delete o.x; var q = inherit(p); q.z = 3; var s = q.toString();/*delete:用来删除对象属性（包含数组元素），也可删除未使用var声明的变量包含（this.的全局变量）*/</code></pre><h1 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h1><ul><li><p>读取、写入、可枚举、可配置</p></li><li><p>只有getter方法，就是只读属性</p></li><li><p>只有setter方法 ，就是只写属性  </p></li></ul><pre><code class="js">/*直接定义存储器属性*/var random = &#123;    get octet()&#123;        return Math.floor(Math.random() *256);    &#125;,    get uint16()&#123;        return Math.floor(Math.random() *65536);    &#125;,    get int16()&#123;        return Math.floor(Math.random() *65536)-32768;    &#125;&#125;;</code></pre><pre><code class="js">/*老式api*/__lookupGetter__(),__lookupSetter__()//返回属性的getter与setter方法；__defineSetter__(),__defineGetter__()//定义属性的getter与setter方法；//有两个参数，第一个为属性名字，第二个是getter与seeter方法</code></pre><h2 id="设置属性特性"><a href="#设置属性特性" class="headerlink" title="设置属性特性"></a>设置属性特性</h2><p><strong>属性特性</strong>  包括：值、可写性、可枚举性、可配置性，分别对应：value,writable,enumerable,configurable</p><pre><code class="js">/** * 设置属性特性 *//*单个 */var o =&#123;&#125;;Object.defineProperty(o,&quot;x&quot;,&#123;value:1,writable:true,enumerable:false,configurable:true&#125;);//Object.defineProperty方法修改自己已有属性或创建自有属性，不可修改继承属性Object.keys(o);//将o.x属性变为只读o.x =2 ;//操作失败Object.defineProperty(o,&quot;x&quot;,&#123;value:2&#125;);/*多个 */var p = Object.defineProperties(&#123;&#125;,&#123;x:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,    y:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,    r:&#123;get:function()&#123;return Math.sqrt(this.x*this.x+this.y*this.y)&#125;,enumerable:true,configurable:true&#125;&#125;);/*复制属性特性 */Object.defineProperty(Object.prototype,&quot;extend&quot;,/*定义Object.prototype.extend*/&#123;writable:true,enumerable:false,configurable:true,value:function(o)&#123;    var names = Object.getOwnPropertyNames(o);//得到所有自由属性包括不可枚举属性    for (var i = 0; i&lt; names.length; i++)&#123;        if(names[i]in this)continue;//如果属性已存在，则跳过        var desc = Object.getOwnPropertyDescriptor(o,names[i]);//为this创建一个属性        Object.defineProperty(this,names[i],desc);    &#125;&#125;&#125;);</code></pre><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><ul><li>获取对象的属性描述</li></ul><pre><code class="js">对于继承属性与不存在属性均返回undefined</code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><ul><li>修改已创建对象的属性特性，不能修改继承属性</li></ul><pre><code class="js">/*用法：Object.defineProperty(操作对象，属性名，&#123;属性描述符对象：value,writable,enumerable,configurable&#125;)*/var o =&#123;&#125;;Object.defineProperty(o,&quot;x&quot;,&#123;value:1,writable:true,enumerable:false,configurable:true&#125;);//为对象O创建一个不可枚举的属性x//修改或创建完成后返回新的对象</code></pre><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><ul><li>同时修改多个对象属性特性，不能修改继承属性</li></ul><pre><code class="js">var p = Object.defineProperties(&#123;&#125;,&#123;x:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,//p是一个空对象                                    /*为其创建x，y，r属性*/    y:&#123;value:1,writable:true,enumerable:true,configurable:true&#125;,    r:&#123;get:function()&#123;return Math.sqrt(this.x*this.x+this.y*this.y)&#125;,enumerable:true,configurable:true&#125;&#125;);</code></pre><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul><li>通过对象直接量创建的对象使用Object.prototype作为它们的原型</li><li>new创建的对象，prototype作为其原型</li><li>Object.create()创建的对象，使用第一个参数作为其原型（可以是null）</li></ul><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><ul><li>创建</li></ul><pre><code class="js">var p =&#123;x:1&#125;;var o =Object.create(p);//使用原型p创建对象op.isPrototype(o)//o继承至p?Object.prototype.isPrototypeOf(o)//P继承至Object.prototype？</code></pre><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><ul><li>查询对象原型</li></ul><pre><code class="js">var a = &#123;&#125;;Object.getPrototypeOf(a);</code></pre><h1 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h1><ul><li>是否可以添加、删除属性；</li></ul><pre><code class="js">/*将对象传入*/Object.esExtensible()//判断对象是否可扩展Object.isSealed()//检测对象是否封闭（不可扩展）Object.prevenExtensions()//将对象自身转换为不可扩展的（此操作不可逆），其原型添加属性时此对象仍会继承这些属性Object.seal()//与Object.prevenExtensions()类似Object.freeze()//冻结：不可扩展且数据属性设置为只读（setter存储器属性不受影响）Object.isFrozen();//检测是否冻结/*创建一个封闭（不可扩展）对象，包含一个冻结原型一个不可枚举属性*/var o = Object.seal(Object.create(Object.freeze(&#123;x:1&#125;),&#123;y:&#123;value:2,writable:true&#125;&#125;));</code></pre><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><pre><code class="js">/*序列化对象 */o = &#123;x:1,y:&#123;z:[false,null,&quot;&quot;]&#125;&#125;;s = JSON.stringify(o);//序列化对象o（转换为字符串）p = JSON.parse(s);//还原为对象,p是深度复制</code></pre><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组</title>
      <link href="2022/03/20/js-05/"/>
      <url>2022/03/20/js-05/</url>
      
        <content type="html"><![CDATA[<p>Js数组是无类型的，其元素可以为任意类型，也可以是任意对象或数组；</p><p>Js数组是动态的，无需声明其大小，数组长度会根据需要增长与缩减；</p><p>省略的数组直接量将被赋予undefined值；</p><p>数组是对象的特殊形式，所以其可以从原型中继承元素，可以定义元素的getter与setter方法；数组的索引是对象属性名的特殊类型。</p><pre><code class="js">var b = [1,,3]//索引1处值即为undefinedvar c = [,];//空数组，因为数组直接量结尾处的“,”可选加与不加，数组中只有1个“,”时默认为是结尾处的“,”var d = [];//空数组var d = new Array(10);//利用Array()构造函数创建一个预分配大小的数组。</code></pre><pre><code class="js">/*负值与非整数的数组索引，将被转换为字符串，字符串作为属性名使用*/var a = [3.1415926] = pi;var b = [-180] = deg;</code></pre><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><pre><code class="js">a = new Array(5);//a为空数组，但其长度为5b = [];b[1000] = 122;//添加一个元素，数组长度为1001/*length属性小于当前长度时，超出length值-1的元素将被删除。*/b.length = 999;//此时数组为空。/*让数组变为只读*/c = [1,2,3];Object.defineProperty(a,&quot;length&quot;,&#123;writable:false&#125;)//将length属性设置为不可写</code></pre><h1 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h1><p>栈、队列、双端队列的实现。</p><h2 id="push-unshift"><a href="#push-unshift" class="headerlink" title="push(),unshift()"></a>push(),unshift()</h2><blockquote><p>**push()**在尾部添加元素;</p><p>**unshift()**在头部添加元素.</p></blockquote><pre><code class="js">a = [];a.push(&quot;pu&quot;);//与直接量添加a[a.length]=&quot;pu&quot;;效果相同a.unshift(&quot;d&quot;,&quot;j&quot;);//unshif插入元素是一次性插入的，所以不会影响顺序/*delete可删除数组元素（数组是特殊对象），但不改变其长度*/delete a[0];</code></pre><h2 id="pop-shift"><a href="#pop-shift" class="headerlink" title="pop(),shift()"></a>pop(),shift()</h2><ul><li><p>栈的实现（配合push()）：pop() 减少数组1长度（即删除末尾元素），并返回被删除的元素值</p></li><li><p>队列的实现（配合unshift()）：shift()从头部删除一个元素，并将被删除元素以后的元素索引减一（队列，所有人向前走一步）</p></li></ul><p><strong><em>双端队列：push(),unshift() pop(),shift()实现。</em></strong></p><h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><ul><li>一般，调用的函数作为forEach第一个参数，调用函数一般提供3个参数：数组元素、元素索引、数组本身</li><li>forEach只能利用”异常“机制终止遍历</li></ul><pre><code class="js">var data = [1,2,3,4,5,];var sum = 0;data.forEach(function(value)&#123;sum+=value;&#125;);//求和data.forEach(function(v,i,a)&#123;a[i]=v+1;&#125;);//每个元素+1/*终止遍历*/function foreach(a,f,t)&#123;    try&#123;a.forEach(f,t);&#125;    catch(e)&#123;if(e===foreach.break)return;else throw e;&#125;&#125;foreach.break = new Error(&quot;Stoplteration&quot;);</code></pre><h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul><li>将数组组成字符串返回</li></ul><pre><code class="js">/*join */var a = [1,2,3,4]a.join();//默认以“,”分隔a.join(&#39;_&#39;);//自定义元素分隔(_)/*split */var b = &quot;hello World&quot;var c =b.split(正则表达式或字符串);//将字符串分割为若干块并创建一个数组</code></pre><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><ul><li>逆序数组元素（直接在原数组中排序），并返回排序后的数组</li></ul><pre><code class="js">var a = [1,2,3,4]a.reverse()</code></pre><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><ul><li>默认以字母顺序进行排序，且返回排序后的数组</li><li>undefined 元素会被排列到尾部</li><li>自定义排序：sort接受一个比较函数，该函数有两个比较参数，返回小于0的值则第一个参数在前，反之第二个参数在前。</li></ul><pre><code class="js">/*排列数值*/var a = [12,574,88,78];a.sort();a.sort(function(a,b)&#123;return a-b;&#125;)/*排列字符串且不区分大小写*/a = [&#39;ant&#39;,&#39;Bug&#39;,&#39;cos&#39;]a.sort(function(s,t)&#123;var a = s.toLowerCase();var b = t.toLowerCase();if(a&lt;b)return -1;//写小于0的任意值if(a&gt;b)return 1;//写大于0的任意值return 0;//相等返回0&#125;);</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><ul><li>创建并返回新的数组</li><li>如果其参数中包含某个数组则添加其元素，创建并返回新的数组</li></ul><pre><code class="js">var a = new Array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);var b = new Array(&#39;1f&#39;,&#39;2f&#39;,&#39;3f&#39;);a.concat(4,5,6,b);//a = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 4, 5, 6, &quot;1f&quot;, &quot;2f&quot;, &quot;3f&quot;];</code></pre><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><ul><li>返回数组参数指定位置的片段或子数组</li></ul><pre><code class="js">var a = new Array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);a.slice(0,2)//返回[&quot;1&quot;, &quot;2&quot;]，返回第一个参数位置（包含第一个位置）到第2个参数位置前的子数组。</code></pre><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><ul><li>插入或删除数组元素，并返回一个包含已删除元素的数组。</li><li>第一个参数指定了插入或删除的位置，第二个参数指定了删除元素的数量（若是添加则此参数填0）</li></ul><pre><code class="js"> var a =[1,32,95,98,6,,78]; a.splice(2, 0,&#39;f1&#39;);//删除0个在索引2前插入&#39;f1&#39; a.splice(4,1,[1,5,,6],&#39;j&#39;);//在索引4出删除1个元素并插入一个数组[1,5,,6]与一个元素&#39;j&#39;</code></pre><h2 id="toString与toLocaleString"><a href="#toString与toLocaleString" class="headerlink" title="toString与toLocaleString"></a>toString与toLocaleString</h2><ul><li>toString将每个元素转换为字符串，并输出用逗号分隔的字符串列表。</li><li>toLocaleString使用“本地化“版本的toString，将元素转换为字符串并分隔（自定义）</li></ul><h1 id="Es-5数组方法"><a href="#Es-5数组方法" class="headerlink" title="Es 5数组方法"></a>Es 5数组方法</h1><p>大多数方法第一个参数接收一个函数，并对数组中每个元素调用一次该函数；</p><p>对于稀疏数组中不存在的元素（undefined），不调用传递函数；</p><p>调用函数一般提供3个参数：数组元素、元素索引、数组本身。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li>将数组的所有元素传递给指定函数，并返回一个包含该函数返回值的数组</li></ul><pre><code class="js">var a = [1,5];var b = a.map( function(x)&#123; return x*x;&#125;);//返回的是新数组哦</code></pre><h2 id="fileter"><a href="#fileter" class="headerlink" title="fileter"></a>fileter</h2><ul><li>返回数组元素的子集</li><li>只返回稠密数组（自动跳过稀疏数组中为空的元素）</li></ul><pre><code class="js">/*返回子集 */var a= [1,5,98,8];var b = a.filter(function(x)&#123;return x&gt;5;&#125;);//过滤var c = a.filter(function(x,y)&#123;return y%2==0;&#125;);/*压缩空缺*/var a = a.filter(function(x)&#123;return x!==undefined &amp;&amp; x!=null;&#125;);</code></pre><h2 id="every与some"><a href="#every与some" class="headerlink" title="every与some"></a>every与some</h2><ul><li><p>对数组元素按照指定的函数进行判定，返回布尔值</p></li><li><h4 id="every针对所有元素，some仅当一些元素"><a href="#every针对所有元素，some仅当一些元素" class="headerlink" title="every针对所有元素，some仅当一些元素"></a>every针对所有元素，some仅当一些元素</h4></li><li><p>一旦every与some确定结果，遍历便停止了</p><pre><code class="js">var a =[1,5,8,,9];a.every(function(x)&#123;return x &lt; 5 ;&#125;);//数组中全部元素大于5？否，返回falsea.some(function(x)&#123;return x &lt;5;&#125;);//数组中有元素大于5？yes，返回false</code></pre></li></ul><h2 id="reduce与reduceRight"><a href="#reduce与reduceRight" class="headerlink" title="reduce与reduceRight"></a>reduce与reduceRight</h2><ul><li>reduce 使用指定函数使数组元素相互结合，其有两个参数第一个是“到目前为止操作的结果”，第二个是初始值。（可不写初始值，默认数组第一个元素为初始值）</li></ul><pre><code class="js">var a = [1,2,5]var sum = a.reduce(function(x,y)&#123;return x+y&#125;，2)//sum =8var sum = a.reduce(function(x,y)&#123;return x+y&#125;)//sum =10</code></pre><ul><li>reduceRight和reduce操作相同，但其从右到左处理数组</li></ul><h2 id="indexOf-与-lastIndexOf"><a href="#indexOf-与-lastIndexOf" class="headerlink" title="indexOf 与 lastIndexOf"></a>indexOf 与 lastIndexOf</h2><ul><li>依照给定的值在数组中搜索元素，返回找到的第一个元素，不存在则返回-1</li><li>indexOf从头开始搜索 lastIndexOf从尾开始搜索</li><li>第一个参数是要搜索的值，第二个参数（可省略）指定从哪个索引开始搜索</li></ul><pre><code class="js">function findall(a,x)&#123;//传入数组与将要查找的值    var results = [],len = a.length,pos = 0;//    while(pos&lt;len)&#123;pos = indexOf(x,pos);//从索引o开始搜索    if(pos===-1)break;results.push(pos);pos +=1;//找不到结束；否则在数组results中存储索引，继续搜索&#125;return results;&#125;</code></pre><h1 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h1><ul><li>类数组对象没有继承自Array.prototype,但其仍可使用Function.call方法调用数组方法</li></ul><pre><code class="js">var a = &#123;&quot;0&quot;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3&#125;Array.prototype.join.call(a,&quot;+&quot;)//调用join方法Array.prototype.slice.call(a,0)//调用slice方法Array.prototype.map.call(a,function(x)&#123;return x.toLowerCase();&#125;)//调用map方法</code></pre><h1 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h1><ul><li><strong>charAt</strong> 方法可用来访问单个字符(即可对字符串采取索引访问操作)</li><li>数组的通用操作也适用于字符串</li></ul><pre><code class="js">var a = &quot;hello!&quot;a.charAt(2)//返回&#39;l&#39;Array.prototype.filter.call(a,function(x)&#123;return x.match(/[^aeiou]/);&#125;)//只匹配非元音字符</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区域</title>
      <link href="2022/03/20/jvm-01/"/>
      <url>2022/03/20/jvm-01/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><img src="https://i.loli.net/2020/07/30/eLwO5syKpnhjivJ.png" style="zoom:25%;" /><ul><li><p>程序计数器：每个线程都有一个程序计数器，它指示当前线程所执行字节码的行号</p></li><li><p>Java虚拟机栈：每个方法执行时均会创建一个栈帧，其存储<strong>局部变量表</strong>（基本类型与对象引用）、操作数栈、动态连接、方法出口等信息</p></li><li><p>本地方法栈：与Java虚拟机栈类似，其<strong>为本地方法服务</strong></p></li><li><p>Java堆（GC堆）：在虚拟机运行时创建用以存放对象实例，且为所有线程共享。</p></li><li><p>方法区：存储已被虚拟机加载的类型信息、常量、静态变量、编译后的代码缓存等数据，且为所有线程共享。</p><ol><li>运行时常量池：属于方法区，在加载类后class文件中的常量池表（字面量、符号引用）将存入运行时常量池</li></ol></li><li><p>直接内存（不属于运行时数据区域）：基于通道与缓冲区的I/O方式，其使用Native函数库直接分配堆外内存，并通过存储在Java堆中的<em>DirectByteBuffer</em>对象作为这块内存的引用进行操作</p></li></ul><h1 id="为对象分配内存："><a href="#为对象分配内存：" class="headerlink" title="为对象分配内存："></a>为对象分配内存：</h1><ul><li><p>创建对象时，虚拟机首先检测这个类是否已被<strong>加载、解析、初始化</strong>，如没有则首先执行<strong>类的加载过程</strong>。</p></li><li><p>垃圾收集器的<strong>空间整理能力</strong>决定<strong>堆是否规整</strong></p></li></ul><h2 id="分配堆内存的两种方式："><a href="#分配堆内存的两种方式：" class="headerlink" title="分配堆内存的两种方式："></a>分配堆内存的两种方式：</h2><h3 id="指针碰撞："><a href="#指针碰撞：" class="headerlink" title="指针碰撞："></a>指针碰撞：</h3><ul><li><strong>Java堆内存是规整的</strong>，有一个指针其两边分别是已使用、未使用的堆内存，分配内存时把指针向未使用的一边挪动一段与对象大小相同的距离</li></ul><p><img src="https://i.loli.net/2020/07/30/tV7RKAgXQWTykm5.png"></p><h3 id="空闲列表："><a href="#空闲列表：" class="headerlink" title="空闲列表："></a>空闲列表：</h3><ul><li><strong>Java堆内存不是规整的</strong>，使用与未使用的堆内存纵横交错，需要使用一个列表记录未使用的堆内存，分配内存时从列表中找到一块足够大的堆内存分配给对象</li></ul><p><img src="https://i.loli.net/2020/07/30/KoeInBvdQrjkEYS.png"></p><h2 id="对象内存分配的细节"><a href="#对象内存分配的细节" class="headerlink" title="对象内存分配的细节"></a>对象内存分配的细节</h2><ul><li>为对象分配堆内存空间时为防止<strong>同一时间创建多个对象的内存分配冲突</strong>（对象A、B分配同一块内存），可采用以下两种操作：</li></ul><ol><li>上锁：为分配的内存空间进行同步处理</li><li>闭包（本地线程分配缓冲）：为每个线程预先分配一块内存</li></ol><ul><li>分配完堆内存后，虚拟机将堆内存初始化值为0（对象头除外）</li><li>对象内存分为3个部分：对象头、实例数据、对其填充</li></ul><h1 id="对象、方法区"><a href="#对象、方法区" class="headerlink" title="对象、方法区"></a>对象、方法区</h1><h2 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h2><ul><li>句柄访问：Java栈中reference存储对象的句柄地址，句柄中包含对象的实例、类型数据的地址信息</li><li><img src="https://i.loli.net/2020/08/19/XxgJA5zpeWqZFt6.jpg" alt="screenshot_2020_07_30T15_08_55+0800" style="zoom:50%;" /></li><li>直接指针访问：Java栈中reference直接存储对象地址<img src="https://i.loli.net/2020/08/19/YsgivyGItW4ALkH.jpg" alt="screenshot_2020_07_31T16_03_41+0800" style="zoom:50%;" /></li></ul><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><ul><li><p>引用计数算法：每个对象都有一个引用计数器，每当被一个地方引用时计数器值便加一，每当失去一个引用计数器值便减一（不采用）</p></li><li><p>可达性分析算法：通过<strong>GCRoots</strong>根对象作为起点，根据引用关系向下搜索，构成一条<strong>引用链</strong>如果某个对象到<strong>GCRoots</strong>间没有任何引用链，那么这个对象就是可回收的。</p><img src="https://i.loli.net/2020/08/19/Jre7x8wUvLEchsP.jpg" alt="screenshot_2020_07_30T20_21_36+0800" style="zoom:50%;" /></li></ul><h2 id="回收对象："><a href="#回收对象：" class="headerlink" title="回收对象："></a>回收对象：</h2><ul><li>可达性分析算法中可回收的对象并<strong>不会被立即回收</strong>，而是对其进行第二次筛选；</li><li>如此对象有覆盖finalize（）方法且此方法且未被虚拟机调用，则执行finalize（）方法，并将其放入F—Queue队列中（<strong>低优先级的Finalizer线程</strong>将执行finalize（）方法），在此期间如<strong>对象与引用链建立联系则不会被回收</strong>（如赋值、引用等）</li></ul><h2 id="回收方法区："><a href="#回收方法区：" class="headerlink" title="回收方法区："></a>回收方法区：</h2><ul><li>方法区的垃圾回收分为两部分，<strong>废弃的常量</strong>与<strong>不再使用的类型</strong>：</li></ul><ol><li>废弃的常量：一个常量<strong>不被引用</strong>，则这个常量将被从常量池中清除（接口、方法、字段符号与之类似）</li><li>不再使用的类型：需要满足以下3个条件方<strong>可被回收</strong>（而不是立即回收）<ul><li>该类不存在<strong>任何实例</strong>（实例均被回收）</li><li>加载该类的<strong>加载器</strong>已被回收</li><li>该类对应的<strong>class对象没有被引用</strong>，且<strong>无法通过反射</strong>访问该类的方法</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
